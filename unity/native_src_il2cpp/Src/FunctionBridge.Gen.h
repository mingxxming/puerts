

// Auto Gen

#if !__SNC__
#ifndef __has_feature 
#define __has_feature(x) 0 
#endif
#endif

#if _MSC_VER
typedef wchar_t Il2CppChar;
#elif __has_feature(cxx_unicode_literals)
typedef char16_t Il2CppChar;
#else
typedef uint16_t Il2CppChar;
#endif

// Color
struct s_r4r4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
};
    
// Vector3
struct s_r4r4r4_
{
    float p0;
    float p1;
    float p2;
};
    
// Vector2
struct s_r4r4_
{
    float p0;
    float p1;
};
    
// GPathPoint
struct s_r4r4r4r4r4r4r4r4r4i4b_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    int32_t p9;
    bool p10;
};
    
// Margin
struct s_i4i4i4i4_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
};
    
// CharPosition
struct s_i4i2r4i2i2i2_
{
    int32_t p0;
    int16_t p1;
    float p2;
    int16_t p3;
    int16_t p4;
    int16_t p5;
};
    
// ClipInfo
struct s_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    bool p8;
    float p9;
    float p10;
    float p11;
    float p12;
    uint32_t p13;
    int32_t p14;
    int32_t p15;
    bool p16;
};
    
// Enumerator
struct s_osi4i4o_
{
    void* p0;
    void* p1;
    int32_t p2;
    int32_t p3;
    void* p4;
};
    
// MatAniInfo
struct s_oo_
{
    void* p0;
    void* p1;
};
    
// OrderRecord
struct s_si4_
{
    void* p0;
    int32_t p1;
};
    
// GIMsg
struct s_i4o_
{
    int32_t p0;
    void* p1;
};
    
// RawMsg
struct s_i4i4ss_
{
    int32_t p0;
    int32_t p1;
    void* p2;
    void* p3;
};
    
// PhyHitInfo
struct s_i8i8i8i8i8i8i8_
{
    int64_t p0;
    int64_t p1;
    int64_t p2;
    int64_t p3;
    int64_t p4;
    int64_t p5;
    int64_t p6;
};
    
// F64
struct s_i8_
{
    int64_t p0;
};
    
// FVector3
struct s_i8i8i8_
{
    int64_t p0;
    int64_t p1;
    int64_t p2;
};
    
// FQuaterion
struct s_i8i8i8i8_
{
    int64_t p0;
    int64_t p1;
    int64_t p2;
    int64_t p3;
};
    
// NavBuildSetting
struct s_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_
{
    int64_t p0;
    int64_t p1;
    int64_t p2;
    int64_t p3;
    int64_t p4;
    int64_t p5;
    int64_t p6;
    int64_t p7;
    int64_t p8;
    int64_t p9;
    int64_t p10;
    int64_t p11;
    int64_t p12;
    int64_t p13;
};
    
// StreamingContext
struct s_Oi4_
{
    void* p0;
    int32_t p1;
};
    
// NativeArray`1
struct s_Pvi4i4i4pi4i4oi4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
    int32_t p8;
};
    
// PlaybackState
struct s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_
{
    float p0;
    float p1;
    float p2;
    int32_t p3;
    float p4;
    float p5;
    uint32_t p6;
    uint32_t p7;
    uint32_t p8;
    uint32_t p9;
    uint32_t p10;
    uint32_t p11;
    uint32_t p12;
    uint32_t p13;
    uint32_t p14;
    uint32_t p15;
    uint32_t p16;
    uint32_t p17;
    uint32_t p18;
    uint32_t p19;
    uint32_t p20;
    uint32_t p21;
    uint32_t p22;
    uint32_t p23;
    uint32_t p24;
    uint32_t p25;
    uint32_t p26;
    uint32_t p27;
    uint32_t p28;
    uint32_t p29;
    uint32_t p30;
    uint32_t p31;
    uint32_t p32;
    uint32_t p33;
    uint32_t p34;
    uint32_t p35;
    uint32_t p36;
    uint32_t p37;
    uint32_t p38;
    uint32_t p39;
    uint32_t p40;
    uint32_t p41;
    float p42;
    float p43;
    float p44;
    float p45;
    float p46;
    float p47;
    int32_t p48;
    uint32_t p49;
    uint32_t p50;
    uint32_t p51;
    uint32_t p52;
    uint32_t p53;
    uint32_t p54;
    uint32_t p55;
    uint32_t p56;
    uint32_t p57;
    uint32_t p58;
    uint32_t p59;
    uint32_t p60;
    uint32_t p61;
    uint32_t p62;
    uint32_t p63;
    uint32_t p64;
    uint32_t p65;
    uint32_t p66;
    uint32_t p67;
    uint32_t p68;
    uint32_t p69;
    uint32_t p70;
    uint32_t p71;
    uint32_t p72;
    uint32_t p73;
    uint32_t p74;
    uint32_t p75;
    uint32_t p76;
    uint32_t p77;
    uint32_t p78;
    uint32_t p79;
    uint32_t p80;
    float p81;
    uint32_t p82;
    uint32_t p83;
    uint32_t p84;
    uint32_t p85;
    float p86;
    float p87;
};
    
// Trails
struct s_ooooi4i4_
{
    void* p0;
    void* p1;
    void* p2;
    void* p3;
    int32_t p4;
    int32_t p5;
};
    
// EmitParams
struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    float p22;
    float p23;
    int32_t p24;
    uint8_t p25;
    uint8_t p26;
    uint8_t p27;
    uint8_t p28;
    uint32_t p29;
    uint32_t p30;
    float p31;
    float p32;
    int32_t p33;
    float p34;
    float p35;
    uint32_t p36;
    bool p37;
    bool p38;
    bool p39;
    bool p40;
    bool p41;
    bool p42;
    bool p43;
    bool p44;
    bool p45;
    bool p46;
    bool p47;
};
    
// Particle
struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    float p22;
    float p23;
    int32_t p24;
    uint8_t p25;
    uint8_t p26;
    uint8_t p27;
    uint8_t p28;
    uint32_t p29;
    uint32_t p30;
    float p31;
    float p32;
    int32_t p33;
    float p34;
    float p35;
    uint32_t p36;
};
    
// Nullable`1
struct s_br4r4r4r4_
{
    bool p0;
    float p1;
    float p2;
    float p3;
    float p4;
};
    
// Nullable`1
struct s_bi4i4i4i4_
{
    bool p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    int32_t p4;
};
    
// RaycastHit
struct s_r4r4r4r4r4r4u4r4r4r4i4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    uint32_t p6;
    float p7;
    float p8;
    float p9;
    int32_t p10;
};
    
// Color32
struct s_i4u1u1u1u1_
{
    int32_t p0;
    uint8_t p1;
    uint8_t p2;
    uint8_t p3;
    uint8_t p4;
};
    
// Matrix4x4
struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
};
    
// LayerMask
struct s_i4_
{
    int32_t p0;
};
    
// Void
struct v
{
};
    
// Enumerator
struct s_oi4i4o_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    void* p3;
};
    
// Enumerator
struct s_oi4i4i4oi4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
};
    
// MainModule
struct s_o_
{
    void* p0;
};
    
// Enumerator
struct s_oi4i4i4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
};
    
// Enumerator
struct s_oi4i4s_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    void* p3;
};
    
// Enumerator
struct s_oi4i4O_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    void* p3;
};
    
// Enumerator
struct s_oi4i4soi4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    void* p3;
    void* p4;
    int32_t p5;
};
    
// Nullable`1
struct s_bi4o_
{
    bool p0;
    int32_t p1;
    void* p2;
};
    
// Nullable`1
struct s_bi4u1u1u1u1_
{
    bool p0;
    int32_t p1;
    uint8_t p2;
    uint8_t p3;
    uint8_t p4;
    uint8_t p5;
};
    
// NativeOverlapped
struct s_ppi4i4p_
{
    void* p0;
    void* p1;
    int32_t p2;
    int32_t p3;
    void* p4;
};
    
// Span`1
struct s_pi4_
{
    void* p0;
    int32_t p1;
};
    
// MeshGeneratorBuffers
struct s_i4oooo_
{
    int32_t p0;
    void* p1;
    void* p2;
    void* p3;
    void* p4;
};
    
// Vector2Int
struct s_i4i4_
{
    int32_t p0;
    int32_t p1;
};
    
// Call
struct s_Ps_i4i4i4_Ps_i4i4i4_oPs_i4i4i4_PPs_i4i4i4__
{
    struct s_i4i4i4_* p0;
    struct s_i4i4i4_* p1;
    void* p2;
    struct s_i4i4i4_* p3;
    struct s_i4i4i4_** p4;
};
    
// AsyncLocalValueChangedArgs`1
struct s_oob_
{
    void* p0;
    void* p1;
    bool p2;
};
    
// FileSystemEntry
struct s_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_
{
    struct s_u4u4i8i8i8i8i8i8i4u4u4c_* p0;
    void* p1;
    int32_t p2;
    void* p3;
    int32_t p4;
    void* p5;
    int32_t p6;
};
    
// BatchCullingContext
struct s_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
    int32_t p8;
    void* p9;
    int32_t p10;
    int32_t p11;
    int32_t p12;
    void* p13;
    int32_t p14;
    int32_t p15;
    void* p16;
    int32_t p17;
    void* p18;
    int32_t p19;
    int32_t p20;
    int32_t p21;
    void* p22;
    int32_t p23;
    int32_t p24;
    void* p25;
    int32_t p26;
    void* p27;
    int32_t p28;
    int32_t p29;
    int32_t p30;
    void* p31;
    int32_t p32;
    int32_t p33;
    void* p34;
    int32_t p35;
    int32_t p36;
    float p37;
    float p38;
    float p39;
    float p40;
    float p41;
    int32_t p42;
    float p43;
    float p44;
    float p45;
    float p46;
    float p47;
    float p48;
    float p49;
    float p50;
    float p51;
    float p52;
    float p53;
    float p54;
    float p55;
    float p56;
    float p57;
    float p58;
    float p59;
};
    
// DateTime
struct s_u8_
{
    uint64_t p0;
};
    
// CullingGroupEvent
struct s_i4u1u1_
{
    int32_t p0;
    uint8_t p1;
    uint8_t p2;
};
    
// DebugScreenCapture
struct s_Pvi4i4i4pi4i4oi4i4i4i4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
    int32_t p8;
    int32_t p9;
    int32_t p10;
    int32_t p11;
};
    
// PhraseRecognizedEventArgs
struct s_i4osu8i8_
{
    int32_t p0;
    void* p1;
    void* p2;
    uint64_t p3;
    int64_t p4;
};
    
// PhotoCaptureResult
struct s_i4i8_
{
    int32_t p0;
    int64_t p1;
};
    
// ScriptableRenderContext
struct s_ppi4i4_
{
    void* p0;
    void* p1;
    int32_t p2;
    int32_t p3;
};
    
// TimerState
struct s_i8i8_
{
    int64_t p0;
    int64_t p1;
};
    
// XRNodeState
struct s_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_
{
    int32_t p0;
    int32_t p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    int32_t p21;
    uint64_t p22;
};
    
// InputDevice
struct s_u8b_
{
    uint64_t p0;
    bool p1;
};
    
// MeshGenerationResult
struct s_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_
{
    uint64_t p0;
    uint64_t p1;
    void* p2;
    void* p3;
    int32_t p4;
    int32_t p5;
    uint64_t p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
};
    
// BuildPlayerOptions
struct s_ossi4i4i4i4o_
{
    void* p0;
    void* p1;
    void* p2;
    int32_t p3;
    int32_t p4;
    int32_t p5;
    int32_t p6;
    void* p7;
};
    
// CacheServerConnectionChangedParameters
struct s__
{
};
    
// CameraMode
struct s_i4ss_
{
    int32_t p0;
    void* p1;
    void* p2;
};
    
// ObjectChangeEventStream
struct s_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
    int32_t p8;
    void* p9;
    int32_t p10;
    int32_t p11;
    int32_t p12;
    void* p13;
    int32_t p14;
    int32_t p15;
    void* p16;
    int32_t p17;
};
    
// ActiveProfileChangedEventArgs
struct s_ss_
{
    void* p0;
    void* p1;
};
    
// ShortcutBindingChangedEventArgs
struct s_soo_
{
    void* p0;
    void* p1;
    void* p2;
};
    
// AuthCodeResponse
struct s_so_
{
    void* p0;
    void* p1;
};
    
// ObjectSelectorTargetInfo
struct s_u8u8u4u4u4u4i4oo_
{
    uint64_t p0;
    uint64_t p1;
    uint32_t p2;
    uint32_t p3;
    uint32_t p4;
    uint32_t p5;
    int32_t p6;
    void* p7;
    void* p8;
};
    
// PlayableGraph
struct s_pu4_
{
    void* p0;
    uint32_t p1;
};
    
// SubSceneInfo
struct s_oi4osi4u1u1u1u1_
{
    void* p0;
    int32_t p1;
    void* p2;
    void* p3;
    int32_t p4;
    uint8_t p5;
    uint8_t p6;
    uint8_t p7;
    uint8_t p8;
};
    
// TouchEvent
struct s_i4r4r4i4_
{
    int32_t p0;
    float p1;
    float p2;
    int32_t p3;
};
    
// NodeCreationContext
struct s_r4r4oi4_
{
    float p0;
    float p1;
    void* p2;
    int32_t p3;
};
    
// GraphViewChange
struct s_ooor4r4_
{
    void* p0;
    void* p1;
    void* p2;
    float p3;
    float p4;
};
    
// SearchColumnEventArgs
struct s_oooObr4r4r4r4bb_
{
    void* p0;
    void* p1;
    void* p2;
    void* p3;
    bool p4;
    float p5;
    float p6;
    float p7;
    float p8;
    bool p9;
    bool p10;
};
    
// SearchColumnCompareArgs
struct s_oooObr4r4r4r4bboooObr4r4r4r4bbb_
{
    void* p0;
    void* p1;
    void* p2;
    void* p3;
    bool p4;
    float p5;
    float p6;
    float p7;
    float p8;
    bool p9;
    bool p10;
    void* p11;
    void* p12;
    void* p13;
    void* p14;
    bool p15;
    float p16;
    float p17;
    float p18;
    float p19;
    bool p20;
    bool p21;
    bool p22;
};
    
// RenderTargetIdentifier
struct s_i4i4i4pi4i4i4_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    void* p3;
    int32_t p4;
    int32_t p5;
    int32_t p6;
};
    
// EventHook
struct s_sOO_
{
    void* p0;
    void* p1;
    void* p2;
};
    
// EditorCurveBinding
struct s_sosi4i4i4i4i4_
{
    void* p0;
    void* p1;
    void* p2;
    int32_t p3;
    int32_t p4;
    int32_t p5;
    int32_t p6;
    int32_t p7;
};
    
// GUID
struct s_u4u4u4u4_
{
    uint32_t p0;
    uint32_t p1;
    uint32_t p2;
    uint32_t p3;
};
    
// Bounds
struct s_r4r4r4r4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
};
    
// ParseResult`1
struct s_bo_
{
    bool p0;
    void* p1;
};
    
// Nullable`1
struct s_bi4_
{
    bool p0;
    int32_t p1;
};
    
// Nullable`1
struct s_bi8_
{
    bool p0;
    int64_t p1;
};
    
// Nullable`1
struct s_br4_
{
    bool p0;
    float p1;
};
    
// Nullable`1
struct s_br8_
{
    bool p0;
    double p1;
};
    
// Decimal
struct s_i4i4i4i4u8_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    uint64_t p4;
};
    
// Nullable`1
struct s_bi4i4i4i4u8_
{
    bool p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    int32_t p4;
    uint64_t p5;
};
    


// System.Object GetItemAssetByURL(System.String)
static bool w_Os(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_Os");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Object GetItemAsset(System.String, System.String)
static bool w_Oss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_Oss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Object get_initiator()
static bool w_Ot(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_Ot");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Object DynamicInvoke(System.Object[])
static bool w_OtVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_OtVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal ref params
    void* p0 = RestArguments<void*>::PackRef(context, info, TIp0, 0);
                

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Object Get(Int32)
static bool w_Oti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_Oti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Object GetItemAsset(FairyGUI.PackageItem)
static bool w_Oto(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_Oto");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Object GetItemAsset(System.String)
static bool w_Ots(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_Ots");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Object& Address(Int32)
static bool w_POti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_POti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void** (*FuncToCall)(void*,int32_t p0, const void* method);
    void** ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    // unknow ret signature: PO
    return true;
}

// Boolean get_developerConsoleVisible()
static bool w_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef bool (*FuncToCall)(const void* method);
    bool ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsTweening(System.Object)
static bool w_bO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef bool (*FuncToCall)(void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsTweening(System.Object, FairyGUI.TweenPropType)
static bool w_bOi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bOi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void* p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsArabicLetter(Char)
static bool w_bc(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bc");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(Il2CppChar p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CanStreamedLevelBeLoaded(Int32)
static bool w_bi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(int32_t p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Implicit(UnityEngine.Object)
static bool w_bo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bo");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef bool (*FuncToCall)(void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean GetRaycastHitFromCache(UnityEngine.Camera, UnityEngine.RaycastHit ByRef)
static bool w_boPs_r4r4r4r4r4r4u4r4r4r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_boPs_r4r4r4r4r4r4u4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Object, UnityEngine.Object)
static bool w_boo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_boo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef bool (*FuncToCall)(void* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CanStreamedLevelBeLoaded(System.String)
static bool w_bs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef bool (*FuncToCall)(void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Vector2, UnityEngine.Vector2)
static bool w_bs_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_bs_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Color, UnityEngine.Color)
static bool w_bs_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean GetAttributeBool(System.String, Boolean)
static bool w_bsb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bsb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void* p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean get_hasChanged()
static bool w_bt(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bt");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef bool (*FuncToCall)(void*,const void* method);
    bool ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(System.Object)
static bool w_btO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef bool (*FuncToCall)(void*,void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsAlive(Boolean)
static bool w_btb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(void*,bool p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean HasCharacter(Char)
static bool w_btc(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btc");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(void*,Il2CppChar p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean GetGlyph(Char, Single ByRef, Single ByRef, Single ByRef)
static bool w_btcPr4Pr4Pr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btcPr4Pr4Pr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(context, info[0]);
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[1]);
    float* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[2]);
    float* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    float up3 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[3]);
    float* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }

    typedef bool (*FuncToCall)(void*,Il2CppChar p0, float* p1, float* p2, float* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<float>::toScript(context, *p1));
    }
    
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<float>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<float>::toScript(context, *p3));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean ContainsKey(Int32)
static bool w_bti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(void*,int32_t p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Remove(Int32, System.Collections.Generic.List`1[UnityEngine.GameObject] ByRef)
static bool w_bti4Po(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4Po");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal Po/PO
    void* up1 = nullptr; // object ref
    void** p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        up1 = JsValueToCSRef(context, tp1, TIp1);
    }
        

    typedef bool (*FuncToCall)(void*,int32_t p0, void** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, CSRefToJsValue(isolate, context, *p1));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Seek(Int32, Int32)
static bool w_bti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean WalkAble(Int32, Int32, Int32, Int32)
static bool w_bti4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef bool (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryAdd(Int32, System.Collections.Generic.List`1[UnityEngine.GameObject])
static bool w_bti4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef bool (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsChildOf(UnityEngine.Transform)
static bool w_bto(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bto");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef bool (*FuncToCall)(void*,void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryGetComponent(System.Type, UnityEngine.Component ByRef)
static bool w_btoPo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btoPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Po/PO
    void* up1 = nullptr; // object ref
    void** p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        up1 = JsValueToCSRef(context, tp1, TIp1);
    }
        

    typedef bool (*FuncToCall)(void*,void* p0, void** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, CSRefToJsValue(isolate, context, *p1));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CompareTag(System.String)
static bool w_bts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef bool (*FuncToCall)(void*,void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean DispatchEvent(System.String, System.Object)
static bool w_btsO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btsO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef bool (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean DispatchEvent(System.String, System.Object, System.Object)
static bool w_btsOO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btsOO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef bool (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Remove(System.String, System.Collections.Generic.List`1[System.Int32] ByRef)
static bool w_btsPo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btsPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal Po/PO
    void* up1 = nullptr; // object ref
    void** p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        up1 = JsValueToCSRef(context, tp1, TIp1);
    }
        

    typedef bool (*FuncToCall)(void*,void* p0, void** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, CSRefToJsValue(isolate, context, *p1));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(GCore.FVector3, GCore.FVector3, Int64, Int32, Int32, Int32)
static bool w_bts_i8i8i8_s_i8i8i8_i8i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i8i8i8_s_i8i8i8_i8i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef bool (*FuncToCall)(void*,struct s_i8i8i8_ p0, struct s_i8i8i8_ p1, int64_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean RaycastSimple(GCore.FVector3, GCore.FVector3, Int64, Int32, Int32, Int32, Int64)
static bool w_bts_i8i8i8_s_i8i8i8_i8i4i4i4i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i8i8i8_s_i8i8i8_i8i4i4i4i8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int64_t p6 = converter::Converter<int64_t>::toCpp(context, info[6]);

    typedef bool (*FuncToCall)(void*,struct s_i8i8i8_ p0, struct s_i8i8i8_ p1, int64_t p2, int32_t p3, int32_t p4, int32_t p5, int64_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Vector2)
static bool w_bts_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Vector3)
static bool w_bts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Color)
static bool w_bts_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean HitTest(UnityEngine.Rect, UnityEngine.Vector2)
static bool w_bts_r4r4r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, struct s_r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean GetBool(System.String, Boolean)
static bool w_btsb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btsb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryAdd(System.String, System.Collections.Generic.List`1[System.Int32])
static bool w_btso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef bool (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean pay(System.String, System.String, System.String, Int32, Int32, System.String, Int64, System.String, System.Action`2[System.Int32,System.String])
static bool w_btsssi4i4si8so(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btsssi4i4si8so");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp7 = wrapData->TypeInfos[4];
    auto TIp8 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsString() && !info[5]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int64_t>::accept(context, info[6])) return false;
        if (!info[7]->IsString() && !info[7]->IsNullOrUndefined()) return false;
        if (!info[8]->IsNullOrUndefined() && (!info[8]->IsObject() || (info[8]->IsFunction() ? !IsDelegate(TIp8) : !IsAssignableFrom(TIp8, GetTypeId(info[8].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal s
    v8::String::Utf8Value tp5(isolate, info[5]);
    void* p5 = CStringToCSharpString(*tp5);
    // JSValToCSVal P any
    int64_t p6 = converter::Converter<int64_t>::toCpp(context, info[6]);
    // JSValToCSVal s
    v8::String::Utf8Value tp7(isolate, info[7]);
    void* p7 = CStringToCSharpString(*tp7);
    // JSValToCSVal o/O
    void* p8 = JsValueToCSRef(context, info[8], TIp8);

    typedef bool (*FuncToCall)(void*,void* p0, void* p1, void* p2, int32_t p3, int32_t p4, void* p5, int64_t p6, void* p7, void* p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean C_EnttValid(UInt32)
static bool w_btu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btu4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(void*,uint32_t p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean C_HasCom(UInt32, Int32)
static bool w_btu4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btu4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void*,uint32_t p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Char get_character()
static bool w_ct(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ct");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef Il2CppChar (*FuncToCall)(void*,const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int16 ReadShort()
static bool w_i2t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i2t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef int16_t (*FuncToCall)(void*,const void* method);
    int16_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 get_frameCount()
static bool w_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef int32_t (*FuncToCall)(const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 CharToHex(Char)
static bool w_i4c(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4c");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(context, info[0]);

    typedef int32_t (*FuncToCall)(Il2CppChar p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UnityEngine.StackTraceLogType GetStackTraceLogType(UnityEngine.LogType)
static bool w_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef int32_t (*FuncToCall)(int32_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetSQLConnCode(IntPtr)
static bool w_i4p(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4p");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);

    typedef int32_t (*FuncToCall)(void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 MapPos2Idx(IntPtr, GCore.F64 ByRef, GCore.F64 ByRef, Int32)
static bool w_i4pPs_i8_Ps_i8_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pPs_i8_Ps_i8_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8_* p1 = nullptr; // valuetype ref
    s_i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8_* p2 = nullptr; // valuetype ref
    s_i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef int32_t (*FuncToCall)(void* p0, struct s_i8_* p1, struct s_i8_* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 grid_pos2idx(IntPtr, GCore.FVector3 ByRef, Int32, Int32)
static bool w_i4pPs_i8i8i8_Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pPs_i8i8i8_Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef int32_t (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 grid_raycast(IntPtr, GCore.FVector3 ByRef, GCore.FVector3 ByRef, Int64 ByRef, Int32, Int32, Int32, GCore.FVector3 ByRef)
static bool w_i4pPs_i8i8i8_Ps_i8i8i8_Pi8i4i4i4Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pPs_i8i8i8_Ps_i8i8i8_Pi8i4i4i4Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p7 = nullptr; // valuetype ref
    s_i8i8i8_ up7;
    v8::Local<v8::Object> op7;
    if (!info[7].IsEmpty() && info[7]->IsObject()) {
        op7 = info[7]->ToObject(context).ToLocalChecked();
        auto tp7 = op7->Get(context, 0).ToLocalChecked();
        p7 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp7);
    }
    if (!p7) {
        p7 = &up7;
    }
        

    typedef int32_t (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, int64_t* p3, int32_t p4, int32_t p5, int32_t p6, struct s_i8i8i8_* p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    if (!op7.IsEmpty() && p7 == &up7)
    {
        auto _unused = op7->Set(context, 0, CopyValueType(isolate, context, TIp7, p7, sizeof(*p7)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 grid_raycastsm(IntPtr, GCore.FVector3 ByRef, GCore.FVector3 ByRef, Int64 ByRef, Int32, Int32, Int32, GCore.FVector3 ByRef, Int64 ByRef)
static bool w_i4pPs_i8i8i8_Ps_i8i8i8_Pi8i4i4i4Ps_i8i8i8_Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pPs_i8i8i8_Ps_i8i8i8_Pi8i4i4i4Ps_i8i8i8_Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsObject()) return false;
        if (!info[8]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p7 = nullptr; // valuetype ref
    s_i8i8i8_ up7;
    v8::Local<v8::Object> op7;
    if (!info[7].IsEmpty() && info[7]->IsObject()) {
        op7 = info[7]->ToObject(context).ToLocalChecked();
        auto tp7 = op7->Get(context, 0).ToLocalChecked();
        p7 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp7);
    }
    if (!p7) {
        p7 = &up7;
    }
        
    // JSValToCSVal P primitive
    int64_t up8 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[8]);
    int64_t* p8 = &up8;
    v8::Local<v8::Object> op8;
    if (!info[8].IsEmpty() && info[8]->IsObject()) {
        op8 = info[8]->ToObject(context).ToLocalChecked();
    }

    typedef int32_t (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, int64_t* p3, int32_t p4, int32_t p5, int32_t p6, struct s_i8i8i8_* p7, int64_t* p8, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    if (!op7.IsEmpty() && p7 == &up7)
    {
        auto _unused = op7->Set(context, 0, CopyValueType(isolate, context, TIp7, p7, sizeof(*p7)));
    }
            
    if (!op8.IsEmpty())
    {
        auto _unused = op8->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p8));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 doRaycast(IntPtr, GCore.FVector3 ByRef, GCore.FVector3 ByRef, GCore.F64 ByRef)
static bool w_i4pPs_i8i8i8_Ps_i8i8i8_Ps_i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pPs_i8i8i8_Ps_i8i8i8_Ps_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8_* p3 = nullptr; // valuetype ref
    s_i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef int32_t (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, struct s_i8_* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 findStraightPath(IntPtr, GCore.FVector3 ByRef, GCore.FVector3 ByRef, Int64[])
static bool w_i4pPs_i8i8i8_Ps_i8i8i8_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pPs_i8i8i8_Ps_i8i8i8_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef int32_t (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 ReadInt32(IntPtr, Int32)
static bool w_i4pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 entt_find_path(IntPtr, Int32, GCore.FVector3 ByRef, GCore.FVector3 ByRef, Int64[])
static bool w_i4pi4Ps_i8i8i8_Ps_i8i8i8_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pi4Ps_i8i8i8_Ps_i8i8i8_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);

    typedef int32_t (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 entt_phy_raycastall(IntPtr, Int32, GCore.FVector3 ByRef, GCore.FVector3 ByRef, GCore.PhyHitInfo[], Int64 ByRef)
static bool w_i4pi4Ps_i8i8i8_Ps_i8i8i8_oPi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pi4Ps_i8i8i8_Ps_i8i8i8_oPi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!info[5]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P primitive
    int64_t up5 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[5]);
    int64_t* p5 = &up5;
    v8::Local<v8::Object> op5;
    if (!info[5].IsEmpty() && info[5]->IsObject()) {
        op5 = info[5]->ToObject(context).ToLocalChecked();
    }

    typedef int32_t (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, void* p4, int64_t* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
            
    if (!op5.IsEmpty())
    {
        auto _unused = op5->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p5));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 randomInt(IntPtr, Int32, Int32)
static bool w_i4pi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void* p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 grid_walktype(IntPtr, Int32, Int32, Int32, Int32)
static bool w_i4pi4i4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pi4i4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef int32_t (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 grid_walkable(IntPtr, Int32, Int32, Int32, Int32)
static bool w_i4pi4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pi4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef int32_t (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 dump(IntPtr, Byte[])
static bool w_i4po(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef int32_t (*FuncToCall)(void* p0, void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 SQLRekey(IntPtr, Byte[], Int32)
static bool w_i4poi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4poi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void* p0, void* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 PGNoQuery(IntPtr, System.String)
static bool w_i4ps(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ps");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef int32_t (*FuncToCall)(void* p0, void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 entt_isvalid(IntPtr, UInt32)
static bool w_i4pu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pu4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void* p0, uint32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 entt_has_com(IntPtr, UInt32, Int32)
static bool w_i4pu4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pu4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void* p0, uint32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 entt_do_phytest(IntPtr, UInt32, GCore.PhyHitInfo[])
static bool w_i4pu4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pu4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef int32_t (*FuncToCall)(void* p0, uint32_t p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// DirectionType DetectTextDirection(System.String)
static bool w_i4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef int32_t (*FuncToCall)(void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetAttributeInt(System.String, Int32)
static bool w_i4si4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4si4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetHashCode()
static bool w_i4t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef int32_t (*FuncToCall)(void*,const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BinarySearch(System.Object)
static bool w_i4tO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef int32_t (*FuncToCall)(void*,void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 IndexOf(System.Object, Int32)
static bool w_i4tOi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tOi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 IndexOf(System.Object, Int32, Int32)
static bool w_i4tOi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tOi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BinarySearch(System.Object, System.Collections.Generic.IComparer`1[System.Object])
static bool w_i4tOo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tOo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef int32_t (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetTrails(Trails ByRef)
static bool w_i4tPs_ooooi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tPs_ooooi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_ooooi4i4_* p0 = nullptr; // valuetype ref
    s_ooooi4i4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_ooooi4i4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef int32_t (*FuncToCall)(void*,struct s_ooooi4i4_* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 EnsureCapacity(Int32)
static bool w_i4ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 IndexOf(Int32, Int32)
static bool w_i4ti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BinarySearch(Int32, Int32, System.Object, System.Collections.Generic.IComparer`1[System.Object])
static bool w_i4ti4i4Oo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4i4Oo");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, void* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 IndexOf(Int32, Int32, Int32)
static bool w_i4ti4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 WalkType(Int32, Int32, Int32, Int32)
static bool w_i4ti4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BinarySearch(Int32, Int32, Int32, System.Collections.Generic.IComparer`1[System.Int32])
static bool w_i4ti4i4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4i4i4o");
    
    auto TIp3 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 FindIndex(Int32, Int32, System.Predicate`1[UnityEngine.GameObject])
static bool w_i4ti4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4i4o");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BinarySearch(Int32, Int32, UnityEngine.GameObject, System.Collections.Generic.IComparer`1[UnityEngine.GameObject])
static bool w_i4ti4i4oo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4i4oo");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, void* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BinarySearch(Int32, Int32, System.String, System.Collections.Generic.IComparer`1[System.String])
static bool w_i4ti4i4so(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4i4so");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, void* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 FindIndex(Int32, System.Predicate`1[UnityEngine.GameObject])
static bool w_i4ti4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 Pos2Idx(Int64, Int64, Int32)
static bool w_i4ti8i8i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti8i8i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void*,int64_t p0, int64_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 Pos2Idx(Int64, Int64, Int32, Int32)
static bool w_i4ti8i8i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti8i8i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef int32_t (*FuncToCall)(void*,int64_t p0, int64_t p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 AddObstacle(Int64, Int64, Int64, Int64)
static bool w_i4ti8i8i8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti8i8i8i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);

    typedef int32_t (*FuncToCall)(void*,int64_t p0, int64_t p1, int64_t p2, int64_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BinarySearch(UnityEngine.GameObject)
static bool w_i4to(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4to");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef int32_t (*FuncToCall)(void*,void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 IndexOf(UnityEngine.GameObject, Int32)
static bool w_i4toi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4toi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 IndexOf(UnityEngine.GameObject, Int32, Int32)
static bool w_i4toi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4toi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BinarySearch(UnityEngine.GameObject, System.Collections.Generic.IComparer`1[UnityEngine.GameObject])
static bool w_i4too(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4too");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef int32_t (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 DrawGlyph(Single, Single, System.Collections.Generic.List`1[UnityEngine.Vector3], System.Collections.Generic.List`1[UnityEngine.Vector2], System.Collections.Generic.List`1[UnityEngine.Vector2], System.Collections.Generic.List`1[UnityEngine.Color32])
static bool w_i4tr4r4oooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tr4r4oooo");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);

    typedef int32_t (*FuncToCall)(void*,float p0, float p1, void* p2, void* p3, void* p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 DrawLine(Single, Single, Single, Int32, Int32, System.Collections.Generic.List`1[UnityEngine.Vector3], System.Collections.Generic.List`1[UnityEngine.Vector2], System.Collections.Generic.List`1[UnityEngine.Vector2], System.Collections.Generic.List`1[UnityEngine.Color32])
static bool w_i4tr4r4r4i4i4oooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tr4r4r4i4i4oooo");
    
    auto TIp5 = wrapData->TypeInfos[0];
    auto TIp6 = wrapData->TypeInfos[1];
    auto TIp7 = wrapData->TypeInfos[2];
    auto TIp8 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
        if (!info[8]->IsNullOrUndefined() && (!info[8]->IsObject() || (info[8]->IsFunction() ? !IsDelegate(TIp8) : !IsAssignableFrom(TIp8, GetTypeId(info[8].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);
    // JSValToCSVal o/O
    void* p8 = JsValueToCSRef(context, info[8], TIp8);

    typedef int32_t (*FuncToCall)(void*,float p0, float p1, float p2, int32_t p3, int32_t p4, void* p5, void* p6, void* p7, void* p8, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetInt(System.String)
static bool w_i4ts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef int32_t (*FuncToCall)(void*,void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle])
static bool w_i4ts_Pvi4i4i4pi4i4oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts_Pvi4i4i4pi4i4oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};

    typedef int32_t (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32)
static bool w_i4ts_Pvi4i4i4pi4i4oi4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts_Pvi4i4i4pi4i4oi4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32, Int32)
static bool w_i4ts_Pvi4i4i4pi4i4oi4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts_Pvi4i4i4pi4i4oi4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetInt(System.String, Int32)
static bool w_i4tsi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tsi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 IndexOf(System.String, Int32, Int32)
static bool w_i4tsi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tsi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BinarySearch(System.String, System.Collections.Generic.IComparer`1[System.String])
static bool w_i4tso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef int32_t (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 C_GetCrowdState(UInt32)
static bool w_i4tu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tu4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);

    typedef int32_t (*FuncToCall)(void*,uint32_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int64 f_log(Int64 ByRef)
static bool w_i8Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8Pi8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    
    // JSValToCSVal P primitive
    int64_t up0 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[0]);
    int64_t* p0 = &up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
    }

    typedef int64_t (*FuncToCall)(int64_t* p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    if (!op0.IsEmpty())
    {
        auto _unused = op0->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p0));
    }
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 f_mul(Int64 ByRef, Int64 ByRef)
static bool w_i8Pi8Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8Pi8Pi8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal P primitive
    int64_t up0 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[0]);
    int64_t* p0 = &up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up1 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[1]);
    int64_t* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }

    typedef int64_t (*FuncToCall)(int64_t* p0, int64_t* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty())
    {
        auto _unused = op0->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p0));
    }
    
    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p1));
    }
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 fv_magnitude(GCore.FVector3 ByRef)
static bool w_i8Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef int64_t (*FuncToCall)(struct s_i8i8i8_* p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 fv_dot(GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_i8Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef int64_t (*FuncToCall)(struct s_i8i8i8_* p0, struct s_i8i8i8_* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 fq_length2(GCore.FQuaterion ByRef)
static bool w_i8Ps_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8Ps_i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef int64_t (*FuncToCall)(struct s_i8i8i8i8_* p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 SetRVOAgentRadius(IntPtr, GCore.F64 ByRef)
static bool w_i8pPs_i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8pPs_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8_* p1 = nullptr; // valuetype ref
    s_i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef int64_t (*FuncToCall)(void* p0, struct s_i8_* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 AddRvoAgent(IntPtr, GCore.F64 ByRef, GCore.F64 ByRef, GCore.FVector3 ByRef)
static bool w_i8pPs_i8_Ps_i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8pPs_i8_Ps_i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8_* p1 = nullptr; // valuetype ref
    s_i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8_* p2 = nullptr; // valuetype ref
    s_i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef int64_t (*FuncToCall)(void* p0, struct s_i8_* p1, struct s_i8_* p2, struct s_i8i8i8_* p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 ReadInt64(IntPtr, Int32)
static bool w_i8pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int64_t (*FuncToCall)(void* p0, int32_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 ReadLong()
static bool w_i8t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef int64_t (*FuncToCall)(void*,const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 ReadInt64(Int32)
static bool w_i8ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8ti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef int64_t (*FuncToCall)(void*,int32_t p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 C_NavRaycast(Int32, GCore.FVector3, GCore.FVector3)
static bool w_i8ti4s_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8ti4s_i8i8i8_s_i8i8i8_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef int64_t (*FuncToCall)(void*,int32_t p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 C_Sin(Int64)
static bool w_i8ti8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8ti8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);

    typedef int64_t (*FuncToCall)(void*,int64_t p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 C_Mul(Int64, Int64)
static bool w_i8ti8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8ti8i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);

    typedef int64_t (*FuncToCall)(void*,int64_t p0, int64_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 AddAgent(Int64, Int64, Int64, Int64)
static bool w_i8ti8i8i8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8ti8i8i8i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);

    typedef int64_t (*FuncToCall)(void*,int64_t p0, int64_t p1, int64_t p2, int64_t p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 Dot(GCore.FVector3)
static bool w_i8ts_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8ts_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};

    typedef int64_t (*FuncToCall)(void*,struct s_i8i8i8_ p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 NavRaycast(System.String, GCore.FVector3, GCore.FVector3)
static bool w_i8tss_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8tss_i8i8i8_s_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef int64_t (*FuncToCall)(void*,void* p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// UnityEngine.ILogger get_unityLogger()
static bool w_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_o");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef void* (*FuncToCall)(const void* method);
    void* ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener GetTween(System.Object)
static bool w_oO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener GetTween(System.Object, FairyGUI.TweenPropType)
static bool w_oOi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oOi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate Combine(System.Delegate[])
static bool w_oVo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
        if (!info[0]->IsNullOrUndefined() && !info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal ref params
    void* p0 = RestArguments<void*>::PackRef(context, info, TIp0, 0);
                

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.GameObject CreatePrimitive(UnityEngine.PrimitiveType)
static bool w_oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RenderTexture CreateRenderTexture(Int32, Int32, Boolean)
static bool w_oi4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4i4b");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(int32_t p0, int32_t p1, bool p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object)
static bool w_oo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GObject NewObject(FairyGUI.PackageItem, System.Type)
static bool w_ooDo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal ref  with default
    void* p1 = OptionalParameter<void*>::GetRefType(context, info, method, 1, TIp1);
                

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.Reflection.MethodInfo)
static bool w_ooOo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooOo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.Reflection.MethodInfo, Boolean)
static bool w_ooOob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooOob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, bool p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.String)
static bool w_ooOs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooOs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.String, Boolean)
static bool w_ooOsb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooOsb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, bool p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.String, Boolean, Boolean)
static bool w_ooOsbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooOsbb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, bool p3, bool p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object[] FindObjectsOfType(System.Type, Boolean)
static bool w_oob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object[] FindObjectsByType(System.Type, UnityEngine.FindObjectsSortMode)
static bool w_ooi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object[] FindObjectsByType(System.Type, UnityEngine.FindObjectsInactive, UnityEngine.FindObjectsSortMode)
static bool w_ooi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, int32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Transform)
static bool w_ooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Transform, Boolean)
static bool w_ooob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void* p0, void* p1, bool p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.UIPackage AddPackage(UnityEngine.AssetBundle, UnityEngine.AssetBundle, System.String)
static bool w_ooos(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Type, System.String, Boolean)
static bool w_ooosb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooosb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, bool p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Type, System.String, Boolean, Boolean)
static bool w_ooosbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooosbb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, bool p3, bool p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Vector3, UnityEngine.Quaternion)
static bool w_oos_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oos_r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void* (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Transform)
static bool w_oos_r4r4r4_s_r4r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oos_r4r4r4_s_r4r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void* (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, void* p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.UIPackage AddPackage(Byte[], System.String, LoadResource)
static bool w_ooso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener DelayedCall(Single)
static bool w_or4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_or4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(float p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener To(Single, Single, Single)
static bool w_or4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_or4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(float p0, float p1, float p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener ToDouble(Double, Double, Single)
static bool w_or8r8r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_or8r8r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<double>::accept(context, info[0])) return false;
        if (!converter::Converter<double>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(context, info[0]);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(double p0, double p1, float p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.GameObject FindWithTag(System.String)
static bool w_os(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener To(UnityEngine.Vector2, UnityEngine.Vector2, Single)
static bool w_os_r4r4_s_r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4_s_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, float p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener Shake(UnityEngine.Vector3, Single, Single)
static bool w_os_r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, float p1, float p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener To(UnityEngine.Vector3, UnityEngine.Vector3, Single)
static bool w_os_r4r4r4_s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener To(UnityEngine.Vector4, UnityEngine.Vector4, Single)
static bool w_os_r4r4r4r4_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4r4_s_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, float p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Camera CreateCamera(System.String, Int32)
static bool w_osi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_osi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.UIPackage AddPackage(System.String, LoadResource)
static bool w_oso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GObject CreateObject(System.String, System.String)
static bool w_oss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GObject CreateObject(System.String, System.String, System.Type)
static bool w_osso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_osso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Transform get_parent()
static bool w_ot(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ot");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener SetTarget(System.Object)
static bool w_otO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener SetTarget(System.Object, FairyGUI.TweenPropType)
static bool w_otOi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otOi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.Generic.IEnumerator`1[FairyGUI.DisplayObject] GetDescendants(Boolean)
static bool w_otb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otb");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,bool p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Transform GetChild(Int32)
static bool w_oti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener SetRepeat(Int32, Boolean)
static bool w_oti4Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4Db");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void* (*FuncToCall)(void*,int32_t p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.DisplayObject RemoveChildAt(Int32, Boolean)
static bool w_oti4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4b");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,int32_t p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.Generic.List`1[UnityEngine.GameObject] GetRange(Int32, Int32)
static bool w_oti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// Int32[] GetOccupyCells(Int32, Int32, Int32)
static bool w_oti4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// Int32[] FindPath(Int32, Int32, Int32, Int32, Int32)
static bool w_oti4i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Material GetMaterial(Int32, FairyGUI.BlendMode, UInt32)
static bool w_oti4i4u4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4i4u4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void*,int32_t p0, int32_t p1, uint32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener SetEase(FairyGUI.EaseType, FairyGUI.CustomEase)
static bool w_oti4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// GCore.HtpServer NewServer(Int32, System.String)
static bool w_oti4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.Generic.List`1[GCore.FVector3] C_FindPath(Int32, GCore.FVector3, GCore.FVector3)
static bool w_oti4s_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4s_i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef void* (*FuncToCall)(void*,int32_t p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// GCore.PhyHitInfo[] C_PhyRaycastAll(Int32, GCore.FVector3, GCore.FVector3, Int64, Int32 ByRef)
static bool w_oti4s_i8i8i8_s_i8i8i8_i8Pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4s_i8i8i8_s_i8i8i8_i8Pi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!info[4]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P primitive
    int32_t up4 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(context, info[4]);
    int32_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }

    typedef void* (*FuncToCall)(void*,int32_t p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, int64_t p3, int32_t* p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int32_t>::toScript(context, *p4));
    }
    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// GCore.C_GridMap CreateGridMap(Int64, Int64, Int32, Int32, Int32)
static bool w_oti8i8Di4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti8i8Di4Di4Di4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef void* (*FuncToCall)(void*,int64_t p0, int64_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.GameObject Find(System.Predicate`1[UnityEngine.GameObject])
static bool w_oto(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oto");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.IEnumerator checkDBUpdate(System.Action`2[System.Int64,System.Int32], Boolean)
static bool w_otoDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otoDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void* (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Component GetComponentInChildren(System.Type, Boolean)
static bool w_otob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.DisplayObject AddChildAt(FairyGUI.DisplayObject, Int32)
static bool w_otoi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otoi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// Byte[] ReadBytes(Byte[], Int32, Int32)
static bool w_otoi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otoi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.Utils.IHtmlObject CreateObject(FairyGUI.RichTextField, FairyGUI.Utils.HtmlElement)
static bool w_otoo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GObject GetChildInGroup(FairyGUI.GGroup, System.String)
static bool w_otos(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Component AddOrGetComponent(UnityEngine.GameObject, System.String, Boolean)
static bool w_otosDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otosDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, bool p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.IEnumerator Print(Single)
static bool w_otr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otr4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,float p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener TweenMoveX(Single, Single)
static bool w_otr4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otr4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,float p0, float p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener TweenValue(Double, Single)
static bool w_otr8r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otr8r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<double>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,double p0, float p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Transform Find(System.String)
static bool w_ots(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.IEnumerator loadScene(System.String, UnityEngine.SceneManagement.LoadSceneMode, System.Action`2[System.Single,System.Boolean])
static bool w_otsDi4Do(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsDi4Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal ref  with default
    void* p2 = OptionalParameter<void*>::GetRefType(context, info, method, 2, TIp2);
                

    typedef void* (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.Generic.List`1[System.String] collectDependences(System.String, System.Collections.Generic.List`1[System.String])
static bool w_otsDo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal ref  with default
    void* p1 = OptionalParameter<void*>::GetRefType(context, info, method, 1, TIp1);
                

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Object[] DoString(System.String, System.String)
static bool w_otsDs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsDs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal string  with default
    void* p1 = OptionalParameter<void*>::GetString(context, info, method, 1);
                

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Coroutine StartCoroutine(System.String, System.Object)
static bool w_otsO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Object[] CallFunction(System.String, System.Object[])
static bool w_otsVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal ref params
    void* p1 = RestArguments<void*>::PackRef(context, info, TIp1, 1);
                

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Texture2D GetScreenShot(System.Nullable`1[FairyGUI.Margin], Single)
static bool w_ots_bi4i4i4i4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots_bi4i4i4i4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_bi4i4i4i4_* pp0 = DataTransfer::GetPointer<s_bi4i4i4i4_>(context, info[0]);
    s_bi4i4i4i4_ p0 = pp0 ? *pp0 : s_bi4i4i4i4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,struct s_bi4i4i4i4_ p0, float p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// Int32[] GetTriangleOccupyCells(GCore.FVector3, GCore.FVector3, GCore.FVector3)
static bool w_ots_i8i8i8_s_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots_i8i8i8_s_i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef void* (*FuncToCall)(void*,struct s_i8i8i8_ p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// Int32[] GetRectOccupyCells(GCore.FVector3, GCore.FVector3, GCore.FVector3, GCore.FVector3)
static bool w_ots_i8i8i8_s_i8i8i8_s_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots_i8i8i8_s_i8i8i8_s_i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp3 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[3]);
    s_i8i8i8_ p3 = pp3 ? *pp3 : s_i8i8i8_ {};

    typedef void* (*FuncToCall)(void*,struct s_i8i8i8_ p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, struct s_i8i8i8_ p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.DisplayObject HitTest(UnityEngine.Vector2, Boolean)
static bool w_ots_r4r4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots_r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,struct s_r4r4_ p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener TweenMove(UnityEngine.Vector2, Single)
static bool w_ots_r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,struct s_r4r4_ p0, float p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// Client.LineRendererHelp Init(UnityEngine.Vector3, UnityEngine.Vector3, Int32)
static bool w_ots_r4r4r4_s_r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots_r4r4r4_s_r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, int32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// Puerts.ArrayBuffer LoadEditorMap(System.String, Boolean)
static bool w_otsb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.String[] GetAttributeArray(System.String, Char)
static bool w_otsc(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsc");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,void* p0, Il2CppChar p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GButton AddItemAt(System.String, Int32, FairyGUI.EventCallback1)
static bool w_otsi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsi4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GButton AddItem(System.String, FairyGUI.EventCallback0)
static bool w_otso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTextField SetVar(System.String, System.String)
static bool w_otss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.Generic.List`1[System.Int64] FindNavPath(System.String, GCore.FVector3, GCore.FVector3)
static bool w_otss_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otss_i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef void* (*FuncToCall)(void*,void* p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.IEnumerator getWebRequestTexture(System.String, System.String, System.Action`1[UnityEngine.Texture2D])
static bool w_otsso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.AssetBundle loadBundle(System.String, UInt32)
static bool w_otsu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsu4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,void* p0, uint32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.IEnumerator syncLoadBundle(System.String, UInt32, System.Action`1[UnityEngine.AssetBundle])
static bool w_otsu4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsu4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void*,void* p0, uint32_t p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// GCore.PhyHitInfo[] C_DoPhyTest(UInt32, Int32 ByRef)
static bool w_otu4Pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otu4Pi4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(context, info[1]);
    int32_t* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }

    typedef void* (*FuncToCall)(void*,uint32_t p0, int32_t* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<int32_t>::toScript(context, *p1));
    }
    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// IntPtr grid_create(Int64 ByRef, Int64 ByRef, Int32, Int32, Int32)
static bool w_pPi8Pi8Di4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pPi8Pi8Di4Di4Di4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P primitive
    int64_t up0 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[0]);
    int64_t* p0 = &up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up1 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[1]);
    int64_t* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef void* (*FuncToCall)(int64_t* p0, int64_t* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op0.IsEmpty())
    {
        auto _unused = op0->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p0));
    }
    
    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p1));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr NewRvoSimulator(GCore.F64 ByRef)
static bool w_pPs_i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pPs_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8_* p0 = nullptr; // valuetype ref
    s_i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef void* (*FuncToCall)(struct s_i8_* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr NewRandMap(Int32, Int32, Int32, GCore.F64 ByRef, Int32, Int32, Int32)
static bool w_pi4i4i4Ps_i8_i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pi4i4i4Ps_i8_i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal Pstruct
    s_i8_* p3 = nullptr; // valuetype ref
    s_i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef void* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, struct s_i8_* p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr entt_create_world(Int32, IntPtr, Int64 ByRef, Int64 ByRef, GCore.OnCollideCallback, GCore.RunActionCallback)
static bool w_pi4pPi8Pi8oo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pi4pPi8Pi8oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[2]);
    int64_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);

    typedef void* (*FuncToCall)(int32_t p0, void* p1, int64_t* p2, int64_t* p3, void* p4, void* p5, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr load(Byte[])
static bool w_po(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_po");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr buildSimple(GCore.F64[], Int32, Int32[], Int32, Int64 ByRef, Int64 ByRef, Int64 ByRef, Int64 ByRef)
static bool w_poi4oi4Pi8Pi8Pi8Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_poi4oi4Pi8Pi8Pi8Pi8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsObject()) return false;
        if (!info[5]->IsObject()) return false;
        if (!info[6]->IsObject()) return false;
        if (!info[7]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P primitive
    int64_t up4 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[4]);
    int64_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up5 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[5]);
    int64_t* p5 = &up5;
    v8::Local<v8::Object> op5;
    if (!info[5].IsEmpty() && info[5]->IsObject()) {
        op5 = info[5]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up6 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[6]);
    int64_t* p6 = &up6;
    v8::Local<v8::Object> op6;
    if (!info[6].IsEmpty() && info[6]->IsObject()) {
        op6 = info[6]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up7 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[7]);
    int64_t* p7 = &up7;
    v8::Local<v8::Object> op7;
    if (!info[7].IsEmpty() && info[7]->IsObject()) {
        op7 = info[7]->ToObject(context).ToLocalChecked();
    }

    typedef void* (*FuncToCall)(void* p0, int32_t p1, void* p2, int32_t p3, int64_t* p4, int64_t* p5, int64_t* p6, int64_t* p7, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p4));
    }
    
    if (!op5.IsEmpty())
    {
        auto _unused = op5->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p5));
    }
    
    if (!op6.IsEmpty())
    {
        auto _unused = op6->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p6));
    }
    
    if (!op7.IsEmpty())
    {
        auto _unused = op7->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p7));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr build(GCore.F64[], Int32, Int32[], Int32, GCore.NavBuildSetting ByRef)
static bool w_poi4oi4Ps_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_poi4oi4Ps_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal Pstruct
    s_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_* p4 = nullptr; // valuetype ref
    s_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_ up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
        auto tp4 = op4->Get(context, 0).ToLocalChecked();
        p4 = DataTransfer::GetPointer<s_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_>(context, tp4);
    }
    if (!p4) {
        p4 = &up4;
    }
        

    typedef void* (*FuncToCall)(void* p0, int32_t p1, void* p2, int32_t p3, struct s_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_* p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op4.IsEmpty() && p4 == &up4)
    {
        auto _unused = op4->Set(context, 0, CopyValueType(isolate, context, TIp4, p4, sizeof(*p4)));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr SQLReader(IntPtr)
static bool w_pp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pp");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr entt_create_gridmap(IntPtr, Int64 ByRef, Int64 ByRef, Int32, Int32, Int32)
static bool w_ppPi8Pi8i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ppPi8Pi8i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P primitive
    int64_t up1 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[1]);
    int64_t* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[2]);
    int64_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void* (*FuncToCall)(void* p0, int64_t* p1, int64_t* p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p1));
    }
    
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p2));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr AddRVOObstacle(IntPtr, GCore.F64 ByRef, GCore.F64 ByRef, GCore.FVector3 ByRef)
static bool w_ppPs_i8_Ps_i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ppPs_i8_Ps_i8_Ps_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8_* p1 = nullptr; // valuetype ref
    s_i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8_* p2 = nullptr; // valuetype ref
    s_i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef void* (*FuncToCall)(void* p0, struct s_i8_* p1, struct s_i8_* p2, struct s_i8i8i8_* p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr ReadText(IntPtr, Int32)
static bool w_ppi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ppi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr entt_set_phy_friction(IntPtr, UInt32, Int64 ByRef)
static bool w_ppu4Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ppu4Pi8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[2]);
    int64_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }

    typedef void* (*FuncToCall)(void* p0, uint32_t p1, int64_t* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p2));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr entt_add_meshphy(IntPtr, UInt32, Int64[], Int32, Int32[], Int32, Int32, Int64 ByRef, Int32, Int32, Int64 ByRef, Int32)
static bool w_ppu4oi4oi4i4Pi8i4i4Pi8i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ppu4oi4oi4i4Pi8i4i4Pi8i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 12) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[9])) return false;
        if (!info[10]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[11])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P primitive
    int64_t up7 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[7]);
    int64_t* p7 = &up7;
    v8::Local<v8::Object> op7;
    if (!info[7].IsEmpty() && info[7]->IsObject()) {
        op7 = info[7]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(context, info[9]);
    // JSValToCSVal P primitive
    int64_t up10 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[10]);
    int64_t* p10 = &up10;
    v8::Local<v8::Object> op10;
    if (!info[10].IsEmpty() && info[10]->IsObject()) {
        op10 = info[10]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(context, info[11]);

    typedef void* (*FuncToCall)(void* p0, uint32_t p1, void* p2, int32_t p3, void* p4, int32_t p5, int32_t p6, int64_t* p7, int32_t p8, int32_t p9, int64_t* p10, int32_t p11, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    if (!op7.IsEmpty())
    {
        auto _unused = op7->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p7));
    }
    
    if (!op10.IsEmpty())
    {
        auto _unused = op10->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p10));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr OpenPGSQL(System.String)
static bool w_ps(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ps");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr OpenSqlite(System.String, Int32, Byte[], Int32)
static bool w_psi4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_psi4oi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, void* p2, int32_t p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// Single get_time()
static bool w_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef float (*FuncToCall)(const void* method);
    float ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Evaluate(FairyGUI.EaseType, Single, Single, Single, Single, FairyGUI.CustomEase)
static bool w_r4i4r4r4Dr4Dr4Do(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4i4r4r4Dr4Dr4Do");
    
    auto TIp5 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<float>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<float>::accept(context, info[4])) return false;
        if (length > 5 && !info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    float p4 = OptionalParameter<float>::GetPrimitive(context, info, method, 4);
                
    // JSValToCSVal ref  with default
    void* p5 = OptionalParameter<void*>::GetRefType(context, info, method, 5, TIp5);
                

    typedef float (*FuncToCall)(int32_t p0, float p1, float p2, float p3, float p4, void* p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GetAttributeFloat(System.String)
static bool w_r4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef float (*FuncToCall)(void* p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single SqrMagnitude(UnityEngine.Vector2)
static bool w_r4s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Dot(UnityEngine.Vector2, UnityEngine.Vector2)
static bool w_r4s_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Magnitude(UnityEngine.Vector3)
static bool w_r4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Dot(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_r4s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single SignedAngle(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_r4s_r4r4r4_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4_s_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Magnitude(UnityEngine.Vector4)
static bool w_r4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4r4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Dot(UnityEngine.Vector4, UnityEngine.Vector4)
static bool w_r4s_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GetAttributeFloat(System.String, Single)
static bool w_r4sr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4sr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef float (*FuncToCall)(void* p0, float p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single get_grayscale()
static bool w_r4t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef float (*FuncToCall)(void*,const void* method);
    float ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single get_Item(Int32)
static bool w_r4ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4ti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef float (*FuncToCall)(void*,int32_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Evaluate(Single)
static bool w_r4tr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4tr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef float (*FuncToCall)(void*,float p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GetLabelTime(System.String)
static bool w_r4ts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4ts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef float (*FuncToCall)(void*,void* p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GetFloat(System.String, Single)
static bool w_r4tsr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4tsr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef float (*FuncToCall)(void*,void* p0, float p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Double get_timeAsDouble()
static bool w_r8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef double (*FuncToCall)(const void* method);
    double ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Double ReadDouble(IntPtr, Int32)
static bool w_r8pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r8pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef double (*FuncToCall)(void* p0, int32_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Double get_min()
static bool w_r8t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r8t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef double (*FuncToCall)(void*,const void* method);
    double ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Double ReadDouble(Int32)
static bool w_r8ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r8ti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef double (*FuncToCall)(void*,int32_t p0, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// System.String get_buildGUID()
static bool w_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef void* (*FuncToCall)(const void* method);
    void* ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetRawText(Boolean)
static bool w_sDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sDb");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<bool>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(context, info, method, 0);
                

    typedef void* (*FuncToCall)(bool p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String toMessage(System.Object[])
static bool w_sVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
    }
    
    // JSValToCSVal ref params
    void* p0 = RestArguments<void*>::PackRef(context, info, TIp0, 0);
                

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Nullable`1[GCore.GIMsg] ConsumeReceiveMsg()
static bool w_s_bi4o_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_bi4o_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_bi4o_ (*FuncToCall)(void*,const void* method);
    struct s_bi4o_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.Nullable`1[UnityEngine.Rect] get_clipRect()
static bool w_s_br4r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_br4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_br4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_br4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.SceneManagement.Scene get_scene()
static bool w_s_i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4_ (*FuncToCall)(void*,const void* method);
    struct s_i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// FairyGUI.Margin get_margin()
static bool w_s_i4i4i4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct s_i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.F64 op_Implicit(Int32)
static bool w_s_i8_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_i8_ (*FuncToCall)(int32_t p0, const void* method);
    struct s_i8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.F64 op_Implicit(Int64)
static bool w_s_i8_i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8_i8");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);

    typedef struct s_i8_ (*FuncToCall)(int64_t p0, const void* method);
    struct s_i8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.F64 op_Implicit(Single)
static bool w_s_i8_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef struct s_i8_ (*FuncToCall)(float p0, const void* method);
    struct s_i8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 Get(Int64, Int64, Int64)
static bool w_s_i8i8i8_Di8Di8Di8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_Di8Di8Di8");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int64_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal primitive with default
    int64_t p0 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int64_t p1 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int64_t p2 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 2);
                

    typedef struct s_i8i8i8_ (*FuncToCall)(int64_t p0, int64_t p1, int64_t p2, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 op_Multiply(GCore.FVector3, Int64)
static bool w_s_i8i8i8_s_i8i8i8_i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_s_i8i8i8_i8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);

    typedef struct s_i8i8i8_ (*FuncToCall)(struct s_i8i8i8_ p0, int64_t p1, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 op_Addition(GCore.FVector3, GCore.FVector3)
static bool w_s_i8i8i8_s_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_s_i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};

    typedef struct s_i8i8i8_ (*FuncToCall)(struct s_i8i8i8_ p0, struct s_i8i8i8_ p1, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 C_FVector()
static bool w_s_i8i8i8_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 Idx2Pos(Int32)
static bool w_s_i8i8i8_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 Idx2Pos(Int32, Int32, Int32)
static bool w_s_i8i8i8_ti4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_ti4Di4Di4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 Cr2Pos(Int32, Int32)
static bool w_s_i8i8i8_ti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_ti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 C_FindNearestPos(Int32, GCore.FVector3, Int64)
static bool w_s_i8i8i8_ti4s_i8i8i8_i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_ti4s_i8i8i8_i8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,int32_t p0, struct s_i8i8i8_ p1, int64_t p2, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 C_GetSurfacePos(Int32, GCore.FVector3, GCore.FVector3)
static bool w_s_i8i8i8_ti4s_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_ti4s_i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,int32_t p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 GetAgentPosition(Int64)
static bool w_s_i8i8i8_ti8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_ti8");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,int64_t p0, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 Cross(GCore.FVector3)
static bool w_s_i8i8i8_ts_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_ts_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,struct s_i8i8i8_ p0, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 RotateByRad(GCore.FVector3, Int64)
static bool w_s_i8i8i8_ts_i8i8i8_i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_ts_i8i8i8_i8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,struct s_i8i8i8_ p0, int64_t p1, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 GetNearest(System.String, GCore.FVector3, GCore.FVector3)
static bool w_s_i8i8i8_tss_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_tss_i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,void* p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 C_GetPosition(UInt32)
static bool w_s_i8i8i8_tu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_tu4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,uint32_t p0, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 C_Local2World(UInt32, GCore.FVector3)
static bool w_s_i8i8i8_tu4s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_tu4s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,uint32_t p0, struct s_i8i8i8_ p1, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FQuaterion Get(Int64, Int64, Int64, Int64)
static bool w_s_i8i8i8i8_Di8Di8Di8Di8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8_Di8Di8Di8Di8");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal primitive with default
    int64_t p0 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int64_t p1 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int64_t p2 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int64_t p3 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 3);
                

    typedef struct s_i8i8i8i8_ (*FuncToCall)(int64_t p0, int64_t p1, int64_t p2, int64_t p3, const void* method);
    struct s_i8i8i8i8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FQuaterion LookAt(GCore.FVector3)
static bool w_s_i8i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};

    typedef struct s_i8i8i8i8_ (*FuncToCall)(struct s_i8i8i8_ p0, const void* method);
    struct s_i8i8i8i8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FQuaterion op_Multiply(GCore.FQuaterion, GCore.FVector3)
static bool w_s_i8i8i8i8_s_i8i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8_s_i8i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i8i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, info[0]);
    s_i8i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};

    typedef struct s_i8i8i8i8_ (*FuncToCall)(struct s_i8i8i8i8_ p0, struct s_i8i8i8_ p1, const void* method);
    struct s_i8i8i8i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FQuaterion op_Multiply(GCore.FQuaterion, GCore.FQuaterion)
static bool w_s_i8i8i8i8_s_i8i8i8i8_s_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8_s_i8i8i8i8_s_i8i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i8i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, info[0]);
    s_i8i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, info[1]);
    s_i8i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8i8_ {};

    typedef struct s_i8i8i8i8_ (*FuncToCall)(struct s_i8i8i8i8_ p0, struct s_i8i8i8i8_ p1, const void* method);
    struct s_i8i8i8i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FQuaterion C_FVector4()
static bool w_s_i8i8i8i8_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i8i8i8i8_ (*FuncToCall)(void*,const void* method);
    struct s_i8i8i8i8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FQuaterion SetEuler(Int64, Int64, Int64)
static bool w_s_i8i8i8i8_ti8i8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8_ti8i8i8");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);

    typedef struct s_i8i8i8i8_ (*FuncToCall)(void*,int64_t p0, int64_t p1, int64_t p2, const void* method);
    struct s_i8i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FQuaterion Rotate(GCore.FVector3, Int64)
static bool w_s_i8i8i8i8_ts_i8i8i8_i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8_ts_i8i8i8_i8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);

    typedef struct s_i8i8i8i8_ (*FuncToCall)(void*,struct s_i8i8i8_ p0, int64_t p1, const void* method);
    struct s_i8i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FQuaterion C_GetRotation(UInt32)
static bool w_s_i8i8i8i8_tu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8_tu4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);

    typedef struct s_i8i8i8i8_ (*FuncToCall)(void*,uint32_t p0, const void* method);
    struct s_i8i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.PhyHitInfo C_PhyRaycast(Int32, GCore.FVector3, GCore.FVector3, Int64)
static bool w_s_i8i8i8i8i8i8i8_ti4s_i8i8i8_s_i8i8i8_i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8i8i8i8_ti4s_i8i8i8_s_i8i8i8_i8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);

    typedef struct s_i8i8i8i8i8i8i8_ (*FuncToCall)(void*,int32_t p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, int64_t p3, const void* method);
    struct s_i8i8i8i8i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// MainModule get_main()
static bool w_s_o_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_o_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_o_ (*FuncToCall)(void*,const void* method);
    struct s_o_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Enumerator GetEnumerator()
static bool w_s_oi4i4O_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_oi4i4O_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_oi4i4O_ (*FuncToCall)(void*,const void* method);
    struct s_oi4i4O_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Enumerator GetEnumerator()
static bool w_s_oi4i4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_oi4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_oi4i4i4_ (*FuncToCall)(void*,const void* method);
    struct s_oi4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Enumerator GetEnumerator()
static bool w_s_oi4i4i4oi4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_oi4i4i4oi4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_oi4i4i4oi4_ (*FuncToCall)(void*,const void* method);
    struct s_oi4i4i4oi4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Enumerator GetEnumerator()
static bool w_s_oi4i4o_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_oi4i4o_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_oi4i4o_ (*FuncToCall)(void*,const void* method);
    struct s_oi4i4o_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Enumerator GetEnumerator()
static bool w_s_oi4i4s_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_oi4i4s_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_oi4i4s_ (*FuncToCall)(void*,const void* method);
    struct s_oi4i4s_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Enumerator GetEnumerator()
static bool w_s_oi4i4soi4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_oi4i4soi4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_oi4i4soi4_ (*FuncToCall)(void*,const void* method);
    struct s_oi4i4soi4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Trails GetTrails()
static bool w_s_ooooi4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_ooooi4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_ooooi4i4_ (*FuncToCall)(void*,const void* method);
    struct s_ooooi4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Enumerator GetEnumerator()
static bool w_s_osi4i4o_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_osi4i4o_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_osi4i4o_ (*FuncToCall)(void*,const void* method);
    struct s_osi4i4o_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Enumerator GetEnumerator(System.String)
static bool w_s_osi4i4o_ts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_osi4i4o_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_osi4i4o_ (*FuncToCall)(void*,void* p0, const void* method);
    struct s_osi4i4o_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 get_zero()
static bool w_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_r4r4_ (*FuncToCall)(const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 op_Multiply(Single, UnityEngine.Vector2)
static bool w_s_r4r4_r4s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_r4s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(float p0, struct s_r4r4_ p1, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 Perpendicular(UnityEngine.Vector2)
static bool w_s_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 ClampMagnitude(UnityEngine.Vector2, Single)
static bool w_s_r4r4_s_r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, float p1, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 Scale(UnityEngine.Vector2, UnityEngine.Vector2)
static bool w_s_r4r4_s_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single)
static bool w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, struct s_r4r4_* p2, float p3, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single, Single)
static bool w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, struct s_r4r4_* p2, float p3, float p4, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single, Single, Single)
static bool w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, struct s_r4r4_* p2, float p3, float p4, float p5, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 Lerp(UnityEngine.Vector2, UnityEngine.Vector2, Single)
static bool w_s_r4r4_s_r4r4_s_r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_s_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, float p2, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 op_Implicit(UnityEngine.Vector3)
static bool w_s_r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 op_Implicit(UnityEngine.Vector4)
static bool w_s_r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 get_normalized()
static bool w_s_r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 GetTouchPosition(Int32)
static bool w_s_r4r4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 GetPoupPosition(FairyGUI.GObject, FairyGUI.GObject, FairyGUI.PopupDirection)
static bool w_s_r4r4_tooi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_tooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef struct s_r4r4_ (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 GetAttributeVector(System.String)
static bool w_s_r4r4_ts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_r4r4_ (*FuncToCall)(void*,void* p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 GlobalToLocal(UnityEngine.Vector2)
static bool w_s_r4r4_ts_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_ts_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(void*,struct s_r4r4_ p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 GetUVAtPosition(UnityEngine.Vector2, Boolean)
static bool w_s_r4r4_ts_r4r4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_ts_r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef struct s_r4r4_ (*FuncToCall)(void*,struct s_r4r4_ p0, bool p1, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 TransformPoint(UnityEngine.Vector2, FairyGUI.DisplayObject)
static bool w_s_r4r4_ts_r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_ts_r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef struct s_r4r4_ (*FuncToCall)(void*,struct s_r4r4_ p0, void* p1, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 WorldToLocal(UnityEngine.Vector3)
static bool w_s_r4r4_ts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_ts_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 WorldToLocal(UnityEngine.Vector3, UnityEngine.Camera)
static bool w_s_r4r4_ts_r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_ts_r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef struct s_r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, void* p1, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 get_zero()
static bool w_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_r4r4r4_ (*FuncToCall)(const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 op_Multiply(Single, UnityEngine.Vector3)
static bool w_s_r4r4r4_r4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_r4s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(float p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 op_Implicit(UnityEngine.Vector2)
static bool w_s_r4r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4_ p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 Normalize(UnityEngine.Vector3)
static bool w_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 ClampMagnitude(UnityEngine.Vector3, Single)
static bool w_s_r4r4r4_s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, float p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 Scale(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_* p2, float p3, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_* p2, float p3, float p4, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single, Single, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_* p2, float p3, float p4, float p5, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 Slerp(UnityEngine.Vector3, UnityEngine.Vector3, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 RotateTowards(UnityEngine.Vector3, UnityEngine.Vector3, Single, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, float p3, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 op_Implicit(UnityEngine.Vector4)
static bool w_s_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 op_Multiply(UnityEngine.Quaternion, UnityEngine.Vector3)
static bool w_s_r4r4r4_s_r4r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 get_normalized()
static bool w_s_r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 GetPosition(Int32)
static bool w_s_r4r4r4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 GetPointAt(Single)
static bool w_s_r4r4r4_tr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_tr4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,float p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 TransformDirection(Single, Single, Single)
static bool w_s_r4r4r4_tr4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_tr4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,float p0, float p1, float p2, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 TransformDirection(UnityEngine.Vector3)
static bool w_s_r4r4r4_ts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_ts_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 ScreenToWorld(UnityEngine.Vector3, Single)
static bool w_s_r4r4r4_ts_r4r4r4_Dr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_ts_r4r4r4_Dr4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (length > 1 && !converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(context, info, method, 1);
                

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, float p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 WorldToLocal(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_s_r4r4r4_ts_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_ts_r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// PlaybackState GetPlaybackState()
static bool w_s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color get_red()
static bool w_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_r4r4r4r4_ (*FuncToCall)(const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rect Intersection(UnityEngine.Rect ByRef, UnityEngine.Rect ByRef)
static bool w_s_r4r4r4r4_Ps_r4r4r4r4_Ps_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_Ps_r4r4r4r4_Ps_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_r4r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_* p0, struct s_r4r4r4r4_* p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color ColorFromRGB(Int32)
static bool w_s_r4r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(int32_t p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color HSVToRGB(Single, Single, Single)
static bool w_s_r4r4r4r4_r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color HSVToRGB(Single, Single, Single, Boolean)
static bool w_s_r4r4r4r4_r4r4r4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4r4r4b");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, bool p3, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Quaternion AngleAxis(Single, UnityEngine.Vector3)
static bool w_s_r4r4r4r4_r4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color op_Multiply(Single, UnityEngine.Color)
static bool w_s_r4r4r4r4_r4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, struct s_r4r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color ConvertFromHtmlColor(System.String)
static bool w_s_r4r4r4r4_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void* p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 op_Implicit(UnityEngine.Vector2)
static bool w_s_r4r4r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4_ p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 op_Implicit(UnityEngine.Vector3)
static bool w_s_r4r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Quaternion FromToRotation(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_s_r4r4r4r4_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 op_Implicit(UnityEngine.Color)
static bool w_s_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color op_Multiply(UnityEngine.Color, Single)
static bool w_s_r4r4r4r4_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, float p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color op_Addition(UnityEngine.Color, UnityEngine.Color)
static bool w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color Lerp(UnityEngine.Color, UnityEngine.Color, Single)
static bool w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, float p2, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color get_linear()
static bool w_s_r4r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rect GetBounds(FairyGUI.DisplayObject)
static bool w_s_r4r4r4r4_to(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,void* p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rect GetDrawRect(UnityEngine.Rect)
static bool w_s_r4r4r4r4_ts_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_ts_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rect TransformRect(UnityEngine.Rect, FairyGUI.DisplayObject)
static bool w_s_r4r4r4r4_ts_r4r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_ts_r4r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, void* p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color GetColor(System.String, UnityEngine.Color)
static bool w_s_r4r4r4r4_tss_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_tss_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color ColorFromRGBA(UInt32)
static bool w_s_r4r4r4r4_u4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(uint32_t p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 get_worldToLocalMatrix()
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.String UTF8ToString(IntPtr, Int32)
static bool w_spi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_spi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ConvertNumber(System.String)
static bool w_ss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String EncodeString(System.String, Boolean)
static bool w_ssDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ssDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void* (*FuncToCall)(void* p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetItemURL(System.String, System.String)
static bool w_sss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ToString()
static bool w_st(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_st");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetTagText(Boolean)
static bool w_stb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_stb");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,bool p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetPageName(Int32)
static bool w_sti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String Find(System.Predicate`1[System.String])
static bool w_sto(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sto");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ToString(System.String)
static bool w_sts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ReadFile(System.String, System.String ByRef)
static bool w_stsPs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_stsPs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal Ps
    void* up1 = nullptr; // string ref
    void** p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        v8::String::Utf8Value tp1(isolate, op1->Get(context, 0).ToLocalChecked());
        up1 = CStringToCSharpString(*tp1);
    }
        

    typedef void* (*FuncToCall)(void*,void* p0, void** p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, CSAnyToJsValue(isolate, context, *p1));
    }
    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ToString(System.String, System.IFormatProvider)
static bool w_stso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_stso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetString(System.String, System.String)
static bool w_stss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_stss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// Byte ReadByte()
static bool w_u1t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u1t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef uint8_t (*FuncToCall)(void*,const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt16 ReadUshort()
static bool w_u2t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u2t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef uint16_t (*FuncToCall)(void*,const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 getSurfacePos(IntPtr, GCore.FVector3 ByRef, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_u4pPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4pPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef uint32_t (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 entt_create_unit(IntPtr, Int32)
static bool w_u4pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef uint32_t (*FuncToCall)(void* p0, int32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 entt_nav_raycast(IntPtr, Int32, GCore.FVector3 ByRef, GCore.FVector3 ByRef, Int64 ByRef)
static bool w_u4pi4Ps_i8i8i8_Ps_i8i8i8_Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4pi4Ps_i8i8i8_Ps_i8i8i8_Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal P primitive
    int64_t up4 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[4]);
    int64_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }

    typedef uint32_t (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, int64_t* p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
            
    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p4));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 entt_get_surfacepos(IntPtr, Int32, GCore.FVector3 ByRef, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_u4pi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4pi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p4 = nullptr; // valuetype ref
    s_i8i8i8_ up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
        auto tp4 = op4->Get(context, 0).ToLocalChecked();
        p4 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp4);
    }
    if (!p4) {
        p4 = &up4;
    }
        

    typedef uint32_t (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, struct s_i8i8i8_* p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
            
    if (!op4.IsEmpty() && p4 == &up4)
    {
        auto _unused = op4->Set(context, 0, CopyValueType(isolate, context, TIp4, p4, sizeof(*p4)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 get_randomSeed()
static bool w_u4t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef uint32_t (*FuncToCall)(void*,const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 C_CreateUnit(Int32)
static bool w_u4ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4ti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef uint32_t (*FuncToCall)(void*,int32_t p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt64 entt_num(IntPtr)
static bool w_u8p(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u8p");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);

    typedef uint64_t (*FuncToCall)(void* p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(v8::BigInt::NewFromUnsigned(isolate, ret));
    return true;
}

// UInt64 get_sceneCullingMask()
static bool w_u8t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u8t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef uint64_t (*FuncToCall)(void*,const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(v8::BigInt::NewFromUnsigned(isolate, ret));
    return true;
}

// Void Break()
static bool w_v(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_v");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef void (*FuncToCall)(const void* method);
    ((FuncToCall)methodPointer)(  method);

    
    return true;
}

// Void Log(System.Object)
static bool w_vO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void (*FuncToCall)(void* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void Kill(System.Object, Boolean)
static bool w_vOb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vOb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Kill(System.Object, FairyGUI.TweenPropType, Boolean)
static bool w_vOi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vOi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Log(System.Object, UnityEngine.Object)
static bool w_vOo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vOo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void fv_opmulf(GCore.FVector3 ByRef, Int64 ByRef, GCore.FVector3 ByRef)
static bool w_vPs_i8i8i8_Pi8Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8_Pi8Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P primitive
    int64_t up1 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[1]);
    int64_t* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8_* p0, int64_t* p1, struct s_i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p1));
    }
    
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void fv_normalize(GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_vPs_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8_* p0, struct s_i8i8i8_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void fv_rotate(GCore.FVector3 ByRef, GCore.FVector3 ByRef, Int64 ByRef, GCore.FVector3 ByRef)
static bool w_vPs_i8i8i8_Ps_i8i8i8_Pi8Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8_Ps_i8i8i8_Pi8Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[2]);
    int64_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8_* p0, struct s_i8i8i8_* p1, int64_t* p2, struct s_i8i8i8_* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    return true;
}

// Void fv_opadd(GCore.FVector3 ByRef, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_vPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8_* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void fq_seteuler(GCore.FQuaterion ByRef, Int64 ByRef, Int64 ByRef, Int64 ByRef, GCore.FQuaterion ByRef)
static bool w_vPs_i8i8i8i8_Pi8Pi8Pi8Ps_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8i8_Pi8Pi8Pi8Ps_i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P primitive
    int64_t up1 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[1]);
    int64_t* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[2]);
    int64_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p4 = nullptr; // valuetype ref
    s_i8i8i8i8_ up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
        auto tp4 = op4->Get(context, 0).ToLocalChecked();
        p4 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp4);
    }
    if (!p4) {
        p4 = &up4;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8i8_* p0, int64_t* p1, int64_t* p2, int64_t* p3, struct s_i8i8i8i8_* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p1));
    }
    
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    if (!op4.IsEmpty() && p4 == &up4)
    {
        auto _unused = op4->Set(context, 0, CopyValueType(isolate, context, TIp4, p4, sizeof(*p4)));
    }
    
    return true;
}

// Void fq_geteuler(GCore.FQuaterion ByRef, GCore.FVector3 ByRef)
static bool w_vPs_i8i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8i8_* p0, struct s_i8i8i8_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void fq_rotate(GCore.FQuaterion ByRef, GCore.FVector3 ByRef, Int64 ByRef, GCore.FQuaterion ByRef)
static bool w_vPs_i8i8i8i8_Ps_i8i8i8_Pi8Ps_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8i8_Ps_i8i8i8_Pi8Ps_i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[2]);
    int64_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8i8_* p0, struct s_i8i8i8_* p1, int64_t* p2, struct s_i8i8i8i8_* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    return true;
}

// Void fq_quatrot(GCore.FQuaterion ByRef, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_vPs_i8i8i8i8_Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8i8_Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8i8_* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void fq_mulv(GCore.FQuaterion ByRef, GCore.FVector3 ByRef, GCore.FQuaterion ByRef)
static bool w_vPs_i8i8i8i8_Ps_i8i8i8_Ps_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8i8_Ps_i8i8i8_Ps_i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8i8_* p0, struct s_i8i8i8_* p1, struct s_i8i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void fq_inverse(GCore.FQuaterion ByRef, GCore.FQuaterion ByRef)
static bool w_vPs_i8i8i8i8_Ps_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8i8_Ps_i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8i8_* p0, struct s_i8i8i8i8_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void fq_mul(GCore.FQuaterion ByRef, GCore.FQuaterion ByRef, GCore.FQuaterion ByRef)
static bool w_vPs_i8i8i8i8_Ps_i8i8i8i8_Ps_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8i8_Ps_i8i8i8i8_Ps_i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8i8_* p0, struct s_i8i8i8i8_* p1, struct s_i8i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void OrthoNormalize(UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef)
static bool w_vPs_r4r4r4_Ps_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_r4r4r4_Ps_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct s_r4r4r4_* p0, struct s_r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void OrthoNormalize(UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef)
static bool w_vPs_r4r4r4_Ps_r4r4r4_Ps_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_r4r4r4_Ps_r4r4r4_Ps_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct s_r4r4r4_* p0, struct s_r4r4r4_* p1, struct s_r4r4r4_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void SkewMatrix(UnityEngine.Matrix4x4 ByRef, Single, Single)
static bool w_vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void Debug(System.Object[])
static bool w_vVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vVO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
    }
    
    // JSValToCSVal ref params
    void* p0 = RestArguments<void*>::PackRef(context, info, TIp0, 0);
                

    typedef void (*FuncToCall)(void* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void set_developerConsoleVisible(Boolean)
static bool w_vb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(bool p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void Assert(Boolean, System.Object)
static bool w_vbO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbO");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(bool p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Assert(Boolean, System.Object, UnityEngine.Object)
static bool w_vbOo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbOo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(bool p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Assert(Boolean, UnityEngine.Object)
static bool w_vbo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbo");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(bool p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void AssertFormat(Boolean, UnityEngine.Object, System.String, System.Object[])
static bool w_vbosVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbosVO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal ref params
    void* p3 = RestArguments<void*>::PackRef(context, info, TIp3, 3);
                

    typedef void (*FuncToCall)(bool p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void Assert(Boolean, System.String)
static bool w_vbs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbs");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(bool p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void AssertFormat(Boolean, System.String, System.Object[])
static bool w_vbsVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbsVO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal ref params
    void* p2 = RestArguments<void*>::PackRef(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(bool p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Assert(Boolean, System.String, UnityEngine.Object)
static bool w_vbso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbso");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(bool p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void set_captureFramerate(Int32)
static bool w_vi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(int32_t p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void SetMaximumPreMappedBufferCounts(Int32, Int32)
static bool w_vi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Override(FairyGUI.BlendMode, UnityEngine.Rendering.BlendMode, UnityEngine.Rendering.BlendMode)
static bool w_vi4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void LogFormat(UnityEngine.LogType, UnityEngine.LogOption, UnityEngine.Object, System.String, System.Object[])
static bool w_vi4i4osVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4osVO");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsString() && !info[3]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal s
    v8::String::Utf8Value tp3(isolate, info[3]);
    void* p3 = CStringToCSharpString(*tp3);
    // JSValToCSVal ref params
    void* p4 = RestArguments<void*>::PackRef(context, info, TIp4, 4);
                

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, void* p2, void* p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetDefaultValue(ConfigKey, ConfigValue)
static bool w_vi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void LogException(System.Exception)
static bool w_vo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vo");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void (*FuncToCall)(void* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void RegisterFont(FairyGUI.BaseFont, System.String)
static bool w_voDs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voDs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal string  with default
    void* p1 = OptionalParameter<void*>::GetString(context, info, method, 1);
                

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void RotateUV(UnityEngine.Vector2[], UnityEngine.Rect ByRef)
static bool w_voPs_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voPs_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Pstruct
    s_r4r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void CacheRaycastHit(UnityEngine.Camera, UnityEngine.RaycastHit ByRef)
static bool w_voPs_r4r4r4r4r4r4u4r4r4r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voPs_r4r4r4r4r4r4u4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void DestroyImmediate(UnityEngine.Object, Boolean)
static bool w_vob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vob");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Apply(UnityEngine.Material, FairyGUI.BlendMode)
static bool w_voi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void EncodeString(System.Text.StringBuilder, Int32, Boolean)
static bool w_voi4Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4Db");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void* p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void LogException(System.Exception, UnityEngine.Object)
static bool w_voo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Capture(FairyGUI.DisplayObject, UnityEngine.RenderTexture, Single, UnityEngine.Vector2)
static bool w_voor4s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voor4s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4_>(context, info[3]);
    s_r4r4_ p3 = pp3 ? *pp3 : s_r4r4_ {};

    typedef void (*FuncToCall)(void* p0, void* p1, float p2, struct s_r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void Destroy(UnityEngine.Object, Single)
static bool w_vor4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vor4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, float p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void LogFormat(UnityEngine.Object, System.String, System.Object[])
static bool w_vosVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vosVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal ref params
    void* p2 = RestArguments<void*>::PackRef(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SQLRollback(IntPtr)
static bool w_vp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vp");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);

    typedef void (*FuncToCall)(void* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void entt_set_phystep(IntPtr, GCore.F64 ByRef)
static bool w_vpPs_i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpPs_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8_* p1 = nullptr; // valuetype ref
    s_i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void* p0, struct s_i8_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void getBounds(IntPtr, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_vpPs_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpPs_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void getNearestPos(IntPtr, GCore.FVector3 ByRef, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_vpPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef void (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    return true;
}

// Void entt_collect_sortdist(IntPtr, GCore.FVector3 ByRef, Int32[], Int32[], Int32, IntPtr, GCore.GameSystemCallback, IntPtr)
static bool w_vpPs_i8i8i8_ooi4pop(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpPs_i8i8i8_ooi4pop");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsArrayBuffer()) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!info[7]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    void* p5 = DataTransfer::GetPointer<void>(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal P any
    void* p7 = DataTransfer::GetPointer<void>(context, info[7]);

    typedef void (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, void* p2, void* p3, int32_t p4, void* p5, void* p6, void* p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void initRandom(IntPtr, Int32)
static bool w_vpi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void grid_idx2cr(IntPtr, Int32, Int32 ByRef, Int32 ByRef, Int32, Int32)
static bool w_vpi4Pi4Pi4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4Pi4Pi4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (length > 5 && !converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(context, info[2]);
    int32_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(context, info[3]);
    int32_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 5);
                

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t* p2, int32_t* p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int32_t>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int32_t>::toScript(context, *p3));
    }
    
    return true;
}

// Void MapIdx2Pos(IntPtr, Int32, GCore.FVector3 ByRef)
static bool w_vpi4Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void grid_idx2pos(IntPtr, Int32, GCore.FVector3 ByRef, Int32, Int32)
static bool w_vpi4Ps_i8i8i8_Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4Ps_i8i8i8_Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef void (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void entt_get_bounds(IntPtr, Int32, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_vpi4Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef void (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    return true;
}

// Void entt_get_nearest_pos(IntPtr, Int32, GCore.FVector3 ByRef, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_vpi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p4 = nullptr; // valuetype ref
    s_i8i8i8_ up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
        auto tp4 = op4->Get(context, 0).ToLocalChecked();
        p4 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp4);
    }
    if (!p4) {
        p4 = &up4;
    }
        

    typedef void (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, struct s_i8i8i8_* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
            
    if (!op4.IsEmpty() && p4 == &up4)
    {
        auto _unused = op4->Set(context, 0, CopyValueType(isolate, context, TIp4, p4, sizeof(*p4)));
    }
    
    return true;
}

// Void entt_phy_raycast(IntPtr, Int32, GCore.FVector3 ByRef, GCore.FVector3 ByRef, GCore.PhyHitInfo ByRef, Int64 ByRef)
static bool w_vpi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8i8i8i8i8_Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8i8i8i8i8_Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
        if (!info[5]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8i8i8i8i8_* p4 = nullptr; // valuetype ref
    s_i8i8i8i8i8i8i8_ up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
        auto tp4 = op4->Get(context, 0).ToLocalChecked();
        p4 = DataTransfer::GetPointer<s_i8i8i8i8i8i8i8_>(context, tp4);
    }
    if (!p4) {
        p4 = &up4;
    }
        
    // JSValToCSVal P primitive
    int64_t up5 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[5]);
    int64_t* p5 = &up5;
    v8::Local<v8::Object> op5;
    if (!info[5].IsEmpty() && info[5]->IsObject()) {
        op5 = info[5]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, struct s_i8i8i8i8i8i8i8_* p4, int64_t* p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
            
    if (!op4.IsEmpty() && p4 == &up4)
    {
        auto _unused = op4->Set(context, 0, CopyValueType(isolate, context, TIp4, p4, sizeof(*p4)));
    }
            
    if (!op5.IsEmpty())
    {
        auto _unused = op5->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p5));
    }
    
    return true;
}

// Void grid_setmovemask(IntPtr, Int32, Int32)
static bool w_vpi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void grid_cr2pos(IntPtr, Int32, Int32, GCore.FVector3 ByRef)
static bool w_vpi4i4Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4i4Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, struct s_i8i8i8_* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    return true;
}

// Void entt_ignore_collideevt(IntPtr, Int32, Int32, Int32)
static bool w_vpi4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetMapCityColor(IntPtr, Int32, Int32, Int32, Int32)
static bool w_vpi4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void grid_findpath(IntPtr, Int32, Int32, Int32, Int32, Int32, Int32[])
static bool w_vpi4i4i4i4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4i4i4i4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp6 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, void* p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void grid_getoccupys(IntPtr, Int32, Int32, Int32, Int32[])
static bool w_vpi4i4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4i4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void MapFaceNeis(IntPtr, Int32, Int32[])
static bool w_vpi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void entt_phy_debug(IntPtr, Int32, IntPtr, GCore.OnDebugLineCallback)
static bool w_vpi4po(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsArrayBuffer()) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void OnUpdate(IntPtr, Int32, IntPtr, IntPtr, Int64)
static bool w_vpi4ppi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4ppi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsArrayBuffer()) return false;
        if (!info[3]->IsArrayBuffer()) return false;
        if (!converter::Converter<int64_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(context, info[2]);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(context, info[3]);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, int64_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void RemoveRVOAgent(IntPtr, Int64)
static bool w_vpi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, int64_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetRVOAgentMaxSpd(IntPtr, Int64, GCore.F64 ByRef)
static bool w_vpi8Ps_i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi8Ps_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8_* p2 = nullptr; // valuetype ref
    s_i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(void* p0, int64_t p1, struct s_i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void SetRVOAgentPosition(IntPtr, Int64, GCore.FVector3 ByRef)
static bool w_vpi8Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi8Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(void* p0, int64_t p1, struct s_i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void SQLQuery(IntPtr, Byte[], Int32)
static bool w_vpoi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpoi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void grid_getpolyoccupys(IntPtr, GCore.FVector3[], Int32, Int32[])
static bool w_vpoi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpoi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void* p0, void* p1, int32_t p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void entt_add_system(IntPtr, Int32[], Int32[], IntPtr, GCore.GameSystemCallback, IntPtr)
static bool w_vpoopop(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpoopop");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsArrayBuffer()) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!info[5]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    void* p5 = DataTransfer::GetPointer<void>(context, info[5]);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void SQLUpdateHook(IntPtr, GCore.SqliteUpdateHook, IntPtr)
static bool w_vpop(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpop");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void RemoveRVOObstacle(IntPtr, IntPtr)
static bool w_vpp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void entt_get_poses(IntPtr, IntPtr, IntPtr)
static bool w_vppp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vppp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void PGQuery(IntPtr, System.String)
static bool w_vps(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vps");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void entt_phy_debugunit(IntPtr, UInt32)
static bool w_vpu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void entt_add_capsulephy(IntPtr, UInt32, Int64 ByRef, Int64 ByRef, Int32, Int32, Int64 ByRef, Int32, Int64 ByRef, Int32)
static bool w_vpu4Pi8Pi8i4i4Pi8i4Pi8i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Pi8Pi8i4i4Pi8i4Pi8i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 10) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!info[8]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[9])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[2]);
    int64_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P primitive
    int64_t up6 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[6]);
    int64_t* p6 = &up6;
    v8::Local<v8::Object> op6;
    if (!info[6].IsEmpty() && info[6]->IsObject()) {
        op6 = info[6]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P primitive
    int64_t up8 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[8]);
    int64_t* p8 = &up8;
    v8::Local<v8::Object> op8;
    if (!info[8].IsEmpty() && info[8]->IsObject()) {
        op8 = info[8]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(context, info[9]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int64_t* p2, int64_t* p3, int32_t p4, int32_t p5, int64_t* p6, int32_t p7, int64_t* p8, int32_t p9, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    if (!op6.IsEmpty())
    {
        auto _unused = op6->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p6));
    }
    
    if (!op8.IsEmpty())
    {
        auto _unused = op8->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p8));
    }
    
    return true;
}

// Void entt_add_spherephy(IntPtr, UInt32, Int64 ByRef, Int32, Int32, Int64 ByRef, Int32, Int64 ByRef, Int32)
static bool w_vpu4Pi8i4i4Pi8i4Pi8i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Pi8i4i4Pi8i4Pi8i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[2]);
    int64_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P primitive
    int64_t up5 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[5]);
    int64_t* p5 = &up5;
    v8::Local<v8::Object> op5;
    if (!info[5].IsEmpty() && info[5]->IsObject()) {
        op5 = info[5]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P primitive
    int64_t up7 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[7]);
    int64_t* p7 = &up7;
    v8::Local<v8::Object> op7;
    if (!info[7].IsEmpty() && info[7]->IsObject()) {
        op7 = info[7]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int64_t* p2, int32_t p3, int32_t p4, int64_t* p5, int32_t p6, int64_t* p7, int32_t p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p2));
    }
    
    if (!op5.IsEmpty())
    {
        auto _unused = op5->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p5));
    }
    
    if (!op7.IsEmpty())
    {
        auto _unused = op7->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p7));
    }
    
    return true;
}

// Void entt_local2world(IntPtr, UInt32, GCore.FVector3 ByRef)
static bool w_vpu4Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(void* p0, uint32_t p1, struct s_i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void entt_add_obstacle(IntPtr, UInt32, GCore.FVector3 ByRef, Int64 ByRef, Int64 ByRef)
static bool w_vpu4Ps_i8i8i8_Pi8Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Ps_i8i8i8_Pi8Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up4 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[4]);
    int64_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(void* p0, uint32_t p1, struct s_i8i8i8_* p2, int64_t* p3, int64_t* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p4));
    }
    
    return true;
}

// Void entt_add_pointforce(IntPtr, UInt32, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_vpu4Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef void (*FuncToCall)(void* p0, uint32_t p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    return true;
}

// Void entt_set_rvoagvel(IntPtr, UInt32, GCore.FVector3 ByRef, Int32)
static bool w_vpu4Ps_i8i8i8_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Ps_i8i8i8_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, struct s_i8i8i8_* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void entt_movewithrad(IntPtr, UInt32, GCore.FVector3 ByRef, Int32, Int64 ByRef, Int64 ByRef, Int64 ByRef)
static bool w_vpu4Ps_i8i8i8_i4Pi8Pi8Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Ps_i8i8i8_i4Pi8Pi8Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsObject()) return false;
        if (!info[5]->IsObject()) return false;
        if (!info[6]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P primitive
    int64_t up4 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[4]);
    int64_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up5 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[5]);
    int64_t* p5 = &up5;
    v8::Local<v8::Object> op5;
    if (!info[5].IsEmpty() && info[5]->IsObject()) {
        op5 = info[5]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up6 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[6]);
    int64_t* p6 = &up6;
    v8::Local<v8::Object> op6;
    if (!info[6].IsEmpty() && info[6]->IsObject()) {
        op6 = info[6]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(void* p0, uint32_t p1, struct s_i8i8i8_* p2, int32_t p3, int64_t* p4, int64_t* p5, int64_t* p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p4));
    }
    
    if (!op5.IsEmpty())
    {
        auto _unused = op5->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p5));
    }
    
    if (!op6.IsEmpty())
    {
        auto _unused = op6->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p6));
    }
    
    return true;
}

// Void entt_moveto(IntPtr, UInt32, GCore.FVector3 ByRef, Int32, Int64 ByRef, Int32)
static bool w_vpu4Ps_i8i8i8_i4Pi8i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Ps_i8i8i8_i4Pi8i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P primitive
    int64_t up4 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[4]);
    int64_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, struct s_i8i8i8_* p2, int32_t p3, int64_t* p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p4));
    }
    
    return true;
}

// Void entt_add_boxphy(IntPtr, UInt32, GCore.FVector3 ByRef, Int32, Int32, Int64 ByRef, Int32, Int64 ByRef, Int32)
static bool w_vpu4Ps_i8i8i8_i4i4Pi8i4Pi8i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Ps_i8i8i8_i4i4Pi8i4Pi8i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P primitive
    int64_t up5 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[5]);
    int64_t* p5 = &up5;
    v8::Local<v8::Object> op5;
    if (!info[5].IsEmpty() && info[5]->IsObject()) {
        op5 = info[5]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P primitive
    int64_t up7 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[7]);
    int64_t* p7 = &up7;
    v8::Local<v8::Object> op7;
    if (!info[7].IsEmpty() && info[7]->IsObject()) {
        op7 = info[7]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, struct s_i8i8i8_* p2, int32_t p3, int32_t p4, int64_t* p5, int32_t p6, int64_t* p7, int32_t p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op5.IsEmpty())
    {
        auto _unused = op5->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p5));
    }
    
    if (!op7.IsEmpty())
    {
        auto _unused = op7->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p7));
    }
    
    return true;
}

// Void entt_set_rotation(IntPtr, UInt32, GCore.FQuaterion ByRef)
static bool w_vpu4Ps_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Ps_i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(void* p0, uint32_t p1, struct s_i8i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void entt_phy_active(IntPtr, UInt32, Int32)
static bool w_vpu4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void entt_set_colideroffset(IntPtr, UInt32, Int32, Int64 ByRef)
static bool w_vpu4i4Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i4Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int32_t p2, int64_t* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    return true;
}

// Void entt_add_rvoobst(IntPtr, UInt32, Int32, Int64 ByRef, Int64 ByRef)
static bool w_vpu4i4Pi8Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i4Pi8Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up4 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[4]);
    int64_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int32_t p2, int64_t* p3, int64_t* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p4));
    }
    
    return true;
}

// Void entt_add_crowd(IntPtr, UInt32, Int32, Int64 ByRef, Int64 ByRef, Int64 ByRef, Int64 ByRef, Int32)
static bool w_vpu4i4Pi8Pi8Pi8Pi8i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i4Pi8Pi8Pi8Pi8i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
        if (!info[5]->IsObject()) return false;
        if (!info[6]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up4 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[4]);
    int64_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up5 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[5]);
    int64_t* p5 = &up5;
    v8::Local<v8::Object> op5;
    if (!info[5].IsEmpty() && info[5]->IsObject()) {
        op5 = info[5]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up6 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[6]);
    int64_t* p6 = &up6;
    v8::Local<v8::Object> op6;
    if (!info[6].IsEmpty() && info[6]->IsObject()) {
        op6 = info[6]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int32_t p2, int64_t* p3, int64_t* p4, int64_t* p5, int64_t* p6, int32_t p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p4));
    }
    
    if (!op5.IsEmpty())
    {
        auto _unused = op5->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p5));
    }
    
    if (!op6.IsEmpty())
    {
        auto _unused = op6->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p6));
    }
    
    return true;
}

// Void entt_add_rvoag(IntPtr, UInt32, Int32, Int64 ByRef, Int64 ByRef, Int32, Int64 ByRef)
static bool w_vpu4i4Pi8Pi8i4Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i4Pi8Pi8i4Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up4 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[4]);
    int64_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P primitive
    int64_t up6 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[6]);
    int64_t* p6 = &up6;
    v8::Local<v8::Object> op6;
    if (!info[6].IsEmpty() && info[6]->IsObject()) {
        op6 = info[6]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int32_t p2, int64_t* p3, int64_t* p4, int32_t p5, int64_t* p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p4));
    }
    
    if (!op6.IsEmpty())
    {
        auto _unused = op6->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p6));
    }
    
    return true;
}

// Void entt_setblacklst(IntPtr, UInt32, Int32, Int32)
static bool w_vpu4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void entt_freeze_bodypos(IntPtr, UInt32, Int32, Int32, Int32)
static bool w_vpu4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void entt_set_worldstate(IntPtr, UInt32, Int64)
static bool w_vpu4i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void entt_setgoal(IntPtr, UInt32, Int64, Int32, Int32)
static bool w_vpu4i8i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i8i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int64_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void entt_ignore_collision(IntPtr, UInt32, UInt32, Int32)
static bool w_vpu4u4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4u4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, uint32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void entt_addaction(IntPtr, UInt32, UInt32, Int64, Int64, Int32, Int32)
static bool w_vpu4u4i8i8i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4u4i8i8i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, uint32_t p2, int64_t p3, int64_t p4, int32_t p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void set_fixedDeltaTime(Single)
static bool w_vr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(float p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void OpenURL(System.String)
static bool w_vs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void (*FuncToCall)(void* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void Begin(System.String, Boolean)
static bool w_vsDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void LogFormat(System.String, System.Object[])
static bool w_vsVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal ref params
    void* p1 = RestArguments<void*>::PackRef(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SampleLightInfo(UnityEngine.LayerMask)
static bool w_vs_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4_* pp0 = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p0 = pp0 ? *pp0 : s_i4_ {};

    typedef void (*FuncToCall)(struct s_i4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_vs_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Color)
static bool w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Color, Single)
static bool w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, float p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Color, Single, Boolean)
static bool w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, float p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void RGBToHSV(UnityEngine.Color, Single ByRef, Single ByRef, Single ByRef)
static bool w_vs_r4r4r4r4_Pr4Pr4Pr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4_Pr4Pr4Pr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[1]);
    float* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[2]);
    float* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    float up3 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[3]);
    float* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(struct s_r4r4r4r4_ p0, float* p1, float* p2, float* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<float>::toScript(context, *p1));
    }
    
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<float>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<float>::toScript(context, *p3));
    }
    
    return true;
}

// Void SetPackageItemExtension(System.String, System.Type)
static bool w_vso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetVar(System.String, System.String)
static bool w_vss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void CreateObjectAsync(System.String, System.String, CreateObjectCallback)
static bool w_vsso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Normalize()
static bool w_vt(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vt");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef void (*FuncToCall)(void*,const void* method);
    ((FuncToCall)methodPointer)(self,  method);

    
    return true;
}

// Void Kill(Boolean)
static bool w_vtDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<bool>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(context, info, method, 0);
                

    typedef void (*FuncToCall)(void*,bool p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void AddTriangles(Int32)
static bool w_vtDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 0);
                

    typedef void (*FuncToCall)(void*,int32_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void RemoveChildren(Int32, Int32)
static bool w_vtDi4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDi4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32)
static bool w_vtDi4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDi4Di4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int32)
static bool w_vtDi4Di4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDi4Di4Di4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void clearMem(Int32, System.Collections.Generic.List`1[System.Int32])
static bool w_vtDi4Do(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDi4Do");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal ref  with default
    void* p1 = OptionalParameter<void*>::GetRefType(context, info, method, 1, TIp1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Int64, Int64, Int64)
static bool w_vtDi8Di8Di8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDi8Di8Di8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int64_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    int64_t p0 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int64_t p1 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int64_t p2 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,int64_t p0, int64_t p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int64, Int64, Int64, Int64)
static bool w_vtDi8Di8Di8Di8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDi8Di8Di8Di8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    int64_t p0 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int64_t p1 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int64_t p2 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int64_t p3 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,int64_t p0, int64_t p1, int64_t p2, int64_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Single, Single, Single)
static bool w_vtDr4Dr4Dr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDr4Dr4Dr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<float>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<float>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    float p0 = OptionalParameter<float>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Single, Single, Single, Single)
static bool w_vtDr4Dr4Dr4Dr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDr4Dr4Dr4Dr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<float>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<float>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<float>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    float p0 = OptionalParameter<float>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void OnDeserialization(System.Object)
static bool w_vtO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void GetSnappingPosition(Single ByRef, Single ByRef)
static bool w_vtPr4Pr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPr4Pr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P primitive
    float up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[0]);
    float* p0 = &up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[1]);
    float* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(void*,float* p0, float* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty())
    {
        auto _unused = op0->Set(context, 0, converter::Converter<float>::toScript(context, *p0));
    }
    
    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<float>::toScript(context, *p1));
    }
    
    return true;
}

// Void GetSnappingPositionWithDir(Single ByRef, Single ByRef, Single, Single)
static bool w_vtPr4Pr4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPr4Pr4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P primitive
    float up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[0]);
    float* p0 = &up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[1]);
    float* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,float* p0, float* p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    if (!op0.IsEmpty())
    {
        auto _unused = op0->Set(context, 0, converter::Converter<float>::toScript(context, *p0));
    }
    
    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<float>::toScript(context, *p1));
    }
    
    return true;
}

// Void ToAngleAxis(Single ByRef, UnityEngine.Vector3 ByRef)
static bool w_vtPr4Ps_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPr4Ps_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P primitive
    float up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[0]);
    float* p0 = &up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal Pstruct
    s_r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,float* p0, struct s_r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty())
    {
        auto _unused = op0->Set(context, 0, converter::Converter<float>::toScript(context, *p0));
    }
    
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void GetPositionAndRotation(UnityEngine.Vector3 ByRef, UnityEngine.Quaternion ByRef)
static bool w_vtPs_r4r4r4_Ps_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_r4r4r4_Ps_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_* p0, struct s_r4r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void SetCustomInput(UnityEngine.RaycastHit ByRef, Boolean)
static bool w_vtPs_r4r4r4r4r4r4u4r4r4r4i4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_r4r4r4r4r4r4u4r4r4r4i4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p0 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4u4r4r4r4i4_* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void SetCustomInput(UnityEngine.RaycastHit ByRef, Boolean, Boolean)
static bool w_vtPs_r4r4r4r4r4r4u4r4r4r4i4_bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_r4r4r4r4r4r4u4r4r4r4i4_bb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p0 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4u4r4r4r4i4_* p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void initialize(System.Object[])
static bool w_vtVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtVO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal ref params
    void* p0 = RestArguments<void*>::PackRef(context, info, TIp0, 0);
                

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void ConcatValues(Single[])
static bool w_vtVr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtVr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
        if (!info[0]->IsNullOrUndefined() && !converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive params
    void* p0 = RestArguments<float>::PackPrimitive(context, info, TIp0, 0);
                

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_hasChanged(Boolean)
static bool w_vtb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,bool p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void FireClick(Boolean, Boolean)
static bool w_vtbDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbDb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,bool p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Set2DGBLight(Boolean, System.String)
static bool w_vtbDs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbDs");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (length > 1 && !info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal string  with default
    void* p1 = OptionalParameter<void*>::GetString(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,bool p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Stop(Boolean, Boolean)
static bool w_vtbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Stop(Boolean, UnityEngine.ParticleSystemStopBehavior)
static bool w_vtbi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,bool p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetAutoPlay(Boolean, Int32, Single)
static bool w_vtbi4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbi4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,bool p0, int32_t p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void CheckError(Boolean, System.String)
static bool w_vtbs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbs");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void*,bool p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddChar(Char, BMGlyph)
static bool w_vtco(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtco");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,Il2CppChar p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetSiblingIndex(Int32)
static bool w_vti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,int32_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void PlayOrReSpeed(Client.ActionRefTriggerType, Int32, Single)
static bool w_vti4Di4Dr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Di4Dr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void clearUnused(Int32, System.Collections.Generic.List`1[System.Int32])
static bool w_vti4Do(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Do");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal ref  with default
    void* p1 = OptionalParameter<void*>::GetRefType(context, info, method, 1, TIp1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void play(Int32, Single)
static bool w_vti4Dr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Dr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Set(Int32, System.Object)
static bool w_vti4O(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4O");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Idx2CR(Int32, Int32 ByRef, Int32 ByRef, Int32, Int32)
static bool w_vti4Pi4Pi4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Pi4Pi4Di4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(context, info[1]);
    int32_t* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(context, info[2]);
    int32_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t* p1, int32_t* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<int32_t>::toScript(context, *p1));
    }
    
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int32_t>::toScript(context, *p2));
    }
    
    return true;
}

// Void TriggerSubEmitter(Int32, Particle ByRef)
static bool w_vti4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void ShowHtmlObject(Int32, Boolean)
static bool w_vti4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,int32_t p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void StopSlots(Client.ActionRefTriggerType, Boolean, Int32)
static bool w_vti4bDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4bDi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, bool p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ScrollToView(Int32, Boolean, Boolean)
static bool w_vti4bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4bb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void RemoveRange(Int32, Int32)
static bool w_vti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.BlendMode, UnityEngine.Rendering.BlendMode, Boolean)
static bool w_vti4i4Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4Db");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetSkin(Int32, Int32, System.String)
static bool w_vti4i4Ds(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4Ds");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal string  with default
    void* p2 = OptionalParameter<void*>::GetString(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void RemoveChildren(Int32, Int32, Boolean)
static bool w_vti4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void AddTriangle(Int32, Int32, Int32)
static bool w_vti4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetPlaySettings(Int32, Int32, Int32, Int32)
static bool w_vti4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int64)
static bool w_vti4i4i4i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int64_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Sort(Int32, Int32, System.Collections.Generic.IComparer`1[UnityEngine.GameObject])
static bool w_vti4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4o");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetLimited(Int32, Int32, GCore.FVector3)
static bool w_vti4i4s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4s_i8i8i8_");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, struct s_i8i8i8_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void set_Item(Int32, UnityEngine.GameObject)
static bool w_vti4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void UpdateInstanceTransform(Int32, Client.InstTrans, Boolean, Boolean)
static bool w_vti4obb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4obb");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void CopyTo(Int32, UnityEngine.GameObject[], Int32, Int32)
static bool w_vti4oi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4oi4i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void set_Item(Int32, Single)
static bool w_vti4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetArea(Int32, Single, Int32, Single)
static bool w_vti4r4i4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4i4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, int32_t p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void GetLinesShape(Int32, Single, Int32, Single, Boolean, System.Collections.Generic.List`1[UnityEngine.Rect])
static bool w_vti4r4i4r4bo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4i4r4bo");
    
    auto TIp5 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, int32_t p2, float p3, bool p4, void* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void Play(Int32, Single, FairyGUI.PlayCompleteCallback)
static bool w_vti4r4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4o");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void GetPointsInSegment(Int32, Single, Single, System.Collections.Generic.List`1[UnityEngine.Vector3], System.Collections.Generic.List`1[System.Single], Single)
static bool w_vti4r4r4oDoDr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4r4oDoDr4");
    
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (length > 4 && !info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (length > 5 && !converter::Converter<float>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal ref  with default
    void* p4 = OptionalParameter<void*>::GetRefType(context, info, method, 4, TIp4);
                
    // JSValToCSVal primitive with default
    float p5 = OptionalParameter<float>::GetPrimitive(context, info, method, 5);
                

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, float p2, void* p3, void* p4, float p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void Play(Int32, Single, Single, Single, FairyGUI.PlayCompleteCallback)
static bool w_vti4r4r4r4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4r4r4o");
    
    auto TIp4 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, float p2, float p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void updateParas(Int32, Single, Single, System.String, System.String, System.String, System.String)
static bool w_vti4r4r4ssss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4r4ssss");
    
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!info[3]->IsString() && !info[3]->IsNullOrUndefined()) return false;
        if (!info[4]->IsString() && !info[4]->IsNullOrUndefined()) return false;
        if (!info[5]->IsString() && !info[5]->IsNullOrUndefined()) return false;
        if (!info[6]->IsString() && !info[6]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal s
    v8::String::Utf8Value tp3(isolate, info[3]);
    void* p3 = CStringToCSharpString(*tp3);
    // JSValToCSVal s
    v8::String::Utf8Value tp4(isolate, info[4]);
    void* p4 = CStringToCSharpString(*tp4);
    // JSValToCSVal s
    v8::String::Utf8Value tp5(isolate, info[5]);
    void* p5 = CStringToCSharpString(*tp5);
    // JSValToCSVal s
    v8::String::Utf8Value tp6(isolate, info[6]);
    void* p6 = CStringToCSharpString(*tp6);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, float p2, void* p3, void* p4, void* p5, void* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void DrawRegularPolygon(Int32, Single, UnityEngine.Color, UnityEngine.Color, UnityEngine.Color, Single, Single[])
static bool w_vti4r4s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4o");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if ((!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp4 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[4]);
    s_r4r4r4r4_ p4 = pp4 ? *pp4 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, struct s_r4r4r4r4_ p2, struct s_r4r4r4r4_ p3, struct s_r4r4r4r4_ p4, float p5, void* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void set_Item(Int32, System.String)
static bool w_vti4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void EnterPaintingMode(Int32, System.Nullable`1[FairyGUI.Margin])
static bool w_vti4s_bi4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_bi4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_bi4i4i4i4_* pp1 = DataTransfer::GetPointer<s_bi4i4i4i4_>(context, info[1]);
    s_bi4i4i4i4_ p1 = pp1 ? *pp1 : s_bi4i4i4i4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_bi4i4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void EnterPaintingMode(Int32, System.Nullable`1[FairyGUI.Margin], Single)
static bool w_vti4s_bi4i4i4i4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_bi4i4i4i4_r4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_bi4i4i4i4_* pp1 = DataTransfer::GetPointer<s_bi4i4i4i4_>(context, info[1]);
    s_bi4i4i4i4_ p1 = pp1 ? *pp1 : s_bi4i4i4i4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_bi4i4i4i4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void addPool(Int32, System.String, UnityEngine.GameObject, System.Type)
static bool w_vti4soo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4soo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void checkRecords(Int64)
static bool w_vti8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,int64_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Init(Int64, Int64, Int32, Int32, Int32)
static bool w_vti8i8Di4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti8i8Di4Di4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef void (*FuncToCall)(void*,int64_t p0, int64_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetAgentVelocity(Int64, Int64, Int64)
static bool w_vti8i8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti8i8i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int64_t p0, int64_t p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void CollectSortDist(Int64, Int64, Int64, Int32)
static bool w_vti8i8i8i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti8i8i8i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int64_t p0, int64_t p1, int64_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void deleteRecords(Int64, System.String)
static bool w_vti8s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti8s");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void*,int64_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_parent(UnityEngine.Transform)
static bool w_vto(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vto");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetFocus(FairyGUI.DisplayObject, Boolean)
static bool w_vtoDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddTriangles(Int32[], Int32)
static bool w_vtoDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Byte[], Int32, Int32)
static bool w_vtoDi4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoDi4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void GetAllPoints(System.Collections.Generic.List`1[UnityEngine.Vector3], Single)
static bool w_vtoDr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoDr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void CallLater(FairyGUI.TimerCallback, System.Object)
static bool w_vtoO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetItemAsset(FairyGUI.PackageItem, System.Object, FairyGUI.DestroyMethod)
static bool w_vtoOi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoOi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetParent(UnityEngine.Transform, Boolean)
static bool w_vtob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtob");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetParent(UnityEngine.GameObject, Boolean, Boolean, Boolean)
static bool w_vtobDbDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtobDbDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,void* p0, bool p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void ScrollToView(FairyGUI.GObject, Boolean, Boolean)
static bool w_vtobb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtobb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetWrapTarget(UnityEngine.GameObject, Boolean, Int32, Int32)
static bool w_vtobi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtobi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void CopyTo(UnityEngine.GameObject[], Int32)
static bool w_vtoi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddRelation(FairyGUI.GObject, FairyGUI.RelationType, Boolean)
static bool w_vtoi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetParticles(Particle[], Int32, Int32)
static bool w_vtoi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(FairyGUI.PixelHitTestData, Int32, Int32, Single, Single)
static bool w_vtoi4i4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, float p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Show(FairyGUI.GObject, FairyGUI.PopupDirection, FairyGUI.PopupMenu)
static bool w_vtoi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void GetComponents(System.Type, System.Collections.Generic.List`1[UnityEngine.Component])
static bool w_vtoo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void ShowPopup(FairyGUI.GObject, FairyGUI.GObject, FairyGUI.PopupDirection)
static bool w_vtooi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtooi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ShowPopup(FairyGUI.GObject, FairyGUI.GObject, FairyGUI.PopupDirection, Boolean)
static bool w_vtooi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtooi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Texture, UnityEngine.Texture, Single, Single)
static bool w_vtoor4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoor4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void PlayOneShotSound(UnityEngine.AudioClip, Single)
static bool w_vtor4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtor4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Update(FairyGUI.UpdateContext, Single, Boolean)
static bool w_vtor4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtor4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, float p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetGORawTex(UnityEngine.GameObject, System.String)
static bool w_vtos(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void StartDrag(FairyGUI.GObject, System.String, System.Object, Int32)
static bool w_vtosODi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtosODi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
static bool w_vtos_Oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_Oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_Oi4_* pp1 = DataTransfer::GetPointer<s_Oi4_>(context, info[1]);
    s_Oi4_ p1 = pp1 ? *pp1 : s_Oi4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_Oi4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void LookAt(UnityEngine.Transform, UnityEngine.Vector3)
static bool w_vtos_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void DrawPolygon(System.Collections.Generic.IList`1[UnityEngine.Vector2], UnityEngine.Color)
static bool w_vtos_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(FairyGUI.NTexture, UnityEngine.Rect, Boolean)
static bool w_vtos_r4r4r4r4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4r4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(FairyGUI.NTexture, UnityEngine.Rect, Boolean, UnityEngine.Vector2, UnityEngine.Vector2)
static bool w_vtos_r4r4r4r4_bs_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4r4_bs_r4r4_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if ((!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4_>(context, info[3]);
    s_r4r4_ p3 = pp3 ? *pp3 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp4 = DataTransfer::GetPointer<s_r4r4_>(context, info[4]);
    s_r4r4_ p4 = pp4 ? *pp4 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4_ p1, bool p2, struct s_r4r4_ p3, struct s_r4r4_ p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawPolygon(System.Collections.Generic.IList`1[UnityEngine.Vector2], UnityEngine.Color, Single, UnityEngine.Color)
static bool w_vtos_r4r4r4r4_r4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4r4_r4s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4_ p1, float p2, struct s_r4r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(System.Collections.Generic.Dictionary`2[System.String,System.Byte[]], System.String, System.Collections.Generic.List`1[System.String])
static bool w_vtoso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Run(FairyGUI.Controller, System.String, System.String)
static bool w_vtoss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(IntPtr)
static bool w_vtp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtp");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsArrayBuffer()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(IntPtr, Boolean)
static bool w_vtpDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtpDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_startDelay(Single)
static bool w_vtr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,float p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Simulate(Single, Boolean)
static bool w_vtr4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,float p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Simulate(Single, Boolean, Boolean)
static bool w_vtr4bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4bb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,float p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Simulate(Single, Boolean, Boolean, Boolean)
static bool w_vtr4bbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4bbb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,float p0, bool p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetSpeed(Single, Int32)
static bool w_vtr4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,float p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Add(Single, Int32, FairyGUI.TimerCallback)
static bool w_vtr4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4i4o");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,float p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Add(Single, Int32, FairyGUI.TimerCallback, System.Object)
static bool w_vtr4i4oO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4i4oO");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,float p0, int32_t p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawRect(Single, UnityEngine.Color32[])
static bool w_vtr4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,float p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Set(Single, Single)
static bool w_vtr4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,float p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetXY(Single, Single, Boolean)
static bool w_vtr4r4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,float p0, float p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void DrawRect(Single, Single, Int32, UnityEngine.Color, UnityEngine.Color)
static bool w_vtr4r4i4s_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4i4s_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if ((!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp4 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[4]);
    s_r4r4r4r4_ p4 = pp4 ? *pp4 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,float p0, float p1, int32_t p2, struct s_r4r4r4r4_ p3, struct s_r4r4r4r4_ p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawPolygon(Single, Single, System.Collections.Generic.IList`1[UnityEngine.Vector2], UnityEngine.Color)
static bool w_vtr4r4os_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4os_r4r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,float p0, float p1, void* p2, struct s_r4r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawPolygon(Single, Single, System.Collections.Generic.IList`1[UnityEngine.Vector2], UnityEngine.Color, Single, UnityEngine.Color)
static bool w_vtr4r4os_r4r4r4r4_r4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4os_r4r4r4r4_r4s_r4r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if ((!info[5]->IsObject() || !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp5 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[5]);
    s_r4r4r4r4_ p5 = pp5 ? *pp5 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,float p0, float p1, void* p2, struct s_r4r4r4r4_ p3, float p4, struct s_r4r4r4r4_ p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void Set(Single, Single, Single)
static bool w_vtr4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void AddFilled(Single, Single, Single, Int32, Int32)
static bool w_vtr4r4r4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4Di4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Translate(Single, Single, Single, UnityEngine.Space)
static bool w_vtr4r4r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Translate(Single, Single, Single, UnityEngine.Transform)
static bool w_vtr4r4r4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4o");
    
    auto TIp3 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Set(Single, Single, Single, Single)
static bool w_vtr4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetLimit(Single, Single, Single, Single, Boolean)
static bool w_vtr4r4r4r4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4r4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, float p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void LerpRotation(Single, Single, Single, Single, Single)
static bool w_vtr4r4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, float p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetValue(Single, Single, System.String)
static bool w_vtr4r4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4s");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(void*,float p0, float p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void DrawEllipse(Single, Single, UnityEngine.Color)
static bool w_vtr4r4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4s_r4r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,float p0, float p1, struct s_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void DrawRoundRect(Single, Single, UnityEngine.Color, Single[])
static bool w_vtr4r4s_r4r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4s_r4r4r4r4_o");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,float p0, float p1, struct s_r4r4r4r4_ p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Single, UnityEngine.Color, Boolean)
static bool w_vtr4s_r4r4r4r4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4s_r4r4r4r4_b");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,float p0, struct s_r4r4r4r4_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void DrawRect(Single, UnityEngine.Color, UnityEngine.Color)
static bool w_vtr4s_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4s_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,float p0, struct s_r4r4r4r4_ p1, struct s_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void DrawRoundRect(Single, UnityEngine.Color, UnityEngine.Color, Single, Single, Single, Single)
static bool w_vtr4s_r4r4r4r4_s_r4r4r4r4_r4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4s_r4r4r4r4_s_r4r4r4r4_r4r4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
        if (!converter::Converter<float>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(context, info[6]);

    typedef void (*FuncToCall)(void*,float p0, struct s_r4r4r4r4_ p1, struct s_r4r4r4r4_ p2, float p3, float p4, float p5, float p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void DrawEllipse(Single, UnityEngine.Color, UnityEngine.Color, UnityEngine.Color, Single, Single)
static bool w_vtr4s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4r4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,float p0, struct s_r4r4r4r4_ p1, struct s_r4r4r4r4_ p2, struct s_r4r4r4r4_ p3, float p4, float p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void set_min(Double)
static bool w_vtr8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<double>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,double p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_tag(System.String)
static bool w_vts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void showDialog(System.String, System.Action, System.Action, System.String, System.String, System.String)
static bool w_vtsDoDoDsDsDs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsDoDoDsDsDs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (length > 2 && !info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (length > 3 && !info[3]->IsString() && !info[3]->IsNullOrUndefined()) return false;
        if (length > 4 && !info[4]->IsString() && !info[4]->IsNullOrUndefined()) return false;
        if (length > 5 && !info[5]->IsString() && !info[5]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal ref  with default
    void* p1 = OptionalParameter<void*>::GetRefType(context, info, method, 1, TIp1);
                
    // JSValToCSVal ref  with default
    void* p2 = OptionalParameter<void*>::GetRefType(context, info, method, 2, TIp2);
                
    // JSValToCSVal string  with default
    void* p3 = OptionalParameter<void*>::GetString(context, info, method, 3);
                
    // JSValToCSVal string  with default
    void* p4 = OptionalParameter<void*>::GetString(context, info, method, 4);
                
    // JSValToCSVal string  with default
    void* p5 = OptionalParameter<void*>::GetString(context, info, method, 5);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(System.String, Single, Int32)
static bool w_vtsDr4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsDr4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !converter::Converter<float>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, float p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Connect(System.String, System.String, System.String)
static bool w_vtsDsDs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsDsDs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (length > 2 && !info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal string  with default
    void* p1 = OptionalParameter<void*>::GetString(context, info, method, 1);
                
    // JSValToCSVal string  with default
    void* p2 = OptionalParameter<void*>::GetString(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SendMessageUpwards(System.String, System.Object)
static bool w_vtsO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SendMessageUpwards(System.String, System.Object, UnityEngine.SendMessageOptions)
static bool w_vtsOi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsOi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void readString(System.String, System.String ByRef)
static bool w_vtsPs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal Ps
    void* up1 = nullptr; // string ref
    void** p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        v8::String::Utf8Value tp1(isolate, op1->Get(context, 0).ToLocalChecked());
        up1 = CStringToCSharpString(*tp1);
    }
        

    typedef void (*FuncToCall)(void*,void* p0, void** p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, CSAnyToJsValue(isolate, context, *p1));
    }
    
    return true;
}

// Void SetValue(System.String, System.Object[])
static bool w_vtsVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal ref params
    void* p1 = RestArguments<void*>::PackRef(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.String, System.Type[])
static bool w_vtsVo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && !info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal ref params
    void* p1 = RestArguments<void*>::PackRef(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle])
static bool w_vts_Pvi4i4i4pi4i4oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pvi4i4i4pi4i4oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};

    typedef void (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32)
static bool w_vts_Pvi4i4i4pi4i4oi4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pvi4i4i4pi4i4oi4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetParticles(Unity.Collections.NativeArray`1[UnityEngine.ParticleSystem+Particle], Int32, Int32)
static bool w_vts_Pvi4i4i4pi4i4oi4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pvi4i4i4pi4i4oi4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void set_clipRect(System.Nullable`1[UnityEngine.Rect])
static bool w_vts_br4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_br4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_br4r4r4r4_* pp0 = DataTransfer::GetPointer<s_br4r4r4r4_>(context, info[0]);
    s_br4r4r4r4_ p0 = pp0 ? *pp0 : s_br4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_br4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_margin(FairyGUI.Margin)
static bool w_vts_i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4i4_>(context, info[0]);
    s_i4i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4i4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(GCore.F64, GCore.F64, GCore.F64)
static bool w_vts_i8_s_i8_s_i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i8_s_i8_s_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8_* pp0 = DataTransfer::GetPointer<s_i8_>(context, info[0]);
    s_i8_ p0 = pp0 ? *pp0 : s_i8_ {};
    // JSValToCSVal struct
    s_i8_* pp1 = DataTransfer::GetPointer<s_i8_>(context, info[1]);
    s_i8_ p1 = pp1 ? *pp1 : s_i8_ {};
    // JSValToCSVal struct
    s_i8_* pp2 = DataTransfer::GetPointer<s_i8_>(context, info[2]);
    s_i8_ p2 = pp2 ? *pp2 : s_i8_ {};

    typedef void (*FuncToCall)(void*,struct s_i8_ p0, struct s_i8_ p1, struct s_i8_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(GCore.F64, GCore.F64, GCore.F64, GCore.F64)
static bool w_vts_i8_s_i8_s_i8_s_i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i8_s_i8_s_i8_s_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8_* pp0 = DataTransfer::GetPointer<s_i8_>(context, info[0]);
    s_i8_ p0 = pp0 ? *pp0 : s_i8_ {};
    // JSValToCSVal struct
    s_i8_* pp1 = DataTransfer::GetPointer<s_i8_>(context, info[1]);
    s_i8_ p1 = pp1 ? *pp1 : s_i8_ {};
    // JSValToCSVal struct
    s_i8_* pp2 = DataTransfer::GetPointer<s_i8_>(context, info[2]);
    s_i8_ p2 = pp2 ? *pp2 : s_i8_ {};
    // JSValToCSVal struct
    s_i8_* pp3 = DataTransfer::GetPointer<s_i8_>(context, info[3]);
    s_i8_ p3 = pp3 ? *pp3 : s_i8_ {};

    typedef void (*FuncToCall)(void*,struct s_i8_ p0, struct s_i8_ p1, struct s_i8_ p2, struct s_i8_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void CopyFrom(GCore.FVector3)
static bool w_vts_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};

    typedef void (*FuncToCall)(void*,struct s_i8i8i8_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void InsertPolyPoint(GCore.FVector3, Int32)
static bool w_vts_i8i8i8_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i8i8i8_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_i8i8i8_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void CopyFrom(GCore.FQuaterion)
static bool w_vts_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, info[0]);
    s_i8i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8i8_ {};

    typedef void (*FuncToCall)(void*,struct s_i8i8i8i8_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetTrails(Trails)
static bool w_vts_ooooi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_ooooi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_ooooi4i4_* pp0 = DataTransfer::GetPointer<s_ooooi4i4_>(context, info[0]);
    s_ooooi4i4_ p0 = pp0 ? *pp0 : s_ooooi4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_ooooi4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Scale(UnityEngine.Vector2)
static bool w_vts_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetCustomInput(UnityEngine.Vector2, Boolean)
static bool w_vts_r4r4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_r4r4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetCustomInput(UnityEngine.Vector2, Boolean, Boolean)
static bool w_vts_r4r4_bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4_bb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_r4r4_ p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Add(UnityEngine.Vector2, UnityEngine.Vector2)
static bool w_vts_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4_ p0, struct s_r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Scale(UnityEngine.Vector3)
static bool w_vts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetTargetPos(UnityEngine.Vector3, Boolean)
static bool w_vts_r4r4r4_Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_Db");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Translate(UnityEngine.Vector3, UnityEngine.Space)
static bool w_vts_r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Translate(UnityEngine.Vector3, UnityEngine.Transform)
static bool w_vts_r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Rotate(UnityEngine.Vector3, Single)
static bool w_vts_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Rotate(UnityEngine.Vector3, Single, UnityEngine.Space)
static bool w_vts_r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, float p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void AddVert(UnityEngine.Vector3, UnityEngine.Color32)
static bool w_vts_r4r4r4_s_i4u1u1u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_i4u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_i4u1u1u1u1_* pp1 = DataTransfer::GetPointer<s_i4u1u1u1u1_>(context, info[1]);
    s_i4u1u1u1u1_ p1 = pp1 ? *pp1 : s_i4u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_i4u1u1u1u1_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddVert(UnityEngine.Vector3, UnityEngine.Color32, UnityEngine.Vector2)
static bool w_vts_r4r4r4_s_i4u1u1u1u1_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_i4u1u1u1u1_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_i4u1u1u1u1_* pp1 = DataTransfer::GetPointer<s_i4u1u1u1u1_>(context, info[1]);
    s_i4u1u1u1u1_ p1 = pp1 ? *pp1 : s_i4u1u1u1u1_ {};
    // JSValToCSVal struct
    s_r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4_>(context, info[2]);
    s_r4r4_ p2 = pp2 ? *pp2 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_i4u1u1u1u1_ p1, struct s_r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void LookAt(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_vts_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void RotateAround(UnityEngine.Vector3, UnityEngine.Vector3, Single)
static bool w_vts_r4r4r4_s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_vts_r4r4r4_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetPositionAndRotation(UnityEngine.Vector3, UnityEngine.Quaternion)
static bool w_vts_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetPlaybackState(PlaybackState)
static bool w_vts_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_>(context, info[0]);
    s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_rotation(UnityEngine.Quaternion)
static bool w_vts_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Tint(UnityEngine.Color, Single)
static bool w_vts_r4r4r4r4_Dr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_Dr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (length > 1 && !converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void ScrollToView(UnityEngine.Rect, Boolean, Boolean)
static bool w_vts_r4r4r4r4_bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_bb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void LerpRotation(UnityEngine.Quaternion, Single)
static bool w_vts_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddQuad(UnityEngine.Rect, UnityEngine.Color32)
static bool w_vts_r4r4r4r4_s_i4u1u1u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_s_i4u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_i4u1u1u1u1_* pp1 = DataTransfer::GetPointer<s_i4u1u1u1u1_>(context, info[1]);
    s_i4u1u1u1u1_ p1 = pp1 ? *pp1 : s_i4u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, struct s_i4u1u1u1u1_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddQuad(UnityEngine.Rect, UnityEngine.Color32, UnityEngine.Rect)
static bool w_vts_r4r4r4r4_s_i4u1u1u1u1_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_s_i4u1u1u1u1_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_i4u1u1u1u1_* pp1 = DataTransfer::GetPointer<s_i4u1u1u1u1_>(context, info[1]);
    s_i4u1u1u1u1_ p1 = pp1 ? *pp1 : s_i4u1u1u1u1_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, struct s_i4u1u1u1u1_ p1, struct s_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Create(FairyGUI.GPathPoint, FairyGUI.GPathPoint)
static bool w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4i4b_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4i4b_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4i4b_ p0, struct s_r4r4r4r4r4r4r4r4r4i4b_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Create(FairyGUI.GPathPoint, FairyGUI.GPathPoint, FairyGUI.GPathPoint)
static bool w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4i4b_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4i4b_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[2]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p2 = pp2 ? *pp2 : s_r4r4r4r4r4r4r4r4r4i4b_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4i4b_ p0, struct s_r4r4r4r4r4r4r4r4r4i4b_ p1, struct s_r4r4r4r4r4r4r4r4r4i4b_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Create(FairyGUI.GPathPoint, FairyGUI.GPathPoint, FairyGUI.GPathPoint, FairyGUI.GPathPoint)
static bool w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4i4b_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4i4b_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[2]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p2 = pp2 ? *pp2 : s_r4r4r4r4r4r4r4r4r4i4b_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[3]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p3 = pp3 ? *pp3 : s_r4r4r4r4r4r4r4r4r4i4b_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4i4b_ p0, struct s_r4r4r4r4r4r4r4r4r4i4b_ p1, struct s_r4r4r4r4r4r4r4r4r4i4b_ p2, struct s_r4r4r4r4r4r4r4r4r4i4b_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Emit(EmitParams, Int32)
static bool w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void ToggleKeyword(System.String, Boolean)
static bool w_vtsb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void OpenKeyboard(System.String, Boolean, Boolean, Boolean, Boolean, System.String, Int32, Boolean)
static bool w_vtsbbbbsi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsbbbbsi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!info[5]->IsString() && !info[5]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal s
    v8::String::Utf8Value tp5(isolate, info[5]);
    void* p5 = CStringToCSharpString(*tp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, bool p2, bool p3, bool p4, void* p5, int32_t p6, bool p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void InitDB(System.String, Boolean, System.String, Int32)
static bool w_vtsbsDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsbsDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,void* p0, bool p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SendMessageUpwards(System.String, UnityEngine.SendMessageOptions)
static bool w_vtsi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.String, Int32, Int32)
static bool w_vtsi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void StartGamePlay(System.String, Int64, Int64)
static bool w_vtsi8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsi8i8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, int64_t p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetShaderAndTexture(System.String, FairyGUI.NTexture)
static bool w_vtso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void getTextrue(System.String, System.Action`1[UnityEngine.Texture], Boolean)
static bool w_vtsoDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsoDb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetValue(System.String, System.Action, System.String)
static bool w_vtsoDs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsoDs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (length > 2 && !info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal string  with default
    void* p2 = OptionalParameter<void*>::GetString(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SaveEditorMap(System.String, Puerts.ArrayBuffer, Boolean)
static bool w_vtsob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetValue(System.String, System.Action, System.Action, System.String, System.String)
static bool w_vtsooDsDs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsooDsDs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (length > 3 && !info[3]->IsString() && !info[3]->IsNullOrUndefined()) return false;
        if (length > 4 && !info[4]->IsString() && !info[4]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal string  with default
    void* p3 = OptionalParameter<void*>::GetString(context, info, method, 3);
                
    // JSValToCSVal string  with default
    void* p4 = OptionalParameter<void*>::GetString(context, info, method, 4);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, void* p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(System.String, UnityEngine.GameObject, System.Type, Int32)
static bool w_vtsooi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsooi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Parse(System.String, FairyGUI.TextFormat, System.Collections.Generic.List`1[FairyGUI.Utils.HtmlElement], FairyGUI.Utils.HtmlParseOptions)
static bool w_vtsooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(System.String, GCore.DBPool, GCore.DBPool, GCore.DBPool, GCore.EthereumUtil, System.Collections.Generic.Dictionary`2[System.String,System.Byte[]], System.Func`2[System.String,System.Byte[]], GCore.GIMode, GCore.IRedisConnect)
static bool w_vtsooooooi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsooooooi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp8 = wrapData->TypeInfos[7];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!info[8]->IsNullOrUndefined() && (!info[8]->IsObject() || (info[8]->IsFunction() ? !IsDelegate(TIp8) : !IsAssignableFrom(TIp8, GetTypeId(info[8].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal o/O
    void* p8 = JsValueToCSRef(context, info[8], TIp8);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, int32_t p7, void* p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void RegisterCursor(System.String, UnityEngine.Texture2D, UnityEngine.Vector2)
static bool w_vtsos_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsos_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal struct
    s_r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4_>(context, info[2]);
    s_r4r4_ p2 = pp2 ? *pp2 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, void* p1, struct s_r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Invoke(System.String, Single)
static bool w_vtsr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void InvokeRepeating(System.String, Single, Single)
static bool w_vtsr4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsr4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetItemText(System.String, System.String)
static bool w_vtss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void ListenNFTTransfer(System.String, System.String, System.String)
static bool w_vtsss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void C_AddMeshCollider(System.String, UInt32, Int32, Int64, Boolean, Boolean, Int64, Boolean)
static bool w_vtsu4i4i8bbi8b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsu4i4i8bbi8b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!converter::Converter<bool>::accept(context, info[5])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[6])) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int64_t p6 = converter::Converter<int64_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void*,void* p0, uint32_t p1, int32_t p2, int64_t p3, bool p4, bool p5, int64_t p6, bool p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void SendMsg(UInt16, Byte[], Int32, Int32)
static bool w_vtu2oDi4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu2oDi4Di4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<uint16_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,uint16_t p0, void* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SendBuffer(UInt16, Puerts.ArrayBuffer, Boolean)
static bool w_vtu2ob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu2ob");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<uint16_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,uint16_t p0, void* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void set_randomSeed(UInt32)
static bool w_vtu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,uint32_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void EnterClipping(UInt32, Boolean)
static bool w_vtu4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,uint32_t p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void C_FreezePhyRot(UInt32, Boolean, Boolean, Boolean)
static bool w_vtu4bbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4bbb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,uint32_t p0, bool p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void C_SetPhyLayer(UInt32, Int32)
static bool w_vtu4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void C_SetActionBlacklist(UInt32, Int32, Boolean)
static bool w_vtu4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetGridUnit(UInt32, Int32, Int32, Int32)
static bool w_vtu4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void C_AddRVOObstacle(UInt32, Int32, Int64, Int64)
static bool w_vtu4i4i8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i4i8i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int32_t p1, int64_t p2, int64_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void C_AddRVOAgent(UInt32, Int32, Int64, Int64, Int32, Int64)
static bool w_vtu4i4i8i8i4i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i4i8i8i4i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int64_t p5 = converter::Converter<int64_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int32_t p1, int64_t p2, int64_t p3, int32_t p4, int64_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void C_AddCrowd(UInt32, Int32, Int64, Int64, Int64, Int64, Int32)
static bool w_vtu4i4i8i8i8i8Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i4i8i8i8i8Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 6) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[5])) return false;
        if (length > 6 && !converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int64_t p5 = converter::Converter<int64_t>::toCpp(context, info[5]);
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 6);
                

    typedef void (*FuncToCall)(void*,uint32_t p0, int32_t p1, int64_t p2, int64_t p3, int64_t p4, int64_t p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void C_SetWorldSt(UInt32, Int64)
static bool w_vtu4i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void C_SetAIGoal(UInt32, Int64, Boolean, Boolean)
static bool w_vtu4i8bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8bb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void C_AddSphereCollider(UInt32, Int64, Boolean, Boolean, Int64, Int32, Int64, Boolean)
static bool w_vtu4i8bbi8i4i8b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8bbi8i4i8b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[6])) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int64_t p6 = converter::Converter<int64_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, bool p2, bool p3, int64_t p4, int32_t p5, int64_t p6, bool p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void C_AddCapsuleCollider(UInt32, Int64, Int64, Boolean, Boolean, Int64, Int32, Int64, Boolean)
static bool w_vtu4i8i8bbi8i4i8b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8i8bbi8i4i8b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[7])) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int64_t p5 = converter::Converter<int64_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int64_t p7 = converter::Converter<int64_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, int64_t p2, bool p3, bool p4, int64_t p5, int32_t p6, int64_t p7, bool p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void C_SetPosition(UInt32, Int64, Int64, Int64)
static bool w_vtu4i8i8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8i8i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, int64_t p2, int64_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void C_SetRVOVelocity(UInt32, Int64, Int64, Int64, Boolean)
static bool w_vtu4i8i8i8Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8i8i8Db");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<bool>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(context, info, method, 4);
                

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, int64_t p2, int64_t p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void C_SetRotation(UInt32, Int64, Int64, Int64, Int64)
static bool w_vtu4i8i8i8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8i8i8i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, int64_t p2, int64_t p3, int64_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void MoveTo(UInt32, Int64, Int64, Int64, Int64, Boolean, Boolean)
static bool w_vtu4i8i8i8i8bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8i8i8i8bb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[4])) return false;
        if (!converter::Converter<bool>::accept(context, info[5])) return false;
        if (!converter::Converter<bool>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(context, info[5]);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(context, info[6]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, int64_t p2, int64_t p3, int64_t p4, bool p5, bool p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void MoveToWithRad(UInt32, Int64, Int64, Int64, Int64, Boolean, Int64, Int64)
static bool w_vtu4i8i8i8i8bi8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8i8i8i8bi8i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[4])) return false;
        if (!converter::Converter<bool>::accept(context, info[5])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[7])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int64_t p6 = converter::Converter<int64_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int64_t p7 = converter::Converter<int64_t>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, int64_t p2, int64_t p3, int64_t p4, bool p5, int64_t p6, int64_t p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void C_SetCrowdVelocity(UInt32, GCore.FVector3)
static bool w_vtu4s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4s_i8i8i8_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};

    typedef void (*FuncToCall)(void*,uint32_t p0, struct s_i8i8i8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void C_AddBoxCollider(UInt32, GCore.FVector3, Boolean, Boolean, Int64, Int32, Int64, Boolean)
static bool w_vtu4s_i8i8i8_bbi8i4i8b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4s_i8i8i8_bbi8i4i8b");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[6])) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int64_t p6 = converter::Converter<int64_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void*,uint32_t p0, struct s_i8i8i8_ p1, bool p2, bool p3, int64_t p4, int32_t p5, int64_t p6, bool p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void C_AddTempObstacle(UInt32, GCore.FVector3, Int64, Int64)
static bool w_vtu4s_i8i8i8_i8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4s_i8i8i8_i8i8");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,uint32_t p0, struct s_i8i8i8_ p1, int64_t p2, int64_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void C_AddPointForce(UInt32, GCore.FVector3, GCore.FVector3)
static bool w_vtu4s_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4s_i8i8i8_s_i8i8i8_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef void (*FuncToCall)(void*,uint32_t p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void EnterClipping(UInt32, UnityEngine.Rect, System.Nullable`1[UnityEngine.Vector4])
static bool w_vtu4s_r4r4r4r4_s_br4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4s_r4r4r4r4_s_br4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_br4r4r4r4_* pp2 = DataTransfer::GetPointer<s_br4r4r4r4_>(context, info[2]);
    s_br4r4r4r4_ p2 = pp2 ? *pp2 : s_br4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,uint32_t p0, struct s_r4r4r4r4_ p1, struct s_br4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void C_IgnorePhyCollision(UInt32, UInt32, Boolean)
static bool w_vtu4u4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4u4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,uint32_t p0, uint32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void C_SetActionCost(UInt32, UInt32, Int32)
static bool w_vtu4u4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4u4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,uint32_t p0, uint32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void C_AddAction(UInt32, UInt32, Int64, Int64, Int32, Int32)
static bool w_vtu4u4i8i8i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4u4i8i8i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,uint32_t p0, uint32_t p1, int64_t p2, int64_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

static WrapFuncInfo g_wrapFuncInfos[] = {
    
    {"Os", w_Os},
    {"Oss", w_Oss},
    {"Ot", w_Ot},
    {"OtVO", w_OtVO},
    {"Oti4", w_Oti4},
    {"Oto", w_Oto},
    {"Ots", w_Ots},
    {"POti4", w_POti4},
    {"b", w_b},
    {"bO", w_bO},
    {"bOi4", w_bOi4},
    {"bc", w_bc},
    {"bi4", w_bi4},
    {"bo", w_bo},
    {"boPs_r4r4r4r4r4r4u4r4r4r4i4_", w_boPs_r4r4r4r4r4r4u4r4r4r4i4_},
    {"boo", w_boo},
    {"bs", w_bs},
    {"bs_r4r4_s_r4r4_", w_bs_r4r4_s_r4r4_},
    {"bs_r4r4r4_s_r4r4r4_", w_bs_r4r4r4_s_r4r4r4_},
    {"bs_r4r4r4r4_s_r4r4r4r4_", w_bs_r4r4r4r4_s_r4r4r4r4_},
    {"bsb", w_bsb},
    {"bt", w_bt},
    {"btO", w_btO},
    {"btb", w_btb},
    {"btc", w_btc},
    {"btcPr4Pr4Pr4", w_btcPr4Pr4Pr4},
    {"bti4", w_bti4},
    {"bti4Po", w_bti4Po},
    {"bti4i4", w_bti4i4},
    {"bti4i4i4i4", w_bti4i4i4i4},
    {"bti4o", w_bti4o},
    {"bto", w_bto},
    {"btoPo", w_btoPo},
    {"bts", w_bts},
    {"btsO", w_btsO},
    {"btsOO", w_btsOO},
    {"btsPo", w_btsPo},
    {"bts_i8i8i8_s_i8i8i8_i8i4i4i4", w_bts_i8i8i8_s_i8i8i8_i8i4i4i4},
    {"bts_i8i8i8_s_i8i8i8_i8i4i4i4i8", w_bts_i8i8i8_s_i8i8i8_i8i4i4i4i8},
    {"bts_r4r4_", w_bts_r4r4_},
    {"bts_r4r4r4_", w_bts_r4r4r4_},
    {"bts_r4r4r4r4_", w_bts_r4r4r4r4_},
    {"bts_r4r4r4r4_s_r4r4_", w_bts_r4r4r4r4_s_r4r4_},
    {"btsb", w_btsb},
    {"btso", w_btso},
    {"btsssi4i4si8so", w_btsssi4i4si8so},
    {"btu4", w_btu4},
    {"btu4i4", w_btu4i4},
    {"ct", w_ct},
    {"i2t", w_i2t},
    {"i4", w_i4},
    {"i4c", w_i4c},
    {"i4i4", w_i4i4},
    {"i4p", w_i4p},
    {"i4pPs_i8_Ps_i8_i4", w_i4pPs_i8_Ps_i8_i4},
    {"i4pPs_i8i8i8_Di4Di4", w_i4pPs_i8i8i8_Di4Di4},
    {"i4pPs_i8i8i8_Ps_i8i8i8_Pi8i4i4i4Ps_i8i8i8_", w_i4pPs_i8i8i8_Ps_i8i8i8_Pi8i4i4i4Ps_i8i8i8_},
    {"i4pPs_i8i8i8_Ps_i8i8i8_Pi8i4i4i4Ps_i8i8i8_Pi8", w_i4pPs_i8i8i8_Ps_i8i8i8_Pi8i4i4i4Ps_i8i8i8_Pi8},
    {"i4pPs_i8i8i8_Ps_i8i8i8_Ps_i8_", w_i4pPs_i8i8i8_Ps_i8i8i8_Ps_i8_},
    {"i4pPs_i8i8i8_Ps_i8i8i8_o", w_i4pPs_i8i8i8_Ps_i8i8i8_o},
    {"i4pi4", w_i4pi4},
    {"i4pi4Ps_i8i8i8_Ps_i8i8i8_o", w_i4pi4Ps_i8i8i8_Ps_i8i8i8_o},
    {"i4pi4Ps_i8i8i8_Ps_i8i8i8_oPi8", w_i4pi4Ps_i8i8i8_Ps_i8i8i8_oPi8},
    {"i4pi4i4", w_i4pi4i4},
    {"i4pi4i4Di4Di4", w_i4pi4i4Di4Di4},
    {"i4pi4i4i4i4", w_i4pi4i4i4i4},
    {"i4po", w_i4po},
    {"i4poi4", w_i4poi4},
    {"i4ps", w_i4ps},
    {"i4pu4", w_i4pu4},
    {"i4pu4i4", w_i4pu4i4},
    {"i4pu4o", w_i4pu4o},
    {"i4s", w_i4s},
    {"i4si4", w_i4si4},
    {"i4t", w_i4t},
    {"i4tO", w_i4tO},
    {"i4tOi4", w_i4tOi4},
    {"i4tOi4i4", w_i4tOi4i4},
    {"i4tOo", w_i4tOo},
    {"i4tPs_ooooi4i4_", w_i4tPs_ooooi4i4_},
    {"i4ti4", w_i4ti4},
    {"i4ti4i4", w_i4ti4i4},
    {"i4ti4i4Oo", w_i4ti4i4Oo},
    {"i4ti4i4i4", w_i4ti4i4i4},
    {"i4ti4i4i4i4", w_i4ti4i4i4i4},
    {"i4ti4i4i4o", w_i4ti4i4i4o},
    {"i4ti4i4o", w_i4ti4i4o},
    {"i4ti4i4oo", w_i4ti4i4oo},
    {"i4ti4i4so", w_i4ti4i4so},
    {"i4ti4o", w_i4ti4o},
    {"i4ti8i8i4", w_i4ti8i8i4},
    {"i4ti8i8i4i4", w_i4ti8i8i4i4},
    {"i4ti8i8i8i8", w_i4ti8i8i8i8},
    {"i4to", w_i4to},
    {"i4toi4", w_i4toi4},
    {"i4toi4i4", w_i4toi4i4},
    {"i4too", w_i4too},
    {"i4tr4r4oooo", w_i4tr4r4oooo},
    {"i4tr4r4r4i4i4oooo", w_i4tr4r4r4i4i4oooo},
    {"i4ts", w_i4ts},
    {"i4ts_Pvi4i4i4pi4i4oi4_", w_i4ts_Pvi4i4i4pi4i4oi4_},
    {"i4ts_Pvi4i4i4pi4i4oi4_i4", w_i4ts_Pvi4i4i4pi4i4oi4_i4},
    {"i4ts_Pvi4i4i4pi4i4oi4_i4i4", w_i4ts_Pvi4i4i4pi4i4oi4_i4i4},
    {"i4tsi4", w_i4tsi4},
    {"i4tsi4i4", w_i4tsi4i4},
    {"i4tso", w_i4tso},
    {"i4tu4", w_i4tu4},
    {"i8Pi8", w_i8Pi8},
    {"i8Pi8Pi8", w_i8Pi8Pi8},
    {"i8Ps_i8i8i8_", w_i8Ps_i8i8i8_},
    {"i8Ps_i8i8i8_Ps_i8i8i8_", w_i8Ps_i8i8i8_Ps_i8i8i8_},
    {"i8Ps_i8i8i8i8_", w_i8Ps_i8i8i8i8_},
    {"i8pPs_i8_", w_i8pPs_i8_},
    {"i8pPs_i8_Ps_i8_Ps_i8i8i8_", w_i8pPs_i8_Ps_i8_Ps_i8i8i8_},
    {"i8pi4", w_i8pi4},
    {"i8t", w_i8t},
    {"i8ti4", w_i8ti4},
    {"i8ti4s_i8i8i8_s_i8i8i8_", w_i8ti4s_i8i8i8_s_i8i8i8_},
    {"i8ti8", w_i8ti8},
    {"i8ti8i8", w_i8ti8i8},
    {"i8ti8i8i8i8", w_i8ti8i8i8i8},
    {"i8ts_i8i8i8_", w_i8ts_i8i8i8_},
    {"i8tss_i8i8i8_s_i8i8i8_", w_i8tss_i8i8i8_s_i8i8i8_},
    {"o", w_o},
    {"oO", w_oO},
    {"oOi4", w_oOi4},
    {"oVo", w_oVo},
    {"oi4", w_oi4},
    {"oi4i4b", w_oi4i4b},
    {"oo", w_oo},
    {"ooDo", w_ooDo},
    {"ooOo", w_ooOo},
    {"ooOob", w_ooOob},
    {"ooOs", w_ooOs},
    {"ooOsb", w_ooOsb},
    {"ooOsbb", w_ooOsbb},
    {"oob", w_oob},
    {"ooi4", w_ooi4},
    {"ooi4i4", w_ooi4i4},
    {"ooo", w_ooo},
    {"ooob", w_ooob},
    {"ooos", w_ooos},
    {"ooosb", w_ooosb},
    {"ooosbb", w_ooosbb},
    {"oos_r4r4r4_s_r4r4r4r4_", w_oos_r4r4r4_s_r4r4r4r4_},
    {"oos_r4r4r4_s_r4r4r4r4_o", w_oos_r4r4r4_s_r4r4r4r4_o},
    {"ooso", w_ooso},
    {"or4", w_or4},
    {"or4r4r4", w_or4r4r4},
    {"or8r8r4", w_or8r8r4},
    {"os", w_os},
    {"os_r4r4_s_r4r4_r4", w_os_r4r4_s_r4r4_r4},
    {"os_r4r4r4_r4r4", w_os_r4r4r4_r4r4},
    {"os_r4r4r4_s_r4r4r4_r4", w_os_r4r4r4_s_r4r4r4_r4},
    {"os_r4r4r4r4_s_r4r4r4r4_r4", w_os_r4r4r4r4_s_r4r4r4r4_r4},
    {"osi4", w_osi4},
    {"oso", w_oso},
    {"oss", w_oss},
    {"osso", w_osso},
    {"ot", w_ot},
    {"otO", w_otO},
    {"otOi4", w_otOi4},
    {"otb", w_otb},
    {"oti4", w_oti4},
    {"oti4Db", w_oti4Db},
    {"oti4b", w_oti4b},
    {"oti4i4", w_oti4i4},
    {"oti4i4i4", w_oti4i4i4},
    {"oti4i4i4i4i4", w_oti4i4i4i4i4},
    {"oti4i4u4", w_oti4i4u4},
    {"oti4o", w_oti4o},
    {"oti4s", w_oti4s},
    {"oti4s_i8i8i8_s_i8i8i8_", w_oti4s_i8i8i8_s_i8i8i8_},
    {"oti4s_i8i8i8_s_i8i8i8_i8Pi4", w_oti4s_i8i8i8_s_i8i8i8_i8Pi4},
    {"oti8i8Di4Di4Di4", w_oti8i8Di4Di4Di4},
    {"oto", w_oto},
    {"otoDb", w_otoDb},
    {"otob", w_otob},
    {"otoi4", w_otoi4},
    {"otoi4i4", w_otoi4i4},
    {"otoo", w_otoo},
    {"otos", w_otos},
    {"otosDb", w_otosDb},
    {"otr4", w_otr4},
    {"otr4r4", w_otr4r4},
    {"otr8r4", w_otr8r4},
    {"ots", w_ots},
    {"otsDi4Do", w_otsDi4Do},
    {"otsDo", w_otsDo},
    {"otsDs", w_otsDs},
    {"otsO", w_otsO},
    {"otsVO", w_otsVO},
    {"ots_bi4i4i4i4_r4", w_ots_bi4i4i4i4_r4},
    {"ots_i8i8i8_s_i8i8i8_s_i8i8i8_", w_ots_i8i8i8_s_i8i8i8_s_i8i8i8_},
    {"ots_i8i8i8_s_i8i8i8_s_i8i8i8_s_i8i8i8_", w_ots_i8i8i8_s_i8i8i8_s_i8i8i8_s_i8i8i8_},
    {"ots_r4r4_b", w_ots_r4r4_b},
    {"ots_r4r4_r4", w_ots_r4r4_r4},
    {"ots_r4r4r4_s_r4r4r4_i4", w_ots_r4r4r4_s_r4r4r4_i4},
    {"otsb", w_otsb},
    {"otsc", w_otsc},
    {"otsi4o", w_otsi4o},
    {"otso", w_otso},
    {"otss", w_otss},
    {"otss_i8i8i8_s_i8i8i8_", w_otss_i8i8i8_s_i8i8i8_},
    {"otsso", w_otsso},
    {"otsu4", w_otsu4},
    {"otsu4o", w_otsu4o},
    {"otu4Pi4", w_otu4Pi4},
    {"pPi8Pi8Di4Di4Di4", w_pPi8Pi8Di4Di4Di4},
    {"pPs_i8_", w_pPs_i8_},
    {"pi4i4i4Ps_i8_i4i4i4", w_pi4i4i4Ps_i8_i4i4i4},
    {"pi4pPi8Pi8oo", w_pi4pPi8Pi8oo},
    {"po", w_po},
    {"poi4oi4Pi8Pi8Pi8Pi8", w_poi4oi4Pi8Pi8Pi8Pi8},
    {"poi4oi4Ps_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_", w_poi4oi4Ps_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_},
    {"pp", w_pp},
    {"ppPi8Pi8i4i4i4", w_ppPi8Pi8i4i4i4},
    {"ppPs_i8_Ps_i8_Ps_i8i8i8_", w_ppPs_i8_Ps_i8_Ps_i8i8i8_},
    {"ppi4", w_ppi4},
    {"ppu4Pi8", w_ppu4Pi8},
    {"ppu4oi4oi4i4Pi8i4i4Pi8i4", w_ppu4oi4oi4i4Pi8i4i4Pi8i4},
    {"ps", w_ps},
    {"psi4oi4", w_psi4oi4},
    {"r4", w_r4},
    {"r4i4r4r4Dr4Dr4Do", w_r4i4r4r4Dr4Dr4Do},
    {"r4s", w_r4s},
    {"r4s_r4r4_", w_r4s_r4r4_},
    {"r4s_r4r4_s_r4r4_", w_r4s_r4r4_s_r4r4_},
    {"r4s_r4r4r4_", w_r4s_r4r4r4_},
    {"r4s_r4r4r4_s_r4r4r4_", w_r4s_r4r4r4_s_r4r4r4_},
    {"r4s_r4r4r4_s_r4r4r4_s_r4r4r4_", w_r4s_r4r4r4_s_r4r4r4_s_r4r4r4_},
    {"r4s_r4r4r4r4_", w_r4s_r4r4r4r4_},
    {"r4s_r4r4r4r4_s_r4r4r4r4_", w_r4s_r4r4r4r4_s_r4r4r4r4_},
    {"r4sr4", w_r4sr4},
    {"r4t", w_r4t},
    {"r4ti4", w_r4ti4},
    {"r4tr4", w_r4tr4},
    {"r4ts", w_r4ts},
    {"r4tsr4", w_r4tsr4},
    {"r8", w_r8},
    {"r8pi4", w_r8pi4},
    {"r8t", w_r8t},
    {"r8ti4", w_r8ti4},
    {"s", w_s},
    {"sDb", w_sDb},
    {"sVO", w_sVO},
    {"s_bi4o_t", w_s_bi4o_t},
    {"s_br4r4r4r4_t", w_s_br4r4r4r4_t},
    {"s_i4_t", w_s_i4_t},
    {"s_i4i4i4i4_t", w_s_i4i4i4i4_t},
    {"s_i8_i4", w_s_i8_i4},
    {"s_i8_i8", w_s_i8_i8},
    {"s_i8_r4", w_s_i8_r4},
    {"s_i8i8i8_Di8Di8Di8", w_s_i8i8i8_Di8Di8Di8},
    {"s_i8i8i8_s_i8i8i8_i8", w_s_i8i8i8_s_i8i8i8_i8},
    {"s_i8i8i8_s_i8i8i8_s_i8i8i8_", w_s_i8i8i8_s_i8i8i8_s_i8i8i8_},
    {"s_i8i8i8_t", w_s_i8i8i8_t},
    {"s_i8i8i8_ti4", w_s_i8i8i8_ti4},
    {"s_i8i8i8_ti4Di4Di4", w_s_i8i8i8_ti4Di4Di4},
    {"s_i8i8i8_ti4i4", w_s_i8i8i8_ti4i4},
    {"s_i8i8i8_ti4s_i8i8i8_i8", w_s_i8i8i8_ti4s_i8i8i8_i8},
    {"s_i8i8i8_ti4s_i8i8i8_s_i8i8i8_", w_s_i8i8i8_ti4s_i8i8i8_s_i8i8i8_},
    {"s_i8i8i8_ti8", w_s_i8i8i8_ti8},
    {"s_i8i8i8_ts_i8i8i8_", w_s_i8i8i8_ts_i8i8i8_},
    {"s_i8i8i8_ts_i8i8i8_i8", w_s_i8i8i8_ts_i8i8i8_i8},
    {"s_i8i8i8_tss_i8i8i8_s_i8i8i8_", w_s_i8i8i8_tss_i8i8i8_s_i8i8i8_},
    {"s_i8i8i8_tu4", w_s_i8i8i8_tu4},
    {"s_i8i8i8_tu4s_i8i8i8_", w_s_i8i8i8_tu4s_i8i8i8_},
    {"s_i8i8i8i8_Di8Di8Di8Di8", w_s_i8i8i8i8_Di8Di8Di8Di8},
    {"s_i8i8i8i8_s_i8i8i8_", w_s_i8i8i8i8_s_i8i8i8_},
    {"s_i8i8i8i8_s_i8i8i8i8_s_i8i8i8_", w_s_i8i8i8i8_s_i8i8i8i8_s_i8i8i8_},
    {"s_i8i8i8i8_s_i8i8i8i8_s_i8i8i8i8_", w_s_i8i8i8i8_s_i8i8i8i8_s_i8i8i8i8_},
    {"s_i8i8i8i8_t", w_s_i8i8i8i8_t},
    {"s_i8i8i8i8_ti8i8i8", w_s_i8i8i8i8_ti8i8i8},
    {"s_i8i8i8i8_ts_i8i8i8_i8", w_s_i8i8i8i8_ts_i8i8i8_i8},
    {"s_i8i8i8i8_tu4", w_s_i8i8i8i8_tu4},
    {"s_i8i8i8i8i8i8i8_ti4s_i8i8i8_s_i8i8i8_i8", w_s_i8i8i8i8i8i8i8_ti4s_i8i8i8_s_i8i8i8_i8},
    {"s_o_t", w_s_o_t},
    {"s_oi4i4O_t", w_s_oi4i4O_t},
    {"s_oi4i4i4_t", w_s_oi4i4i4_t},
    {"s_oi4i4i4oi4_t", w_s_oi4i4i4oi4_t},
    {"s_oi4i4o_t", w_s_oi4i4o_t},
    {"s_oi4i4s_t", w_s_oi4i4s_t},
    {"s_oi4i4soi4_t", w_s_oi4i4soi4_t},
    {"s_ooooi4i4_t", w_s_ooooi4i4_t},
    {"s_osi4i4o_t", w_s_osi4i4o_t},
    {"s_osi4i4o_ts", w_s_osi4i4o_ts},
    {"s_r4r4_", w_s_r4r4_},
    {"s_r4r4_r4s_r4r4_", w_s_r4r4_r4s_r4r4_},
    {"s_r4r4_s_r4r4_", w_s_r4r4_s_r4r4_},
    {"s_r4r4_s_r4r4_r4", w_s_r4r4_s_r4r4_r4},
    {"s_r4r4_s_r4r4_s_r4r4_", w_s_r4r4_s_r4r4_s_r4r4_},
    {"s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4", w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4},
    {"s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4", w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4},
    {"s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4r4", w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4r4},
    {"s_r4r4_s_r4r4_s_r4r4_r4", w_s_r4r4_s_r4r4_s_r4r4_r4},
    {"s_r4r4_s_r4r4r4_", w_s_r4r4_s_r4r4r4_},
    {"s_r4r4_s_r4r4r4r4_", w_s_r4r4_s_r4r4r4r4_},
    {"s_r4r4_t", w_s_r4r4_t},
    {"s_r4r4_ti4", w_s_r4r4_ti4},
    {"s_r4r4_tooi4", w_s_r4r4_tooi4},
    {"s_r4r4_ts", w_s_r4r4_ts},
    {"s_r4r4_ts_r4r4_", w_s_r4r4_ts_r4r4_},
    {"s_r4r4_ts_r4r4_b", w_s_r4r4_ts_r4r4_b},
    {"s_r4r4_ts_r4r4_o", w_s_r4r4_ts_r4r4_o},
    {"s_r4r4_ts_r4r4r4_", w_s_r4r4_ts_r4r4r4_},
    {"s_r4r4_ts_r4r4r4_o", w_s_r4r4_ts_r4r4r4_o},
    {"s_r4r4r4_", w_s_r4r4r4_},
    {"s_r4r4r4_r4s_r4r4r4_", w_s_r4r4r4_r4s_r4r4r4_},
    {"s_r4r4r4_s_r4r4_", w_s_r4r4r4_s_r4r4_},
    {"s_r4r4r4_s_r4r4r4_", w_s_r4r4r4_s_r4r4r4_},
    {"s_r4r4r4_s_r4r4r4_r4", w_s_r4r4r4_s_r4r4r4_r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_r4r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4r4},
    {"s_r4r4r4_s_r4r4r4r4_", w_s_r4r4r4_s_r4r4r4r4_},
    {"s_r4r4r4_s_r4r4r4r4_s_r4r4r4_", w_s_r4r4r4_s_r4r4r4r4_s_r4r4r4_},
    {"s_r4r4r4_t", w_s_r4r4r4_t},
    {"s_r4r4r4_ti4", w_s_r4r4r4_ti4},
    {"s_r4r4r4_tr4", w_s_r4r4r4_tr4},
    {"s_r4r4r4_tr4r4r4", w_s_r4r4r4_tr4r4r4},
    {"s_r4r4r4_ts_r4r4r4_", w_s_r4r4r4_ts_r4r4r4_},
    {"s_r4r4r4_ts_r4r4r4_Dr4", w_s_r4r4r4_ts_r4r4r4_Dr4},
    {"s_r4r4r4_ts_r4r4r4_s_r4r4r4_", w_s_r4r4r4_ts_r4r4r4_s_r4r4r4_},
    {"s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_t", w_s_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_t},
    {"s_r4r4r4r4_", w_s_r4r4r4r4_},
    {"s_r4r4r4r4_Ps_r4r4r4r4_Ps_r4r4r4r4_", w_s_r4r4r4r4_Ps_r4r4r4r4_Ps_r4r4r4r4_},
    {"s_r4r4r4r4_i4", w_s_r4r4r4r4_i4},
    {"s_r4r4r4r4_r4r4r4", w_s_r4r4r4r4_r4r4r4},
    {"s_r4r4r4r4_r4r4r4b", w_s_r4r4r4r4_r4r4r4b},
    {"s_r4r4r4r4_r4s_r4r4r4_", w_s_r4r4r4r4_r4s_r4r4r4_},
    {"s_r4r4r4r4_r4s_r4r4r4r4_", w_s_r4r4r4r4_r4s_r4r4r4r4_},
    {"s_r4r4r4r4_s", w_s_r4r4r4r4_s},
    {"s_r4r4r4r4_s_r4r4_", w_s_r4r4r4r4_s_r4r4_},
    {"s_r4r4r4r4_s_r4r4r4_", w_s_r4r4r4r4_s_r4r4r4_},
    {"s_r4r4r4r4_s_r4r4r4_s_r4r4r4_", w_s_r4r4r4r4_s_r4r4r4_s_r4r4r4_},
    {"s_r4r4r4r4_s_r4r4r4r4_", w_s_r4r4r4r4_s_r4r4r4r4_},
    {"s_r4r4r4r4_s_r4r4r4r4_r4", w_s_r4r4r4r4_s_r4r4r4r4_r4},
    {"s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_", w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_},
    {"s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4", w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4},
    {"s_r4r4r4r4_t", w_s_r4r4r4r4_t},
    {"s_r4r4r4r4_to", w_s_r4r4r4r4_to},
    {"s_r4r4r4r4_ts_r4r4r4r4_", w_s_r4r4r4r4_ts_r4r4r4r4_},
    {"s_r4r4r4r4_ts_r4r4r4r4_o", w_s_r4r4r4r4_ts_r4r4r4r4_o},
    {"s_r4r4r4r4_tss_r4r4r4r4_", w_s_r4r4r4r4_tss_r4r4r4r4_},
    {"s_r4r4r4r4_u4", w_s_r4r4r4r4_u4},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t},
    {"spi4", w_spi4},
    {"ss", w_ss},
    {"ssDb", w_ssDb},
    {"sss", w_sss},
    {"st", w_st},
    {"stb", w_stb},
    {"sti4", w_sti4},
    {"sto", w_sto},
    {"sts", w_sts},
    {"stsPs", w_stsPs},
    {"stso", w_stso},
    {"stss", w_stss},
    {"u1t", w_u1t},
    {"u2t", w_u2t},
    {"u4pPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_", w_u4pPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_},
    {"u4pi4", w_u4pi4},
    {"u4pi4Ps_i8i8i8_Ps_i8i8i8_Pi8", w_u4pi4Ps_i8i8i8_Ps_i8i8i8_Pi8},
    {"u4pi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_", w_u4pi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_},
    {"u4t", w_u4t},
    {"u4ti4", w_u4ti4},
    {"u8p", w_u8p},
    {"u8t", w_u8t},
    {"v", w_v},
    {"vO", w_vO},
    {"vOb", w_vOb},
    {"vOi4b", w_vOi4b},
    {"vOo", w_vOo},
    {"vPs_i8i8i8_Pi8Ps_i8i8i8_", w_vPs_i8i8i8_Pi8Ps_i8i8i8_},
    {"vPs_i8i8i8_Ps_i8i8i8_", w_vPs_i8i8i8_Ps_i8i8i8_},
    {"vPs_i8i8i8_Ps_i8i8i8_Pi8Ps_i8i8i8_", w_vPs_i8i8i8_Ps_i8i8i8_Pi8Ps_i8i8i8_},
    {"vPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_", w_vPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_},
    {"vPs_i8i8i8i8_Pi8Pi8Pi8Ps_i8i8i8i8_", w_vPs_i8i8i8i8_Pi8Pi8Pi8Ps_i8i8i8i8_},
    {"vPs_i8i8i8i8_Ps_i8i8i8_", w_vPs_i8i8i8i8_Ps_i8i8i8_},
    {"vPs_i8i8i8i8_Ps_i8i8i8_Pi8Ps_i8i8i8i8_", w_vPs_i8i8i8i8_Ps_i8i8i8_Pi8Ps_i8i8i8i8_},
    {"vPs_i8i8i8i8_Ps_i8i8i8_Ps_i8i8i8_", w_vPs_i8i8i8i8_Ps_i8i8i8_Ps_i8i8i8_},
    {"vPs_i8i8i8i8_Ps_i8i8i8_Ps_i8i8i8i8_", w_vPs_i8i8i8i8_Ps_i8i8i8_Ps_i8i8i8i8_},
    {"vPs_i8i8i8i8_Ps_i8i8i8i8_", w_vPs_i8i8i8i8_Ps_i8i8i8i8_},
    {"vPs_i8i8i8i8_Ps_i8i8i8i8_Ps_i8i8i8i8_", w_vPs_i8i8i8i8_Ps_i8i8i8i8_Ps_i8i8i8i8_},
    {"vPs_r4r4r4_Ps_r4r4r4_", w_vPs_r4r4r4_Ps_r4r4r4_},
    {"vPs_r4r4r4_Ps_r4r4r4_Ps_r4r4r4_", w_vPs_r4r4r4_Ps_r4r4r4_Ps_r4r4r4_},
    {"vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4", w_vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4},
    {"vVO", w_vVO},
    {"vb", w_vb},
    {"vbO", w_vbO},
    {"vbOo", w_vbOo},
    {"vbo", w_vbo},
    {"vbosVO", w_vbosVO},
    {"vbs", w_vbs},
    {"vbsVO", w_vbsVO},
    {"vbso", w_vbso},
    {"vi4", w_vi4},
    {"vi4i4", w_vi4i4},
    {"vi4i4i4", w_vi4i4i4},
    {"vi4i4osVO", w_vi4i4osVO},
    {"vi4o", w_vi4o},
    {"vo", w_vo},
    {"voDs", w_voDs},
    {"voPs_r4r4r4r4_", w_voPs_r4r4r4r4_},
    {"voPs_r4r4r4r4r4r4u4r4r4r4i4_", w_voPs_r4r4r4r4r4r4u4r4r4r4i4_},
    {"vob", w_vob},
    {"voi4", w_voi4},
    {"voi4Db", w_voi4Db},
    {"voo", w_voo},
    {"voor4s_r4r4_", w_voor4s_r4r4_},
    {"vor4", w_vor4},
    {"vosVO", w_vosVO},
    {"vp", w_vp},
    {"vpPs_i8_", w_vpPs_i8_},
    {"vpPs_i8i8i8_Ps_i8i8i8_", w_vpPs_i8i8i8_Ps_i8i8i8_},
    {"vpPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_", w_vpPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_},
    {"vpPs_i8i8i8_ooi4pop", w_vpPs_i8i8i8_ooi4pop},
    {"vpi4", w_vpi4},
    {"vpi4Pi4Pi4Di4Di4", w_vpi4Pi4Pi4Di4Di4},
    {"vpi4Ps_i8i8i8_", w_vpi4Ps_i8i8i8_},
    {"vpi4Ps_i8i8i8_Di4Di4", w_vpi4Ps_i8i8i8_Di4Di4},
    {"vpi4Ps_i8i8i8_Ps_i8i8i8_", w_vpi4Ps_i8i8i8_Ps_i8i8i8_},
    {"vpi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_", w_vpi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_},
    {"vpi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8i8i8i8i8_Pi8", w_vpi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8i8i8i8i8_Pi8},
    {"vpi4i4", w_vpi4i4},
    {"vpi4i4Ps_i8i8i8_", w_vpi4i4Ps_i8i8i8_},
    {"vpi4i4i4", w_vpi4i4i4},
    {"vpi4i4i4i4", w_vpi4i4i4i4},
    {"vpi4i4i4i4i4o", w_vpi4i4i4i4i4o},
    {"vpi4i4i4o", w_vpi4i4i4o},
    {"vpi4o", w_vpi4o},
    {"vpi4po", w_vpi4po},
    {"vpi4ppi8", w_vpi4ppi8},
    {"vpi8", w_vpi8},
    {"vpi8Ps_i8_", w_vpi8Ps_i8_},
    {"vpi8Ps_i8i8i8_", w_vpi8Ps_i8i8i8_},
    {"vpoi4", w_vpoi4},
    {"vpoi4o", w_vpoi4o},
    {"vpoopop", w_vpoopop},
    {"vpop", w_vpop},
    {"vpp", w_vpp},
    {"vppp", w_vppp},
    {"vps", w_vps},
    {"vpu4", w_vpu4},
    {"vpu4Pi8Pi8i4i4Pi8i4Pi8i4", w_vpu4Pi8Pi8i4i4Pi8i4Pi8i4},
    {"vpu4Pi8i4i4Pi8i4Pi8i4", w_vpu4Pi8i4i4Pi8i4Pi8i4},
    {"vpu4Ps_i8i8i8_", w_vpu4Ps_i8i8i8_},
    {"vpu4Ps_i8i8i8_Pi8Pi8", w_vpu4Ps_i8i8i8_Pi8Pi8},
    {"vpu4Ps_i8i8i8_Ps_i8i8i8_", w_vpu4Ps_i8i8i8_Ps_i8i8i8_},
    {"vpu4Ps_i8i8i8_i4", w_vpu4Ps_i8i8i8_i4},
    {"vpu4Ps_i8i8i8_i4Pi8Pi8Pi8", w_vpu4Ps_i8i8i8_i4Pi8Pi8Pi8},
    {"vpu4Ps_i8i8i8_i4Pi8i4", w_vpu4Ps_i8i8i8_i4Pi8i4},
    {"vpu4Ps_i8i8i8_i4i4Pi8i4Pi8i4", w_vpu4Ps_i8i8i8_i4i4Pi8i4Pi8i4},
    {"vpu4Ps_i8i8i8i8_", w_vpu4Ps_i8i8i8i8_},
    {"vpu4i4", w_vpu4i4},
    {"vpu4i4Pi8", w_vpu4i4Pi8},
    {"vpu4i4Pi8Pi8", w_vpu4i4Pi8Pi8},
    {"vpu4i4Pi8Pi8Pi8Pi8i4", w_vpu4i4Pi8Pi8Pi8Pi8i4},
    {"vpu4i4Pi8Pi8i4Pi8", w_vpu4i4Pi8Pi8i4Pi8},
    {"vpu4i4i4", w_vpu4i4i4},
    {"vpu4i4i4i4", w_vpu4i4i4i4},
    {"vpu4i8", w_vpu4i8},
    {"vpu4i8i4i4", w_vpu4i8i4i4},
    {"vpu4u4i4", w_vpu4u4i4},
    {"vpu4u4i8i8i4i4", w_vpu4u4i8i8i4i4},
    {"vr4", w_vr4},
    {"vs", w_vs},
    {"vsDb", w_vsDb},
    {"vsVO", w_vsVO},
    {"vs_i4_", w_vs_i4_},
    {"vs_r4r4r4_s_r4r4r4_", w_vs_r4r4r4_s_r4r4r4_},
    {"vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_", w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_},
    {"vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4", w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4},
    {"vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4b", w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4b},
    {"vs_r4r4r4r4_Pr4Pr4Pr4", w_vs_r4r4r4r4_Pr4Pr4Pr4},
    {"vso", w_vso},
    {"vss", w_vss},
    {"vsso", w_vsso},
    {"vt", w_vt},
    {"vtDb", w_vtDb},
    {"vtDi4", w_vtDi4},
    {"vtDi4Di4", w_vtDi4Di4},
    {"vtDi4Di4Di4", w_vtDi4Di4Di4},
    {"vtDi4Di4Di4Di4", w_vtDi4Di4Di4Di4},
    {"vtDi4Do", w_vtDi4Do},
    {"vtDi8Di8Di8", w_vtDi8Di8Di8},
    {"vtDi8Di8Di8Di8", w_vtDi8Di8Di8Di8},
    {"vtDr4Dr4Dr4", w_vtDr4Dr4Dr4},
    {"vtDr4Dr4Dr4Dr4", w_vtDr4Dr4Dr4Dr4},
    {"vtO", w_vtO},
    {"vtPr4Pr4", w_vtPr4Pr4},
    {"vtPr4Pr4r4r4", w_vtPr4Pr4r4r4},
    {"vtPr4Ps_r4r4r4_", w_vtPr4Ps_r4r4r4_},
    {"vtPs_r4r4r4_Ps_r4r4r4r4_", w_vtPs_r4r4r4_Ps_r4r4r4r4_},
    {"vtPs_r4r4r4r4r4r4u4r4r4r4i4_b", w_vtPs_r4r4r4r4r4r4u4r4r4r4i4_b},
    {"vtPs_r4r4r4r4r4r4u4r4r4r4i4_bb", w_vtPs_r4r4r4r4r4r4u4r4r4r4i4_bb},
    {"vtVO", w_vtVO},
    {"vtVr4", w_vtVr4},
    {"vtb", w_vtb},
    {"vtbDb", w_vtbDb},
    {"vtbDs", w_vtbDs},
    {"vtbb", w_vtbb},
    {"vtbi4", w_vtbi4},
    {"vtbi4r4", w_vtbi4r4},
    {"vtbs", w_vtbs},
    {"vtco", w_vtco},
    {"vti4", w_vti4},
    {"vti4Di4Dr4", w_vti4Di4Dr4},
    {"vti4Do", w_vti4Do},
    {"vti4Dr4", w_vti4Dr4},
    {"vti4O", w_vti4O},
    {"vti4Pi4Pi4Di4Di4", w_vti4Pi4Pi4Di4Di4},
    {"vti4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_", w_vti4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4_},
    {"vti4b", w_vti4b},
    {"vti4bDi4", w_vti4bDi4},
    {"vti4bb", w_vti4bb},
    {"vti4i4", w_vti4i4},
    {"vti4i4Db", w_vti4i4Db},
    {"vti4i4Ds", w_vti4i4Ds},
    {"vti4i4b", w_vti4i4b},
    {"vti4i4i4", w_vti4i4i4},
    {"vti4i4i4i4", w_vti4i4i4i4},
    {"vti4i4i4i8", w_vti4i4i4i8},
    {"vti4i4o", w_vti4i4o},
    {"vti4i4s_i8i8i8_", w_vti4i4s_i8i8i8_},
    {"vti4o", w_vti4o},
    {"vti4obb", w_vti4obb},
    {"vti4oi4i4", w_vti4oi4i4},
    {"vti4r4", w_vti4r4},
    {"vti4r4i4r4", w_vti4r4i4r4},
    {"vti4r4i4r4bo", w_vti4r4i4r4bo},
    {"vti4r4o", w_vti4r4o},
    {"vti4r4r4oDoDr4", w_vti4r4r4oDoDr4},
    {"vti4r4r4r4o", w_vti4r4r4r4o},
    {"vti4r4r4ssss", w_vti4r4r4ssss},
    {"vti4r4s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4o", w_vti4r4s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4o},
    {"vti4s", w_vti4s},
    {"vti4s_bi4i4i4i4_", w_vti4s_bi4i4i4i4_},
    {"vti4s_bi4i4i4i4_r4", w_vti4s_bi4i4i4i4_r4},
    {"vti4soo", w_vti4soo},
    {"vti8", w_vti8},
    {"vti8i8Di4Di4Di4", w_vti8i8Di4Di4Di4},
    {"vti8i8i8", w_vti8i8i8},
    {"vti8i8i8i4", w_vti8i8i8i4},
    {"vti8s", w_vti8s},
    {"vto", w_vto},
    {"vtoDb", w_vtoDb},
    {"vtoDi4", w_vtoDi4},
    {"vtoDi4Di4", w_vtoDi4Di4},
    {"vtoDr4", w_vtoDr4},
    {"vtoO", w_vtoO},
    {"vtoOi4", w_vtoOi4},
    {"vtob", w_vtob},
    {"vtobDbDb", w_vtobDbDb},
    {"vtobb", w_vtobb},
    {"vtobi4i4", w_vtobi4i4},
    {"vtoi4", w_vtoi4},
    {"vtoi4b", w_vtoi4b},
    {"vtoi4i4", w_vtoi4i4},
    {"vtoi4i4r4r4", w_vtoi4i4r4r4},
    {"vtoi4o", w_vtoi4o},
    {"vtoo", w_vtoo},
    {"vtooi4", w_vtooi4},
    {"vtooi4b", w_vtooi4b},
    {"vtoor4r4", w_vtoor4r4},
    {"vtor4", w_vtor4},
    {"vtor4b", w_vtor4b},
    {"vtos", w_vtos},
    {"vtosODi4", w_vtosODi4},
    {"vtos_Oi4_", w_vtos_Oi4_},
    {"vtos_r4r4r4_", w_vtos_r4r4r4_},
    {"vtos_r4r4r4r4_", w_vtos_r4r4r4r4_},
    {"vtos_r4r4r4r4_b", w_vtos_r4r4r4r4_b},
    {"vtos_r4r4r4r4_bs_r4r4_s_r4r4_", w_vtos_r4r4r4r4_bs_r4r4_s_r4r4_},
    {"vtos_r4r4r4r4_r4s_r4r4r4r4_", w_vtos_r4r4r4r4_r4s_r4r4r4r4_},
    {"vtoso", w_vtoso},
    {"vtoss", w_vtoss},
    {"vtp", w_vtp},
    {"vtpDb", w_vtpDb},
    {"vtr4", w_vtr4},
    {"vtr4b", w_vtr4b},
    {"vtr4bb", w_vtr4bb},
    {"vtr4bbb", w_vtr4bbb},
    {"vtr4i4", w_vtr4i4},
    {"vtr4i4o", w_vtr4i4o},
    {"vtr4i4oO", w_vtr4i4oO},
    {"vtr4o", w_vtr4o},
    {"vtr4r4", w_vtr4r4},
    {"vtr4r4b", w_vtr4r4b},
    {"vtr4r4i4s_r4r4r4r4_s_r4r4r4r4_", w_vtr4r4i4s_r4r4r4r4_s_r4r4r4r4_},
    {"vtr4r4os_r4r4r4r4_", w_vtr4r4os_r4r4r4r4_},
    {"vtr4r4os_r4r4r4r4_r4s_r4r4r4r4_", w_vtr4r4os_r4r4r4r4_r4s_r4r4r4r4_},
    {"vtr4r4r4", w_vtr4r4r4},
    {"vtr4r4r4Di4Di4", w_vtr4r4r4Di4Di4},
    {"vtr4r4r4i4", w_vtr4r4r4i4},
    {"vtr4r4r4o", w_vtr4r4r4o},
    {"vtr4r4r4r4", w_vtr4r4r4r4},
    {"vtr4r4r4r4b", w_vtr4r4r4r4b},
    {"vtr4r4r4r4r4", w_vtr4r4r4r4r4},
    {"vtr4r4s", w_vtr4r4s},
    {"vtr4r4s_r4r4r4r4_", w_vtr4r4s_r4r4r4r4_},
    {"vtr4r4s_r4r4r4r4_o", w_vtr4r4s_r4r4r4r4_o},
    {"vtr4s_r4r4r4r4_b", w_vtr4s_r4r4r4r4_b},
    {"vtr4s_r4r4r4r4_s_r4r4r4r4_", w_vtr4s_r4r4r4r4_s_r4r4r4r4_},
    {"vtr4s_r4r4r4r4_s_r4r4r4r4_r4r4r4r4", w_vtr4s_r4r4r4r4_s_r4r4r4r4_r4r4r4r4},
    {"vtr4s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4r4", w_vtr4s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4r4},
    {"vtr8", w_vtr8},
    {"vts", w_vts},
    {"vtsDoDoDsDsDs", w_vtsDoDoDsDsDs},
    {"vtsDr4Di4", w_vtsDr4Di4},
    {"vtsDsDs", w_vtsDsDs},
    {"vtsO", w_vtsO},
    {"vtsOi4", w_vtsOi4},
    {"vtsPs", w_vtsPs},
    {"vtsVO", w_vtsVO},
    {"vtsVo", w_vtsVo},
    {"vts_Pvi4i4i4pi4i4oi4_", w_vts_Pvi4i4i4pi4i4oi4_},
    {"vts_Pvi4i4i4pi4i4oi4_i4", w_vts_Pvi4i4i4pi4i4oi4_i4},
    {"vts_Pvi4i4i4pi4i4oi4_i4i4", w_vts_Pvi4i4i4pi4i4oi4_i4i4},
    {"vts_br4r4r4r4_", w_vts_br4r4r4r4_},
    {"vts_i4i4i4i4_", w_vts_i4i4i4i4_},
    {"vts_i8_s_i8_s_i8_", w_vts_i8_s_i8_s_i8_},
    {"vts_i8_s_i8_s_i8_s_i8_", w_vts_i8_s_i8_s_i8_s_i8_},
    {"vts_i8i8i8_", w_vts_i8i8i8_},
    {"vts_i8i8i8_i4", w_vts_i8i8i8_i4},
    {"vts_i8i8i8i8_", w_vts_i8i8i8i8_},
    {"vts_ooooi4i4_", w_vts_ooooi4i4_},
    {"vts_r4r4_", w_vts_r4r4_},
    {"vts_r4r4_b", w_vts_r4r4_b},
    {"vts_r4r4_bb", w_vts_r4r4_bb},
    {"vts_r4r4_s_r4r4_", w_vts_r4r4_s_r4r4_},
    {"vts_r4r4r4_", w_vts_r4r4r4_},
    {"vts_r4r4r4_Db", w_vts_r4r4r4_Db},
    {"vts_r4r4r4_i4", w_vts_r4r4r4_i4},
    {"vts_r4r4r4_o", w_vts_r4r4r4_o},
    {"vts_r4r4r4_r4", w_vts_r4r4r4_r4},
    {"vts_r4r4r4_r4i4", w_vts_r4r4r4_r4i4},
    {"vts_r4r4r4_s_i4u1u1u1u1_", w_vts_r4r4r4_s_i4u1u1u1u1_},
    {"vts_r4r4r4_s_i4u1u1u1u1_s_r4r4_", w_vts_r4r4r4_s_i4u1u1u1u1_s_r4r4_},
    {"vts_r4r4r4_s_r4r4r4_", w_vts_r4r4r4_s_r4r4r4_},
    {"vts_r4r4r4_s_r4r4r4_r4", w_vts_r4r4r4_s_r4r4r4_r4},
    {"vts_r4r4r4_s_r4r4r4_s_r4r4r4_", w_vts_r4r4r4_s_r4r4r4_s_r4r4r4_},
    {"vts_r4r4r4_s_r4r4r4r4_", w_vts_r4r4r4_s_r4r4r4r4_},
    {"vts_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_", w_vts_r4r4r4i4r4r4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4r4r4r4r4r4i4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4u4r4u4u4u4u4r4r4_},
    {"vts_r4r4r4r4_", w_vts_r4r4r4r4_},
    {"vts_r4r4r4r4_Dr4", w_vts_r4r4r4r4_Dr4},
    {"vts_r4r4r4r4_bb", w_vts_r4r4r4r4_bb},
    {"vts_r4r4r4r4_r4", w_vts_r4r4r4r4_r4},
    {"vts_r4r4r4r4_s_i4u1u1u1u1_", w_vts_r4r4r4r4_s_i4u1u1u1u1_},
    {"vts_r4r4r4r4_s_i4u1u1u1u1_s_r4r4r4r4_", w_vts_r4r4r4r4_s_i4u1u1u1u1_s_r4r4r4r4_},
    {"vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_", w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_},
    {"vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_", w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_},
    {"vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_", w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_},
    {"vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_i4", w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u1u1u1u1u4u4r4r4i4r4r4u4bbbbbbbbbbb_i4},
    {"vtsb", w_vtsb},
    {"vtsbbbbsi4b", w_vtsbbbbsi4b},
    {"vtsbsDi4", w_vtsbsDi4},
    {"vtsi4", w_vtsi4},
    {"vtsi4i4", w_vtsi4i4},
    {"vtsi8i8", w_vtsi8i8},
    {"vtso", w_vtso},
    {"vtsoDb", w_vtsoDb},
    {"vtsoDs", w_vtsoDs},
    {"vtsob", w_vtsob},
    {"vtsooDsDs", w_vtsooDsDs},
    {"vtsooi4", w_vtsooi4},
    {"vtsooo", w_vtsooo},
    {"vtsooooooi4o", w_vtsooooooi4o},
    {"vtsos_r4r4_", w_vtsos_r4r4_},
    {"vtsr4", w_vtsr4},
    {"vtsr4r4", w_vtsr4r4},
    {"vtss", w_vtss},
    {"vtsss", w_vtsss},
    {"vtsu4i4i8bbi8b", w_vtsu4i4i8bbi8b},
    {"vtu2oDi4Di4", w_vtu2oDi4Di4},
    {"vtu2ob", w_vtu2ob},
    {"vtu4", w_vtu4},
    {"vtu4b", w_vtu4b},
    {"vtu4bbb", w_vtu4bbb},
    {"vtu4i4", w_vtu4i4},
    {"vtu4i4b", w_vtu4i4b},
    {"vtu4i4i4i4", w_vtu4i4i4i4},
    {"vtu4i4i8i8", w_vtu4i4i8i8},
    {"vtu4i4i8i8i4i8", w_vtu4i4i8i8i4i8},
    {"vtu4i4i8i8i8i8Di4", w_vtu4i4i8i8i8i8Di4},
    {"vtu4i8", w_vtu4i8},
    {"vtu4i8bb", w_vtu4i8bb},
    {"vtu4i8bbi8i4i8b", w_vtu4i8bbi8i4i8b},
    {"vtu4i8i8bbi8i4i8b", w_vtu4i8i8bbi8i4i8b},
    {"vtu4i8i8i8", w_vtu4i8i8i8},
    {"vtu4i8i8i8Db", w_vtu4i8i8i8Db},
    {"vtu4i8i8i8i8", w_vtu4i8i8i8i8},
    {"vtu4i8i8i8i8bb", w_vtu4i8i8i8i8bb},
    {"vtu4i8i8i8i8bi8i8", w_vtu4i8i8i8i8bi8i8},
    {"vtu4s_i8i8i8_", w_vtu4s_i8i8i8_},
    {"vtu4s_i8i8i8_bbi8i4i8b", w_vtu4s_i8i8i8_bbi8i4i8b},
    {"vtu4s_i8i8i8_i8i8", w_vtu4s_i8i8i8_i8i8},
    {"vtu4s_i8i8i8_s_i8i8i8_", w_vtu4s_i8i8i8_s_i8i8i8_},
    {"vtu4s_r4r4r4r4_s_br4r4r4r4_", w_vtu4s_r4r4r4r4_s_br4r4r4r4_},
    {"vtu4u4b", w_vtu4u4b},
    {"vtu4u4i4", w_vtu4u4i4},
    {"vtu4u4i8i8i4i4", w_vtu4u4i8i8i4i4},
    {nullptr, nullptr}
};


static void* b_O(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_O");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_OO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_OO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_OVO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_OVO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    auto arrayLength = GetArrayLength(p0);
    v8::Local<v8::Value> *Argv = (v8::Local<v8::Value> *)alloca(sizeof(v8::Local<v8::Value>) * (0 + arrayLength));
    memset(Argv, 0, sizeof(v8::Local<v8::Value>) * (0 + arrayLength));
    
    RestArguments<void*>::UnPackRefOrBoxedValueType(context, p0, arrayLength, TIp0, Argv + 0);
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1 + arrayLength - 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oi4popb(void* target, int32_t p0, void* p1, void* p2, void* p3, bool p4, void* method) {
    // PLog(LogLevel::Log, "Running b_Oi4popb");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate),
        converter::Converter<bool>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oo(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_Oo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Ooo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_Ooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oooo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_Oooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oppi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_Oppi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Os_oooObr4r4r4r4bb_(void* target, struct s_oooObr4r4r4r4bb_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_Os_oooObr4r4r4r4bb_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oso(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_Oso");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_OssoPi4(void* target, void* p0, void* p1, void* p2, int32_t* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_OssoPi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static bool b_b(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_b");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bO");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bOooi4(void* target, void* p0, void* p1, void* p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bOooi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bPs(void* target, void** p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bPs");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_(void* target, struct s_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bb(void* target, bool p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bb");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<bool>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bi4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bi4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bi4i4i4po(void* target, int32_t p0, int32_t p1, int32_t p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_bi4i4i4po");

    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bo(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bo");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_boO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boPi4(void* target, void* p0, int32_t* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_boPi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boPsPs(void* target, void* p0, void** p1, void** p2, void* method) {
    // PLog(LogLevel::Log, "Running b_boPsPs");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        v8::Undefined(isolate),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_boi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boi4O(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_boi4O");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_boo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_booi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_booi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boooi4(void* target, void* p0, void* p1, void* p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_boooi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_booso(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_booso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boso(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_boso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bososo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_bososo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSAnyToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bosso(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bosso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bosss(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bosss");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2),
        CSAnyToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bossss(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_bossss");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2),
        CSAnyToJsValue(isolate, context, p3),
        CSAnyToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bp(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bp");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bs");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bsO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_bsO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_i4ss_(void* target, struct s_i4ss_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_i4ss_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_r4r4_Ps_r4r4r4_Ps_r4r4r4_(void* target, struct s_r4r4_ p0, struct s_r4r4r4_* p1, struct s_r4r4r4_* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_r4r4_Ps_r4r4r4_Ps_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        v8::Undefined(isolate),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_sOO_(void* target, struct s_sOO_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_sOO_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_u8_(void* target, struct s_u8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_u8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_u8u8u4u4u4u4i4oo_oo(void* target, struct s_u8u8u4u4u4u4i4oo_ p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_u8u8u4u4u4u4i4oo_oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bsbi4s(void* target, void* p0, bool p1, int32_t p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bsbi4s");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2),
        CSAnyToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bso(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_bso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bsooi4(void* target, void* p0, void* p1, void* p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bsooi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bu1o(void* target, uint8_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_bu1o");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<uint8_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static Il2CppChar b_csi4c(void* target, void* p0, int32_t p1, Il2CppChar p2, void* method) {
    // PLog(LogLevel::Log, "Running b_csi4c");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<Il2CppChar>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    Il2CppChar ret = converter::Converter<Il2CppChar>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int16_t b_i2os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i2os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int16_t ret = converter::Converter<int16_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4i4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_i4i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4i4i4ob(void* target, int32_t p0, int32_t p1, void* p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_i4i4i4ob");

    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4i4sb(void* target, int32_t p0, void* p1, bool p2, void* method) {
    // PLog(LogLevel::Log, "Running b_i4i4sb");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<bool>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_i4o");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4ob(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i4ob");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4oi4o(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_i4oi4o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4oo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i4oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4ooo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_i4ooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4oooo(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_i4oooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i4os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4os_r4r4r4_s_r4r4_ob(void* target, void* p0, struct s_r4r4r4_ p1, struct s_r4r4_ p2, void* p3, bool p4, void* method) {
    // PLog(LogLevel::Log, "Running b_i4os_r4r4r4_s_r4r4_ob");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        CSRefToJsValue(isolate, context, p3),
        converter::Converter<bool>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4s_oooObr4r4r4r4bboooObr4r4r4r4bbb_(void* target, struct s_oooObr4r4r4r4bboooObr4r4r4r4bbb_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_i4s_oooObr4r4r4r4bboooObr4r4r4r4bbb_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4ss(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i4ss");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int64_t b_i8o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_i8o");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int64_t ret = converter::Converter<int64_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int64_t b_i8os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i8os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int64_t ret = converter::Converter<int64_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static void* b_o(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_o");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_oO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oOo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oOo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oOs(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oOs");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oOsooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_oOsooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_(void* target, struct s_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_oPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ob(void* target, bool p0, void* method) {
    // PLog(LogLevel::Log, "Running b_ob");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<bool>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_oi4");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi4oo(void* target, int32_t p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oi4oo");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi4popb(void* target, int32_t p0, void* p1, void* p2, void* p3, bool p4, void* method) {
    // PLog(LogLevel::Log, "Running b_oi4popb");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate),
        converter::Converter<bool>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi4s(void* target, int32_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oi4s");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi8oo(void* target, int64_t p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oi8oo");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<int64_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oo(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_oo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_ooO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_ooi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooi4i4(void* target, void* p0, int32_t p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_ooi4i4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooi4s_r4r4_ooPi4(void* target, void* p0, int32_t p1, struct s_r4r4_ p2, void* p3, void* p4, int32_t* p5, void* method) {
    // PLog(LogLevel::Log, "Running b_ooi4s_r4r4_ooPi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[6]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 6, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_ooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooO(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oooO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oooi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooi8o(void* target, void* p0, void* p1, int64_t p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_oooi8o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int64_t>::toScript(context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooO(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSAnyToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooO(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSAnyToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[6]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 6, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[7]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 7, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[8]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 8, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[9]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 9, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[10]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 10, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[11]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 11, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[12]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 12, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[13]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 13, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[14]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 14, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* p14, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);
    auto TIp14 = GetParameterType(method, 14);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[15]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13),
        CSRefToJsValue(isolate, context, p14)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 15, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* p14, void* p15, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);
    auto TIp14 = GetParameterType(method, 14);
    auto TIp15 = GetParameterType(method, 15);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[16]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13),
        CSRefToJsValue(isolate, context, p14),
        CSRefToJsValue(isolate, context, p15)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 16, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooor4(void* target, void* p0, void* p1, float p2, void* method) {
    // PLog(LogLevel::Log, "Running b_ooor4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<float>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooos_r4r4_i4(void* target, void* p0, void* p1, struct s_r4r4_ p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_ooos_r4r4_i4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oos(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oos");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oos_r4r4_(void* target, void* p0, struct s_r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oos_r4r4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oosb(void* target, void* p0, void* p1, bool p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oosb");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<bool>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooso(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_ooso");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oosu8(void* target, void* p0, void* p1, uint64_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oosu8");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<uint64_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oou4u4(void* target, void* p0, uint32_t p1, uint32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oou4u4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<uint32_t>::toScript(context, p1),
        converter::Converter<uint32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_os(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_os");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_os_i4i4_(void* target, struct s_i4i4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_os_i4i4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_os_r4r4r4r4_o(void* target, struct s_r4r4r4r4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_os_r4r4r4r4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_osi4o(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_osi4o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_osooo(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_osooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oss(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oss");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_osso(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_osso");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_pp(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_pp");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    void* ret = DataTransfer::GetPointer<void>(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static void* b_pppi4i8(void* target, void* p0, void* p1, int32_t p2, int64_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_pppi4i8");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p2),
        converter::Converter<int64_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    void* ret = DataTransfer::GetPointer<void>(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_r4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4i4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r4i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r4o");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4oos_r4r4r4_(void* target, void* p0, void* p1, struct s_r4r4r4_ p2, void* method) {
    // PLog(LogLevel::Log, "Running b_r4oos_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_r4os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4r4(void* target, float p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r4r4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<float>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4r4Ps_r4r4r4r4_(void* target, float p0, struct s_r4r4r4r4_* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_r4r4Ps_r4r4r4r4_");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<float>::toScript(context, p0),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4s_r4r4r4_(void* target, struct s_r4r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r4s_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static double b_r8(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_r8");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    double ret = converter::Converter<double>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static double b_r8o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r8o");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    double ret = converter::Converter<double>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static double b_r8os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_r8os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    double ret = converter::Converter<double>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static void* b_s(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_s");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_sO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_sO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static struct s__ b_s__(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_s__");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s__* pret = DataTransfer::GetPointer<s__>(context, MaybeRet.ToLocalChecked());
    s__ ret = pret ? *pret : s__ {};
    return ret;
        
}

static struct s_bi4_ b_s_bi4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_bi4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_bi4_* pret = DataTransfer::GetPointer<s_bi4_>(context, MaybeRet.ToLocalChecked());
    s_bi4_ ret = pret ? *pret : s_bi4_ {};
    return ret;
        
}

static struct s_bi4i4i4i4u8_ b_s_bi4i4i4i4u8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_bi4i4i4i4u8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_bi4i4i4i4u8_* pret = DataTransfer::GetPointer<s_bi4i4i4i4u8_>(context, MaybeRet.ToLocalChecked());
    s_bi4i4i4i4u8_ ret = pret ? *pret : s_bi4i4i4i4u8_ {};
    return ret;
        
}

static struct s_bi8_ b_s_bi8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_bi8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_bi8_* pret = DataTransfer::GetPointer<s_bi8_>(context, MaybeRet.ToLocalChecked());
    s_bi8_ ret = pret ? *pret : s_bi8_ {};
    return ret;
        
}

static struct s_bo_ b_s_bo_s(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_bo_s");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_bo_* pret = DataTransfer::GetPointer<s_bo_>(context, MaybeRet.ToLocalChecked());
    s_bo_ ret = pret ? *pret : s_bo_ {};
    return ret;
        
}

static struct s_br4_ b_s_br4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_br4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_br4_* pret = DataTransfer::GetPointer<s_br4_>(context, MaybeRet.ToLocalChecked());
    s_br4_ ret = pret ? *pret : s_br4_ {};
    return ret;
        
}

static struct s_br8_ b_s_br8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_br8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_br8_* pret = DataTransfer::GetPointer<s_br8_>(context, MaybeRet.ToLocalChecked());
    s_br8_ ret = pret ? *pret : s_br8_ {};
    return ret;
        
}

static struct s_i4i4_ b_s_i4i4_s_i4i4_(void* target, struct s_i4i4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_i4i4_s_i4i4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_i4i4_* pret = DataTransfer::GetPointer<s_i4i4_>(context, MaybeRet.ToLocalChecked());
    s_i4i4_ ret = pret ? *pret : s_i4i4_ {};
    return ret;
        
}

static struct s_i4i4i4i4u8_ b_s_i4i4i4i4u8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_i4i4i4i4u8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_i4i4i4i4u8_* pret = DataTransfer::GetPointer<s_i4i4i4i4u8_>(context, MaybeRet.ToLocalChecked());
    s_i4i4i4i4u8_ ret = pret ? *pret : s_i4i4i4i4u8_ {};
    return ret;
        
}

static struct s_ooor4r4_ b_s_ooor4r4_s_ooor4r4_(void* target, struct s_ooor4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_ooor4r4_s_ooor4r4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_ooor4r4_* pret = DataTransfer::GetPointer<s_ooor4r4_>(context, MaybeRet.ToLocalChecked());
    s_ooor4r4_ ret = pret ? *pret : s_ooor4r4_ {};
    return ret;
        
}

static struct s_ossi4i4i4i4o_ b_s_ossi4i4i4i4o_s_ossi4i4i4i4o_(void* target, struct s_ossi4i4i4i4o_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_ossi4i4i4i4o_s_ossi4i4i4i4o_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_ossi4i4i4i4o_* pret = DataTransfer::GetPointer<s_ossi4i4i4i4o_>(context, MaybeRet.ToLocalChecked());
    s_ossi4i4i4i4o_ ret = pret ? *pret : s_ossi4i4i4i4o_ {};
    return ret;
        
}

static struct s_pi4_ b_s_pi4_os_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* target, void* p0, struct s_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_s_pi4_os_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_pi4_* pret = DataTransfer::GetPointer<s_pi4_>(context, MaybeRet.ToLocalChecked());
    s_pi4_ ret = pret ? *pret : s_pi4_ {};
    return ret;
        
}

static struct s_r4r4_ b_s_r4r4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4_* pret = DataTransfer::GetPointer<s_r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4_ ret = pret ? *pret : s_r4r4_ {};
    return ret;
        
}

static struct s_r4r4_ b_s_r4r4_s_r4r4_(void* target, struct s_r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4_s_r4r4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4_* pret = DataTransfer::GetPointer<s_r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4_ ret = pret ? *pret : s_r4r4_ {};
    return ret;
        
}

static struct s_r4r4r4_ b_s_r4r4r4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4r4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pret = DataTransfer::GetPointer<s_r4r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4r4_ ret = pret ? *pret : s_r4r4r4_ {};
    return ret;
        
}

static struct s_r4r4r4r4_ b_s_r4r4r4r4_(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4r4r4_");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pret = DataTransfer::GetPointer<s_r4r4r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4r4r4_ ret = pret ? *pret : s_r4r4r4r4_ {};
    return ret;
        
}

static struct s_r4r4r4r4_ b_s_r4r4r4r4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4r4r4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pret = DataTransfer::GetPointer<s_r4r4r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4r4r4_ ret = pret ? *pret : s_r4r4r4r4_ {};
    return ret;
        
}

static struct s_r4r4r4r4r4r4_ b_s_r4r4r4r4r4r4_(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4r4r4r4r4_");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pret = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4r4r4r4r4_ ret = pret ? *pret : s_r4r4r4r4r4r4_ {};
    return ret;
        
}

static struct s_u8_ b_s_u8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_u8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_u8_* pret = DataTransfer::GetPointer<s_u8_>(context, MaybeRet.ToLocalChecked());
    s_u8_ ret = pret ? *pret : s_u8_ {};
    return ret;
        
}

static void* b_si4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_si4");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_so(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_so");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_sob(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_sob");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_soo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_soo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_sos(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_sos");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_ss(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_ss");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_ss_oi4osi4u1u1u1u1_(void* target, struct s_oi4osi4u1u1u1u1_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_ss_oi4osi4u1u1u1u1_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_ssbs(void* target, void* p0, bool p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_ssbs");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_sso(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_sso");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static uint16_t b_u2os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_u2os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    uint16_t ret = converter::Converter<uint16_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static uint32_t b_u4os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_u4os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    uint32_t ret = converter::Converter<uint32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static uint32_t b_u4u4pu4(void* target, uint32_t p0, void* p1, uint32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_u4u4pu4");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<uint32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        converter::Converter<uint32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    uint32_t ret = converter::Converter<uint32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static uint64_t b_u8os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_u8os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    uint64_t ret = converter::Converter<uint64_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static void b_v(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_v");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vO");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vODo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vODo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vOO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOb(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vOb");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vOo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOoi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vOoi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOsO(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vOsO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOs_Oi4_(void* target, void* p0, struct s_Oi4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vOs_Oi4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOs_Oi4_o(void* target, void* p0, struct s_Oi4_ p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vOs_Oi4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vPs_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_(void* target, struct s_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vPs_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vb(void* target, bool p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vb");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<bool>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vbbi4(void* target, bool p0, bool p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vbbi4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<bool>::toScript(context, p0),
        converter::Converter<bool>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vbs(void* target, bool p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vbs");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<bool>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vbso(void* target, bool p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vbso");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<bool>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4O(void* target, int32_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4O");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4b(void* target, int32_t p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4b");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4i4(void* target, int32_t p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4i4i4p(void* target, int32_t p0, int32_t p1, int32_t p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4i4i4p");

    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4i8i8b(void* target, int32_t p0, int64_t p1, int64_t p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4i8i8b");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int64_t>::toScript(context, p1),
        converter::Converter<int64_t>::toScript(context, p2),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4o(void* target, int32_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4o");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4oi4i4(void* target, int32_t p0, void* p1, int32_t p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4oi4i4");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4ooo(void* target, int32_t p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4ooo");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4popO(void* target, int32_t p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4popO");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate),
        CSAnyToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4popo(void* target, int32_t p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4popo");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4s(void* target, int32_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4s");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4s_r4r4r4_s_r4r4r4r4_r4i4(void* target, int32_t p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, float p3, int32_t p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4s_r4r4r4_s_r4r4r4r4_r4i4");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        converter::Converter<float>::toScript(context, p3),
        converter::Converter<int32_t>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4s_r4r4r4r4_(void* target, int32_t p0, struct s_r4r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4s_r4r4r4r4_");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4u4u4(void* target, int32_t p0, uint32_t p1, uint32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4u4u4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<uint32_t>::toScript(context, p1),
        converter::Converter<uint32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi8(void* target, int64_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vi8");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int64_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi8i4(void* target, int64_t p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi8i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int64_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi8i8(void* target, int64_t p0, int64_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi8i8");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int64_t>::toScript(context, p0),
        converter::Converter<int64_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi8o(void* target, int64_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi8o");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int64_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vo(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vo");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_voO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voPs_Ps_i4i4i4_Ps_i4i4i4_oPs_i4i4i4_PPs_i4i4i4__b(void* target, void* p0, struct s_Ps_i4i4i4_Ps_i4i4i4_oPs_i4i4i4_PPs_i4i4i4__* p1, bool p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voPs_Ps_i4i4i4_Ps_i4i4i4_oPs_i4i4i4_PPs_i4i4i4__b");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        v8::Undefined(isolate),
        converter::Converter<bool>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vob(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vob");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4i4(void* target, void* p0, int32_t p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4o(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4oo(void* target, void* p0, int32_t p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4s_r4r4_(void* target, void* p0, int32_t p1, struct s_r4r4_ p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4s_r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi8(void* target, void* p0, int64_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_voi8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int64_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi8i8i8i8i8i8i8(void* target, void* p0, int64_t p1, int64_t p2, int64_t p3, int64_t p4, int64_t p5, int64_t p6, int64_t p7, void* method) {
    // PLog(LogLevel::Log, "Running b_voi8i8i8i8i8i8i8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[8]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int64_t>::toScript(context, p1),
        converter::Converter<int64_t>::toScript(context, p2),
        converter::Converter<int64_t>::toScript(context, p3),
        converter::Converter<int64_t>::toScript(context, p4),
        converter::Converter<int64_t>::toScript(context, p5),
        converter::Converter<int64_t>::toScript(context, p6),
        converter::Converter<int64_t>::toScript(context, p7)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 8, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_voo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vooi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooi8(void* target, void* p0, void* p1, int64_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vooi8");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int64_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooo(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_voooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[6]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 6, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[7]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 7, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[8]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 8, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[9]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 9, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[10]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 10, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[11]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 11, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[12]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 12, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[13]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 13, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[14]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 14, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* p14, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);
    auto TIp14 = GetParameterType(method, 14);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[15]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13),
        CSRefToJsValue(isolate, context, p14)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 15, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* p14, void* p15, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);
    auto TIp14 = GetParameterType(method, 14);
    auto TIp15 = GetParameterType(method, 15);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[16]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13),
        CSRefToJsValue(isolate, context, p14),
        CSRefToJsValue(isolate, context, p15)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 16, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voos(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voos");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vor4(void* target, void* p0, float p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vor4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<float>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vor8(void* target, void* p0, double p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vor8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<double>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_Pvi4i4i4pi4i4oi4_(void* target, void* p0, struct s_Pvi4i4i4pi4i4oi4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_Pvi4i4i4pi4i4oi4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_i4_(void* target, void* p0, struct s_i4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_i4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_i4_ob(void* target, void* p0, struct s_i4_ p1, void* p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_i4_ob");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_i4i4i4i4_b(void* target, void* p0, struct s_i4i4i4i4_ p1, bool p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_i4i4i4i4_b");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        converter::Converter<bool>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_oi4osi4u1u1u1u1_(void* target, void* p0, struct s_oi4osi4u1u1u1u1_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_oi4osi4u1u1u1u1_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_r4r4_(void* target, void* p0, struct s_r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_r4r4_r4(void* target, void* p0, struct s_r4r4_ p1, float p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_r4r4_r4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        converter::Converter<float>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_r4r4r4_(void* target, void* p0, struct s_r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_r4r4r4r4_(void* target, void* p0, struct s_r4r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_r4r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_sosi4i4i4i4i4_i4(void* target, void* p0, struct s_sosi4i4i4i4i4_ p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_sosi4i4i4i4i4_i4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vosb(void* target, void* p0, void* p1, bool p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vosb");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<bool>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vosbsr4oo(void* target, void* p0, void* p1, bool p2, void* p3, float p4, void* p5, void* p6, void* method) {
    // PLog(LogLevel::Log, "Running b_vosbsr4oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[7]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<bool>::toScript(context, p2),
        CSAnyToJsValue(isolate, context, p3),
        converter::Converter<float>::toScript(context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 7, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voso(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voss_i4i4i4i4_b(void* target, void* p0, void* p1, struct s_i4i4i4i4_ p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_voss_i4i4i4i4_b");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vou1s(void* target, void* p0, uint8_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vou1s");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<uint8_t>::toScript(context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vou4(void* target, void* p0, uint32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vou4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<uint32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vp(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vp");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vpi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpi4ppi8(void* target, void* p0, int32_t p1, void* p2, void* p3, int64_t p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vpi4ppi8");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p1),
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int64_t>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpi4u4u4(void* target, void* p0, int32_t p1, uint32_t p2, uint32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vpi4u4u4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<uint32_t>::toScript(context, p2),
        converter::Converter<uint32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpi8(void* target, void* p0, int64_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vpi8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        v8::Undefined(isolate),
        converter::Converter<int64_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpppi4(void* target, void* p0, void* p1, void* p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vpppi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpppi4i8(void* target, void* p0, void* p1, void* p2, int32_t p3, int64_t p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vpppi4i8");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p3),
        converter::Converter<int64_t>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpr4r4r4r4r4r4(void* target, void* p0, float p1, float p2, float p3, float p4, float p5, float p6, void* method) {
    // PLog(LogLevel::Log, "Running b_vpr4r4r4r4r4r4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[7]{
        v8::Undefined(isolate),
        converter::Converter<float>::toScript(context, p1),
        converter::Converter<float>::toScript(context, p2),
        converter::Converter<float>::toScript(context, p3),
        converter::Converter<float>::toScript(context, p4),
        converter::Converter<float>::toScript(context, p5),
        converter::Converter<float>::toScript(context, p6)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 7, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpu2i4p(void* target, void* p0, uint16_t p1, int32_t p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vpu2i4p");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        v8::Undefined(isolate),
        converter::Converter<uint16_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpu4(void* target, void* p0, uint32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vpu4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        v8::Undefined(isolate),
        converter::Converter<uint32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpu4u4(void* target, void* p0, uint32_t p1, uint32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vpu4u4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        v8::Undefined(isolate),
        converter::Converter<uint32_t>::toScript(context, p1),
        converter::Converter<uint32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpu4u4u4i4(void* target, void* p0, uint32_t p1, uint32_t p2, uint32_t p3, int32_t p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vpu4u4u4i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        v8::Undefined(isolate),
        converter::Converter<uint32_t>::toScript(context, p1),
        converter::Converter<uint32_t>::toScript(context, p2),
        converter::Converter<uint32_t>::toScript(context, p3),
        converter::Converter<int32_t>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vr4(void* target, float p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vr4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<float>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vr4Ps_r4r4r4r4_Pr4Pr4(void* target, float p0, struct s_r4r4r4r4_* p1, float* p2, float* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vr4Ps_r4r4r4r4_Pr4Pr4");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<float>::toScript(context, p0),
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vr4b(void* target, float p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vr4b");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<float>::toScript(context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_Oi4_(void* target, struct s_Oi4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_Oi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs__(void* target, struct s__ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs__");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_(void* target, struct s_i4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_b(void* target, struct s_i4_ p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_b");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_i4(void* target, struct s_i4_ p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_i4i4(void* target, struct s_i4_ p0, int32_t p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_i4i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_s(void* target, struct s_i4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_s");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_s_Pvi4i4i4pi4i4oi4_(void* target, struct s_i4_ p0, struct s_Pvi4i4i4pi4i4oi4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_s_Pvi4i4i4pi4i4oi4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_s_i4_(void* target, struct s_i4_ p0, struct s_i4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_s_i4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i4_(void* target, struct s_i4i4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i4i4pi4i4i4_o(void* target, struct s_i4i4i4pi4i4i4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i4i4pi4i4i4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_(void* target, struct s_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i8_(void* target, struct s_i4i8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i8_o(void* target, struct s_i4i8_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i8_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4o_(void* target, struct s_i4o_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4o_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4oooo_(void* target, struct s_i4oooo_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4oooo_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4osu8i8_(void* target, struct s_i4osu8i8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4osu8i8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4r4r4i4_(void* target, struct s_i4r4r4i4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4r4r4i4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4ss_(void* target, struct s_i4ss_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4ss_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4u1u1_(void* target, struct s_i4u1u1_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4u1u1_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i8i8_(void* target, struct s_i8i8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i8i8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_oo_(void* target, struct s_oo_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_oo_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_oob_(void* target, struct s_oob_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_oob_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_oooObr4r4r4r4bb_(void* target, struct s_oooObr4r4r4r4bb_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_oooObr4r4r4r4bb_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_ossi4i4i4i4o_(void* target, struct s_ossi4i4i4i4o_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_ossi4i4i4i4o_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_pi4_(void* target, struct s_pi4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_pi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_pi4_o(void* target, struct s_pi4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_pi4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_ppi4i4_o(void* target, struct s_ppi4i4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_ppi4i4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_pu4_(void* target, struct s_pu4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_pu4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4_(void* target, struct s_r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4oi4_(void* target, struct s_r4r4oi4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4oi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4_(void* target, struct s_r4r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_(void* target, struct s_r4r4r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_i4(void* target, struct s_r4r4r4r4_ p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_i4bb(void* target, struct s_r4r4r4r4_ p0, int32_t p1, bool p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_i4bb");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<bool>::toScript(context, p2),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_o(void* target, struct s_r4r4r4r4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_oo(void* target, struct s_r4r4r4r4_ p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_so_(void* target, struct s_so_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_so_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_soo_(void* target, struct s_soo_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_soo_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_ss_(void* target, struct s_ss_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_ss_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_u4u4u4u4_o(void* target, struct s_u4u4u4u4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_u4u4u4u4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_u8_(void* target, struct s_u8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_u8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_u8b_(void* target, struct s_u8b_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_u8b_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_(void* target, struct s_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsb(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vsb");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsbs(void* target, void* p0, bool p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsbs");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsbs_Pvi4i4i4pi4i4oi4i4i4i4_(void* target, void* p0, bool p1, struct s_Pvi4i4i4pi4i4oi4i4i4i4_ p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsbs_Pvi4i4i4pi4i4oi4i4i4i4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vsi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsi8(void* target, void* p0, int64_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vsi8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<int64_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vso(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsoo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsoo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vss(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vss");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vss_r4r4r4r4_(void* target, void* p0, struct s_r4r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vss_r4r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vssi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vssi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsso(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vssoo(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vssoo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vu1(void* target, uint8_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vu1");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<uint8_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vu4(void* target, uint32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vu4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<uint32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vu4u4Ps_ppi4i4p_(void* target, uint32_t p0, uint32_t p1, struct s_ppi4i4p_* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vu4u4Ps_ppi4i4p_");

    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<uint32_t>::toScript(context, p0),
        converter::Converter<uint32_t>::toScript(context, p1),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vu4u4u4i4(void* target, uint32_t p0, uint32_t p1, uint32_t p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vu4u4u4i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<uint32_t>::toScript(context, p0),
        converter::Converter<uint32_t>::toScript(context, p1),
        converter::Converter<uint32_t>::toScript(context, p2),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vu8o(void* target, uint64_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vu8o");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<uint64_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static BridgeFuncInfo g_bridgeFuncInfos[] = {
    
    {"O", (MethodPointer)b_O},
    {"OO", (MethodPointer)b_OO},
    {"OVO", (MethodPointer)b_OVO},
    {"Oi4popb", (MethodPointer)b_Oi4popb},
    {"Oo", (MethodPointer)b_Oo},
    {"Ooo", (MethodPointer)b_Ooo},
    {"Oooo", (MethodPointer)b_Oooo},
    {"Oppi4", (MethodPointer)b_Oppi4},
    {"Os_oooObr4r4r4r4bb_", (MethodPointer)b_Os_oooObr4r4r4r4bb_},
    {"Oso", (MethodPointer)b_Oso},
    {"OssoPi4", (MethodPointer)b_OssoPi4},
    {"b", (MethodPointer)b_b},
    {"bO", (MethodPointer)b_bO},
    {"bOooi4", (MethodPointer)b_bOooi4},
    {"bPs", (MethodPointer)b_bPs},
    {"bPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_", (MethodPointer)b_bPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_},
    {"bb", (MethodPointer)b_bb},
    {"bi4", (MethodPointer)b_bi4},
    {"bi4i4i4po", (MethodPointer)b_bi4i4i4po},
    {"bo", (MethodPointer)b_bo},
    {"boO", (MethodPointer)b_boO},
    {"boPi4", (MethodPointer)b_boPi4},
    {"boPsPs", (MethodPointer)b_boPsPs},
    {"boi4", (MethodPointer)b_boi4},
    {"boi4O", (MethodPointer)b_boi4O},
    {"boo", (MethodPointer)b_boo},
    {"booi4", (MethodPointer)b_booi4},
    {"boooi4", (MethodPointer)b_boooi4},
    {"booso", (MethodPointer)b_booso},
    {"boso", (MethodPointer)b_boso},
    {"bososo", (MethodPointer)b_bososo},
    {"bosso", (MethodPointer)b_bosso},
    {"bosss", (MethodPointer)b_bosss},
    {"bossss", (MethodPointer)b_bossss},
    {"bp", (MethodPointer)b_bp},
    {"bs", (MethodPointer)b_bs},
    {"bsO", (MethodPointer)b_bsO},
    {"bs_i4ss_", (MethodPointer)b_bs_i4ss_},
    {"bs_r4r4_Ps_r4r4r4_Ps_r4r4r4_", (MethodPointer)b_bs_r4r4_Ps_r4r4r4_Ps_r4r4r4_},
    {"bs_sOO_", (MethodPointer)b_bs_sOO_},
    {"bs_u8_", (MethodPointer)b_bs_u8_},
    {"bs_u8u8u4u4u4u4i4oo_oo", (MethodPointer)b_bs_u8u8u4u4u4u4i4oo_oo},
    {"bsbi4s", (MethodPointer)b_bsbi4s},
    {"bso", (MethodPointer)b_bso},
    {"bsooi4", (MethodPointer)b_bsooi4},
    {"bu1o", (MethodPointer)b_bu1o},
    {"csi4c", (MethodPointer)b_csi4c},
    {"i2os", (MethodPointer)b_i2os},
    {"i4", (MethodPointer)b_i4},
    {"i4i4", (MethodPointer)b_i4i4},
    {"i4i4i4ob", (MethodPointer)b_i4i4i4ob},
    {"i4i4sb", (MethodPointer)b_i4i4sb},
    {"i4o", (MethodPointer)b_i4o},
    {"i4ob", (MethodPointer)b_i4ob},
    {"i4oi4o", (MethodPointer)b_i4oi4o},
    {"i4oo", (MethodPointer)b_i4oo},
    {"i4ooo", (MethodPointer)b_i4ooo},
    {"i4oooo", (MethodPointer)b_i4oooo},
    {"i4os", (MethodPointer)b_i4os},
    {"i4os_r4r4r4_s_r4r4_ob", (MethodPointer)b_i4os_r4r4r4_s_r4r4_ob},
    {"i4s_oooObr4r4r4r4bboooObr4r4r4r4bbb_", (MethodPointer)b_i4s_oooObr4r4r4r4bboooObr4r4r4r4bbb_},
    {"i4ss", (MethodPointer)b_i4ss},
    {"i8o", (MethodPointer)b_i8o},
    {"i8os", (MethodPointer)b_i8os},
    {"o", (MethodPointer)b_o},
    {"oO", (MethodPointer)b_oO},
    {"oOo", (MethodPointer)b_oOo},
    {"oOs", (MethodPointer)b_oOs},
    {"oOsooo", (MethodPointer)b_oOsooo},
    {"oPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_", (MethodPointer)b_oPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_},
    {"ob", (MethodPointer)b_ob},
    {"oi4", (MethodPointer)b_oi4},
    {"oi4oo", (MethodPointer)b_oi4oo},
    {"oi4popb", (MethodPointer)b_oi4popb},
    {"oi4s", (MethodPointer)b_oi4s},
    {"oi8oo", (MethodPointer)b_oi8oo},
    {"oo", (MethodPointer)b_oo},
    {"ooO", (MethodPointer)b_ooO},
    {"ooi4", (MethodPointer)b_ooi4},
    {"ooi4i4", (MethodPointer)b_ooi4i4},
    {"ooi4s_r4r4_ooPi4", (MethodPointer)b_ooi4s_r4r4_ooPi4},
    {"ooo", (MethodPointer)b_ooo},
    {"oooO", (MethodPointer)b_oooO},
    {"oooi4", (MethodPointer)b_oooi4},
    {"oooi8o", (MethodPointer)b_oooi8o},
    {"oooo", (MethodPointer)b_oooo},
    {"ooooO", (MethodPointer)b_ooooO},
    {"ooooo", (MethodPointer)b_ooooo},
    {"oooooO", (MethodPointer)b_oooooO},
    {"oooooo", (MethodPointer)b_oooooo},
    {"ooooooo", (MethodPointer)b_ooooooo},
    {"oooooooo", (MethodPointer)b_oooooooo},
    {"ooooooooo", (MethodPointer)b_ooooooooo},
    {"oooooooooo", (MethodPointer)b_oooooooooo},
    {"ooooooooooo", (MethodPointer)b_ooooooooooo},
    {"oooooooooooo", (MethodPointer)b_oooooooooooo},
    {"ooooooooooooo", (MethodPointer)b_ooooooooooooo},
    {"oooooooooooooo", (MethodPointer)b_oooooooooooooo},
    {"ooooooooooooooo", (MethodPointer)b_ooooooooooooooo},
    {"oooooooooooooooo", (MethodPointer)b_oooooooooooooooo},
    {"ooooooooooooooooo", (MethodPointer)b_ooooooooooooooooo},
    {"ooor4", (MethodPointer)b_ooor4},
    {"ooos_r4r4_i4", (MethodPointer)b_ooos_r4r4_i4},
    {"oos", (MethodPointer)b_oos},
    {"oos_r4r4_", (MethodPointer)b_oos_r4r4_},
    {"oosb", (MethodPointer)b_oosb},
    {"ooso", (MethodPointer)b_ooso},
    {"oosu8", (MethodPointer)b_oosu8},
    {"oou4u4", (MethodPointer)b_oou4u4},
    {"os", (MethodPointer)b_os},
    {"os_i4i4_", (MethodPointer)b_os_i4i4_},
    {"os_r4r4r4r4_o", (MethodPointer)b_os_r4r4r4r4_o},
    {"osi4o", (MethodPointer)b_osi4o},
    {"osooo", (MethodPointer)b_osooo},
    {"oss", (MethodPointer)b_oss},
    {"osso", (MethodPointer)b_osso},
    {"pp", (MethodPointer)b_pp},
    {"pppi4i8", (MethodPointer)b_pppi4i8},
    {"r4", (MethodPointer)b_r4},
    {"r4i4", (MethodPointer)b_r4i4},
    {"r4o", (MethodPointer)b_r4o},
    {"r4oos_r4r4r4_", (MethodPointer)b_r4oos_r4r4r4_},
    {"r4os", (MethodPointer)b_r4os},
    {"r4r4", (MethodPointer)b_r4r4},
    {"r4r4Ps_r4r4r4r4_", (MethodPointer)b_r4r4Ps_r4r4r4r4_},
    {"r4s_r4r4r4_", (MethodPointer)b_r4s_r4r4r4_},
    {"r8", (MethodPointer)b_r8},
    {"r8o", (MethodPointer)b_r8o},
    {"r8os", (MethodPointer)b_r8os},
    {"s", (MethodPointer)b_s},
    {"sO", (MethodPointer)b_sO},
    {"s__", (MethodPointer)b_s__},
    {"s_bi4_o", (MethodPointer)b_s_bi4_o},
    {"s_bi4i4i4i4u8_o", (MethodPointer)b_s_bi4i4i4i4u8_o},
    {"s_bi8_o", (MethodPointer)b_s_bi8_o},
    {"s_bo_s", (MethodPointer)b_s_bo_s},
    {"s_br4_o", (MethodPointer)b_s_br4_o},
    {"s_br8_o", (MethodPointer)b_s_br8_o},
    {"s_i4i4_s_i4i4_", (MethodPointer)b_s_i4i4_s_i4i4_},
    {"s_i4i4i4i4u8_o", (MethodPointer)b_s_i4i4i4i4u8_o},
    {"s_ooor4r4_s_ooor4r4_", (MethodPointer)b_s_ooor4r4_s_ooor4r4_},
    {"s_ossi4i4i4i4o_s_ossi4i4i4i4o_", (MethodPointer)b_s_ossi4i4i4i4o_s_ossi4i4i4i4o_},
    {"s_pi4_os_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", (MethodPointer)b_s_pi4_os_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"s_r4r4_o", (MethodPointer)b_s_r4r4_o},
    {"s_r4r4_s_r4r4_", (MethodPointer)b_s_r4r4_s_r4r4_},
    {"s_r4r4r4_o", (MethodPointer)b_s_r4r4r4_o},
    {"s_r4r4r4r4_", (MethodPointer)b_s_r4r4r4r4_},
    {"s_r4r4r4r4_o", (MethodPointer)b_s_r4r4r4r4_o},
    {"s_r4r4r4r4r4r4_", (MethodPointer)b_s_r4r4r4r4r4r4_},
    {"s_u8_o", (MethodPointer)b_s_u8_o},
    {"si4", (MethodPointer)b_si4},
    {"so", (MethodPointer)b_so},
    {"sob", (MethodPointer)b_sob},
    {"soo", (MethodPointer)b_soo},
    {"sos", (MethodPointer)b_sos},
    {"ss", (MethodPointer)b_ss},
    {"ss_oi4osi4u1u1u1u1_", (MethodPointer)b_ss_oi4osi4u1u1u1u1_},
    {"ssbs", (MethodPointer)b_ssbs},
    {"sso", (MethodPointer)b_sso},
    {"u2os", (MethodPointer)b_u2os},
    {"u4os", (MethodPointer)b_u4os},
    {"u4u4pu4", (MethodPointer)b_u4u4pu4},
    {"u8os", (MethodPointer)b_u8os},
    {"v", (MethodPointer)b_v},
    {"vO", (MethodPointer)b_vO},
    {"vODo", (MethodPointer)b_vODo},
    {"vOO", (MethodPointer)b_vOO},
    {"vOb", (MethodPointer)b_vOb},
    {"vOo", (MethodPointer)b_vOo},
    {"vOoi4", (MethodPointer)b_vOoi4},
    {"vOsO", (MethodPointer)b_vOsO},
    {"vOs_Oi4_", (MethodPointer)b_vOs_Oi4_},
    {"vOs_Oi4_o", (MethodPointer)b_vOs_Oi4_o},
    {"vPs_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_", (MethodPointer)b_vPs_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_},
    {"vb", (MethodPointer)b_vb},
    {"vbbi4", (MethodPointer)b_vbbi4},
    {"vbs", (MethodPointer)b_vbs},
    {"vbso", (MethodPointer)b_vbso},
    {"vi4", (MethodPointer)b_vi4},
    {"vi4O", (MethodPointer)b_vi4O},
    {"vi4b", (MethodPointer)b_vi4b},
    {"vi4i4", (MethodPointer)b_vi4i4},
    {"vi4i4i4p", (MethodPointer)b_vi4i4i4p},
    {"vi4i8i8b", (MethodPointer)b_vi4i8i8b},
    {"vi4o", (MethodPointer)b_vi4o},
    {"vi4oi4i4", (MethodPointer)b_vi4oi4i4},
    {"vi4ooo", (MethodPointer)b_vi4ooo},
    {"vi4popO", (MethodPointer)b_vi4popO},
    {"vi4popo", (MethodPointer)b_vi4popo},
    {"vi4s", (MethodPointer)b_vi4s},
    {"vi4s_r4r4r4_s_r4r4r4r4_r4i4", (MethodPointer)b_vi4s_r4r4r4_s_r4r4r4r4_r4i4},
    {"vi4s_r4r4r4r4_", (MethodPointer)b_vi4s_r4r4r4r4_},
    {"vi4u4u4", (MethodPointer)b_vi4u4u4},
    {"vi8", (MethodPointer)b_vi8},
    {"vi8i4", (MethodPointer)b_vi8i4},
    {"vi8i8", (MethodPointer)b_vi8i8},
    {"vi8o", (MethodPointer)b_vi8o},
    {"vo", (MethodPointer)b_vo},
    {"voO", (MethodPointer)b_voO},
    {"voPs_Ps_i4i4i4_Ps_i4i4i4_oPs_i4i4i4_PPs_i4i4i4__b", (MethodPointer)b_voPs_Ps_i4i4i4_Ps_i4i4i4_oPs_i4i4i4_PPs_i4i4i4__b},
    {"vob", (MethodPointer)b_vob},
    {"voi4", (MethodPointer)b_voi4},
    {"voi4i4", (MethodPointer)b_voi4i4},
    {"voi4o", (MethodPointer)b_voi4o},
    {"voi4oo", (MethodPointer)b_voi4oo},
    {"voi4s_r4r4_", (MethodPointer)b_voi4s_r4r4_},
    {"voi8", (MethodPointer)b_voi8},
    {"voi8i8i8i8i8i8i8", (MethodPointer)b_voi8i8i8i8i8i8i8},
    {"voo", (MethodPointer)b_voo},
    {"vooi4", (MethodPointer)b_vooi4},
    {"vooi8", (MethodPointer)b_vooi8},
    {"vooo", (MethodPointer)b_vooo},
    {"voooo", (MethodPointer)b_voooo},
    {"vooooo", (MethodPointer)b_vooooo},
    {"voooooo", (MethodPointer)b_voooooo},
    {"vooooooo", (MethodPointer)b_vooooooo},
    {"voooooooo", (MethodPointer)b_voooooooo},
    {"vooooooooo", (MethodPointer)b_vooooooooo},
    {"voooooooooo", (MethodPointer)b_voooooooooo},
    {"vooooooooooo", (MethodPointer)b_vooooooooooo},
    {"voooooooooooo", (MethodPointer)b_voooooooooooo},
    {"vooooooooooooo", (MethodPointer)b_vooooooooooooo},
    {"voooooooooooooo", (MethodPointer)b_voooooooooooooo},
    {"vooooooooooooooo", (MethodPointer)b_vooooooooooooooo},
    {"voooooooooooooooo", (MethodPointer)b_voooooooooooooooo},
    {"voos", (MethodPointer)b_voos},
    {"vor4", (MethodPointer)b_vor4},
    {"vor8", (MethodPointer)b_vor8},
    {"vos", (MethodPointer)b_vos},
    {"vos_Pvi4i4i4pi4i4oi4_", (MethodPointer)b_vos_Pvi4i4i4pi4i4oi4_},
    {"vos_i4_", (MethodPointer)b_vos_i4_},
    {"vos_i4_ob", (MethodPointer)b_vos_i4_ob},
    {"vos_i4i4i4i4_b", (MethodPointer)b_vos_i4i4i4i4_b},
    {"vos_oi4osi4u1u1u1u1_", (MethodPointer)b_vos_oi4osi4u1u1u1u1_},
    {"vos_r4r4_", (MethodPointer)b_vos_r4r4_},
    {"vos_r4r4_r4", (MethodPointer)b_vos_r4r4_r4},
    {"vos_r4r4r4_", (MethodPointer)b_vos_r4r4r4_},
    {"vos_r4r4r4r4_", (MethodPointer)b_vos_r4r4r4r4_},
    {"vos_sosi4i4i4i4i4_i4", (MethodPointer)b_vos_sosi4i4i4i4i4_i4},
    {"vosb", (MethodPointer)b_vosb},
    {"vosbsr4oo", (MethodPointer)b_vosbsr4oo},
    {"voso", (MethodPointer)b_voso},
    {"voss_i4i4i4i4_b", (MethodPointer)b_voss_i4i4i4i4_b},
    {"vou1s", (MethodPointer)b_vou1s},
    {"vou4", (MethodPointer)b_vou4},
    {"vp", (MethodPointer)b_vp},
    {"vpi4", (MethodPointer)b_vpi4},
    {"vpi4ppi8", (MethodPointer)b_vpi4ppi8},
    {"vpi4u4u4", (MethodPointer)b_vpi4u4u4},
    {"vpi8", (MethodPointer)b_vpi8},
    {"vpppi4", (MethodPointer)b_vpppi4},
    {"vpppi4i8", (MethodPointer)b_vpppi4i8},
    {"vpr4r4r4r4r4r4", (MethodPointer)b_vpr4r4r4r4r4r4},
    {"vpu2i4p", (MethodPointer)b_vpu2i4p},
    {"vpu4", (MethodPointer)b_vpu4},
    {"vpu4u4", (MethodPointer)b_vpu4u4},
    {"vpu4u4u4i4", (MethodPointer)b_vpu4u4u4i4},
    {"vr4", (MethodPointer)b_vr4},
    {"vr4Ps_r4r4r4r4_Pr4Pr4", (MethodPointer)b_vr4Ps_r4r4r4r4_Pr4Pr4},
    {"vr4b", (MethodPointer)b_vr4b},
    {"vs", (MethodPointer)b_vs},
    {"vs_Oi4_", (MethodPointer)b_vs_Oi4_},
    {"vs__", (MethodPointer)b_vs__},
    {"vs_i4_", (MethodPointer)b_vs_i4_},
    {"vs_i4_b", (MethodPointer)b_vs_i4_b},
    {"vs_i4_i4", (MethodPointer)b_vs_i4_i4},
    {"vs_i4_i4i4", (MethodPointer)b_vs_i4_i4i4},
    {"vs_i4_s", (MethodPointer)b_vs_i4_s},
    {"vs_i4_s_Pvi4i4i4pi4i4oi4_", (MethodPointer)b_vs_i4_s_Pvi4i4i4pi4i4oi4_},
    {"vs_i4_s_i4_", (MethodPointer)b_vs_i4_s_i4_},
    {"vs_i4i4_", (MethodPointer)b_vs_i4i4_},
    {"vs_i4i4i4pi4i4i4_o", (MethodPointer)b_vs_i4i4i4pi4i4i4_o},
    {"vs_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_", (MethodPointer)b_vs_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_},
    {"vs_i4i8_", (MethodPointer)b_vs_i4i8_},
    {"vs_i4i8_o", (MethodPointer)b_vs_i4i8_o},
    {"vs_i4o_", (MethodPointer)b_vs_i4o_},
    {"vs_i4oooo_", (MethodPointer)b_vs_i4oooo_},
    {"vs_i4osu8i8_", (MethodPointer)b_vs_i4osu8i8_},
    {"vs_i4r4r4i4_", (MethodPointer)b_vs_i4r4r4i4_},
    {"vs_i4ss_", (MethodPointer)b_vs_i4ss_},
    {"vs_i4u1u1_", (MethodPointer)b_vs_i4u1u1_},
    {"vs_i8i8_", (MethodPointer)b_vs_i8i8_},
    {"vs_oo_", (MethodPointer)b_vs_oo_},
    {"vs_oob_", (MethodPointer)b_vs_oob_},
    {"vs_oooObr4r4r4r4bb_", (MethodPointer)b_vs_oooObr4r4r4r4bb_},
    {"vs_ossi4i4i4i4o_", (MethodPointer)b_vs_ossi4i4i4i4o_},
    {"vs_pi4_", (MethodPointer)b_vs_pi4_},
    {"vs_pi4_o", (MethodPointer)b_vs_pi4_o},
    {"vs_ppi4i4_o", (MethodPointer)b_vs_ppi4i4_o},
    {"vs_pu4_", (MethodPointer)b_vs_pu4_},
    {"vs_r4r4_", (MethodPointer)b_vs_r4r4_},
    {"vs_r4r4oi4_", (MethodPointer)b_vs_r4r4oi4_},
    {"vs_r4r4r4_", (MethodPointer)b_vs_r4r4r4_},
    {"vs_r4r4r4r4_", (MethodPointer)b_vs_r4r4r4r4_},
    {"vs_r4r4r4r4_i4", (MethodPointer)b_vs_r4r4r4r4_i4},
    {"vs_r4r4r4r4_i4bb", (MethodPointer)b_vs_r4r4r4r4_i4bb},
    {"vs_r4r4r4r4_o", (MethodPointer)b_vs_r4r4r4r4_o},
    {"vs_r4r4r4r4_oo", (MethodPointer)b_vs_r4r4r4r4_oo},
    {"vs_so_", (MethodPointer)b_vs_so_},
    {"vs_soo_", (MethodPointer)b_vs_soo_},
    {"vs_ss_", (MethodPointer)b_vs_ss_},
    {"vs_u4u4u4u4_o", (MethodPointer)b_vs_u4u4u4u4_o},
    {"vs_u8_", (MethodPointer)b_vs_u8_},
    {"vs_u8b_", (MethodPointer)b_vs_u8b_},
    {"vs_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_", (MethodPointer)b_vs_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_},
    {"vsb", (MethodPointer)b_vsb},
    {"vsbs", (MethodPointer)b_vsbs},
    {"vsbs_Pvi4i4i4pi4i4oi4i4i4i4_", (MethodPointer)b_vsbs_Pvi4i4i4pi4i4oi4i4i4i4_},
    {"vsi4", (MethodPointer)b_vsi4},
    {"vsi8", (MethodPointer)b_vsi8},
    {"vso", (MethodPointer)b_vso},
    {"vsoo", (MethodPointer)b_vsoo},
    {"vss", (MethodPointer)b_vss},
    {"vss_r4r4r4r4_", (MethodPointer)b_vss_r4r4r4r4_},
    {"vssi4", (MethodPointer)b_vssi4},
    {"vsso", (MethodPointer)b_vsso},
    {"vssoo", (MethodPointer)b_vssoo},
    {"vu1", (MethodPointer)b_vu1},
    {"vu4", (MethodPointer)b_vu4},
    {"vu4u4Ps_ppi4i4p_", (MethodPointer)b_vu4u4Ps_ppi4i4p_},
    {"vu4u4u4i4", (MethodPointer)b_vu4u4u4i4},
    {"vu8o", (MethodPointer)b_vu8o},
    {nullptr, nullptr}
};


static void ifg_b(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_b");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    bool ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_b(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_b");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal P any
    bool p = converter::Converter<bool>::toCpp(context, info[0]);
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_i4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_i4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    int32_t ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_i4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_i4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal P any
    int32_t p = converter::Converter<int32_t>::toCpp(context, info[0]);
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_i8(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_i8");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    int64_t ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
}

static void ifs_i8(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_i8");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal P any
    int64_t p = converter::Converter<int64_t>::toCpp(context, info[0]);
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_o(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_o");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    void* ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
}

static void ifs_o(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_o");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal o/O
    void* p = JsValueToCSRef(context, info[0], TIp);
    FieldSet(nullptr, fieldInfo, offset, p);
}

static void ifg_r4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_r4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    float ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_r4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_r4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal P any
    float p = converter::Converter<float>::toCpp(context, info[0]);
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_s(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_s");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    void* ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
}

static void ifs_s(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_s");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal s
    v8::String::Utf8Value tp(isolate, info[0]);
    void* p = CStringToCSharpString(*tp);
    FieldSet(nullptr, fieldInfo, offset, p);
}

static void ifg_s_i8i8i8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_s_i8i8i8_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    auto ret = GetValueTypeFieldPtr(nullptr, fieldInfo, offset);
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_s_i8i8i8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_s_i8i8i8_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal struct
    s_i8i8i8_* pp = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p = pp ? *pp : s_i8i8i8_ {};
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_s_i8i8i8i8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_s_i8i8i8i8_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    auto ret = GetValueTypeFieldPtr(nullptr, fieldInfo, offset);
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_s_i8i8i8i8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_s_i8i8i8i8_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal struct
    s_i8i8i8i8_* pp = DataTransfer::GetPointer<s_i8i8i8i8_>(context, info[0]);
    s_i8i8i8i8_ p = pp ? *pp : s_i8i8i8i8_ {};
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_s_r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_s_r4r4r4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    auto ret = GetValueTypeFieldPtr(nullptr, fieldInfo, offset);
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_s_r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_s_r4r4r4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal struct
    s_r4r4r4_* pp = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p = pp ? *pp : s_r4r4r4_ {};
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_s_r4r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_s_r4r4r4r4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    auto ret = GetValueTypeFieldPtr(nullptr, fieldInfo, offset);
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_s_r4r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_s_r4r4r4r4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal struct
    s_r4r4r4r4_* pp = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p = pp ? *pp : s_r4r4r4r4_ {};
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_tO(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_tO");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    void* ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
}

static void ifs_tO(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_tO");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal o/O
    void* p = JsValueToCSRef(context, info[0], TIp);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_tb(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_tb");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    bool ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_tb(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_tb");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    bool p = converter::Converter<bool>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ti2(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ti2");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    int16_t ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_ti2(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ti2");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    int16_t p = converter::Converter<int16_t>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ti4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ti4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    int32_t ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_ti4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ti4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    int32_t p = converter::Converter<int32_t>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ti8(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ti8");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    int64_t ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
}

static void ifs_ti8(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ti8");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    int64_t p = converter::Converter<int64_t>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_to(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_to");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    void* ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
}

static void ifs_to(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_to");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal o/O
    void* p = JsValueToCSRef(context, info[0], TIp);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_tp(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_tp");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    void* ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
}

static void ifs_tp(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_tp");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    void* p = DataTransfer::GetPointer<void>(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_tr4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_tr4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    float ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_tr4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_tr4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    float p = converter::Converter<float>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_tr8(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_tr8");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    double ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_tr8(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_tr8");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    double p = converter::Converter<double>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    void* ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
}

static void ifs_ts(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal s
    v8::String::Utf8Value tp(isolate, info[0]);
    void* p = CStringToCSharpString(*tp);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_bi4u1u1u1u1_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_bi4u1u1u1u1_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_bi4u1u1u1u1_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_bi4u1u1u1u1_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_bi4u1u1u1u1_* pp = DataTransfer::GetPointer<s_bi4u1u1u1u1_>(context, info[0]);
    s_bi4u1u1u1u1_ p = pp ? *pp : s_bi4u1u1u1u1_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_br4r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_br4r4r4r4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_br4r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_br4r4r4r4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_br4r4r4r4_* pp = DataTransfer::GetPointer<s_br4r4r4r4_>(context, info[0]);
    s_br4r4r4r4_ p = pp ? *pp : s_br4r4r4r4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_i4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_i4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_i4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_i4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_i4_* pp = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p = pp ? *pp : s_i4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_i4u1u1u1u1_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_i4u1u1u1u1_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_i4u1u1u1u1_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_i4u1u1u1u1_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_i4u1u1u1u1_* pp = DataTransfer::GetPointer<s_i4u1u1u1u1_>(context, info[0]);
    s_i4u1u1u1u1_ p = pp ? *pp : s_i4u1u1u1u1_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_i8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_i8_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_i8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_i8_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_i8_* pp = DataTransfer::GetPointer<s_i8_>(context, info[0]);
    s_i8_ p = pp ? *pp : s_i8_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_i8i8i8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_i8i8i8_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_i8i8i8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_i8i8i8_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_i8i8i8_* pp = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p = pp ? *pp : s_i8i8i8_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_r4r4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_r4r4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_r4r4_* pp = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p = pp ? *pp : s_r4r4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_r4r4r4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_r4r4r4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_r4r4r4_* pp = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p = pp ? *pp : s_r4r4r4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_r4r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_r4r4r4r4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_r4r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_r4r4r4r4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_r4r4r4r4_* pp = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p = pp ? *pp : s_r4r4r4r4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_* pp = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_ p = pp ? *pp : s_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p = pp ? *pp : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_tu4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_tu4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    uint32_t ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_tu4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_tu4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    uint32_t p = converter::Converter<uint32_t>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static FieldWrapFuncInfo g_fieldWrapFuncInfos[] = {
    
    {"b", ifg_b, ifs_b},
    {"i4", ifg_i4, ifs_i4},
    {"i8", ifg_i8, ifs_i8},
    {"o", ifg_o, ifs_o},
    {"r4", ifg_r4, ifs_r4},
    {"s", ifg_s, ifs_s},
    {"s_i8i8i8_", ifg_s_i8i8i8_, ifs_s_i8i8i8_},
    {"s_i8i8i8i8_", ifg_s_i8i8i8i8_, ifs_s_i8i8i8i8_},
    {"s_r4r4r4_", ifg_s_r4r4r4_, ifs_s_r4r4r4_},
    {"s_r4r4r4r4_", ifg_s_r4r4r4r4_, ifs_s_r4r4r4r4_},
    {"tO", ifg_tO, ifs_tO},
    {"tb", ifg_tb, ifs_tb},
    {"ti2", ifg_ti2, ifs_ti2},
    {"ti4", ifg_ti4, ifs_ti4},
    {"ti8", ifg_ti8, ifs_ti8},
    {"to", ifg_to, ifs_to},
    {"tp", ifg_tp, ifs_tp},
    {"tr4", ifg_tr4, ifs_tr4},
    {"tr8", ifg_tr8, ifs_tr8},
    {"ts", ifg_ts, ifs_ts},
    {"ts_bi4u1u1u1u1_", ifg_ts_bi4u1u1u1u1_, ifs_ts_bi4u1u1u1u1_},
    {"ts_br4r4r4r4_", ifg_ts_br4r4r4r4_, ifs_ts_br4r4r4r4_},
    {"ts_i4_", ifg_ts_i4_, ifs_ts_i4_},
    {"ts_i4u1u1u1u1_", ifg_ts_i4u1u1u1u1_, ifs_ts_i4u1u1u1u1_},
    {"ts_i8_", ifg_ts_i8_, ifs_ts_i8_},
    {"ts_i8i8i8_", ifg_ts_i8i8i8_, ifs_ts_i8i8i8_},
    {"ts_r4r4_", ifg_ts_r4r4_, ifs_ts_r4r4_},
    {"ts_r4r4r4_", ifg_ts_r4r4r4_, ifs_ts_r4r4r4_},
    {"ts_r4r4r4r4_", ifg_ts_r4r4r4r4_, ifs_ts_r4r4r4r4_},
    {"ts_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_", ifg_ts_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_, ifs_ts_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_},
    {"ts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", ifg_ts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_, ifs_ts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"tu4", ifg_tu4, ifs_tu4},
    {nullptr, nullptr, nullptr}    
};

