

// Auto Gen

#if !__SNC__
#ifndef __has_feature 
#define __has_feature(x) 0 
#endif
#endif

#if _MSC_VER
typedef wchar_t Il2CppChar;
#elif __has_feature(cxx_unicode_literals)
typedef char16_t Il2CppChar;
#else
typedef uint16_t Il2CppChar;
#endif

// GPathPoint
struct s_r4r4r4r4r4r4r4r4r4i4b_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    int32_t p9;
    bool p10;
};
    
// Margin
struct s_i4i4i4i4_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
};
    
// LineCharInfo
struct s_r4r4r4_
{
    float p0;
    float p1;
    float p2;
};
    
// CharPosition
struct s_i4i2r4i2i2i2_
{
    int32_t p0;
    int16_t p1;
    float p2;
    int16_t p3;
    int16_t p4;
    int16_t p5;
};
    
// ClipInfo
struct s_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    bool p8;
    float p9;
    float p10;
    float p11;
    float p12;
    uint32_t p13;
    int32_t p14;
    int32_t p15;
    bool p16;
};
    
// Enumerator
struct s_osi4i4o_
{
    void* p0;
    void* p1;
    int32_t p2;
    int32_t p3;
    void* p4;
};
    
// MatAniInfo
struct s_oo_
{
    void* p0;
    void* p1;
};
    
// OrderRecord
struct s_si4_
{
    void* p0;
    int32_t p1;
};
    
// MathfInternal
struct s__
{
};
    
// SortingLayer
struct s_i4_
{
    int32_t p0;
};
    
// Keyframe
struct s_r4r4r4r4i4i4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    int32_t p4;
    int32_t p5;
    float p6;
    float p7;
};
    
// CachedAssetBundle
struct s_su8u8_
{
    void* p0;
    uint64_t p1;
    uint64_t p2;
};
    
// GateFitParameters
struct s_i4r4_
{
    int32_t p0;
    float p1;
};
    
// RenderRequest
struct s_i4oi4_
{
    int32_t p0;
    void* p1;
    int32_t p2;
};
    
// BoundingSphere
struct s_r4r4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
};
    
// CullingGroupEvent
struct s_i4u1u1_
{
    int32_t p0;
    uint8_t p1;
    uint8_t p2;
};
    
// ExposedPropertyResolver
struct s_p_
{
    void* p0;
};
    
// Bounds
struct s_r4r4r4r4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
};
    
// BoundsInt
struct s_i4i4i4i4i4i4_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    int32_t p4;
    int32_t p5;
};
    
// PositionEnumerator
struct s_i4i4i4i4i4i4i4i4i4_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    int32_t p4;
    int32_t p5;
    int32_t p6;
    int32_t p7;
    int32_t p8;
};
    
// RefreshRate
struct s_u4u4_
{
    uint32_t p0;
    uint32_t p1;
};
    
// DisplayInfo
struct s_u8i4i4u4u4i4i4i4i4s_
{
    uint64_t p0;
    int32_t p1;
    int32_t p2;
    uint32_t p3;
    uint32_t p4;
    int32_t p5;
    int32_t p6;
    int32_t p7;
    int32_t p8;
    void* p9;
};
    
// RenderBuffer
struct s_i4p_
{
    int32_t p0;
    void* p1;
};
    
// FrameTiming
struct s_u8r8u8r8r4r4u4_
{
    uint64_t p0;
    double p1;
    uint64_t p2;
    double p3;
    float p4;
    float p5;
    uint32_t p6;
};
    
// Resolution
struct s_i4i4i4_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
};
    
// RenderTargetSetup
struct s_oi4pi4i4i4ooi4i4_
{
    void* p0;
    int32_t p1;
    void* p2;
    int32_t p3;
    int32_t p4;
    int32_t p5;
    void* p6;
    void* p7;
    int32_t p8;
    int32_t p9;
};
    
// RenderParams
struct s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_
{
    int32_t p0;
    uint32_t p1;
    int32_t p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    void* p9;
    int32_t p10;
    int32_t p11;
    void* p12;
    void* p13;
    int32_t p14;
    bool p15;
    int32_t p16;
    void* p17;
};
    
// MeshData
struct s_ppi4i4_
{
    void* p0;
    void* p1;
    int32_t p2;
    int32_t p3;
};
    
// MeshDataArray
struct s_Ppi4i4i4pi4i4o_
{
    void** p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
};
    
// IndirectDrawArgs
struct s_u4u4u4u4_
{
    uint32_t p0;
    uint32_t p1;
    uint32_t p2;
    uint32_t p3;
};
    
// IndirectDrawIndexedArgs
struct s_u4u4u4u4u4_
{
    uint32_t p0;
    uint32_t p1;
    uint32_t p2;
    uint32_t p3;
    uint32_t p4;
};
    
// LightBakingOutput
struct s_i4i4i4i4b_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    bool p4;
};
    
// LOD
struct s_r4r4o_
{
    float p0;
    float p1;
    void* p2;
};
    
// BoneWeight
struct s_r4r4r4r4i4i4i4i4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    int32_t p4;
    int32_t p5;
    int32_t p6;
    int32_t p7;
};
    
// BoneWeight1
struct s_r4i4_
{
    float p0;
    int32_t p1;
};
    
// CombineInstance
struct s_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_
{
    int32_t p0;
    int32_t p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    float p22;
    float p23;
    float p24;
    float p25;
};
    
// CustomRenderTextureUpdateZone
struct s_r4r4r4r4r4r4r4i4b_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    int32_t p7;
    bool p8;
};
    
// RenderTextureDescriptor
struct s_i4i4i4i4i4i4i4i4i4i4i4i4i4_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    int32_t p4;
    int32_t p5;
    int32_t p6;
    int32_t p7;
    int32_t p8;
    int32_t p9;
    int32_t p10;
    int32_t p11;
    int32_t p12;
};
    
// Hash128
struct s_u8u8_
{
    uint64_t p0;
    uint64_t p1;
};
    
// Color32
struct s_i4u1u1u1u1_
{
    int32_t p0;
    uint8_t p1;
    uint8_t p2;
    uint8_t p3;
    uint8_t p4;
};
    
// GradientColorKey
struct s_r4r4r4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
};
    
// GradientAlphaKey
struct s_r4r4_
{
    float p0;
    float p1;
};
    
// Matrix4x4
struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
};
    
// Vector2Int
struct s_i4i4_
{
    int32_t p0;
    int32_t p1;
};
    
// ShaderVariant
struct s_oi4o_
{
    void* p0;
    int32_t p1;
    void* p2;
};
    
// Pose
struct s_r4r4r4r4r4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
};
    
// DrivenRectTransformTracker
struct s_o_
{
    void* p0;
};
    
// SecondarySpriteTexture
struct s_so_
{
    void* p0;
    void* p1;
};
    
// SpriteBone
struct s_ssr4r4r4r4r4r4r4r4i4i4u1u1u1u1_
{
    void* p0;
    void* p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    int32_t p10;
    int32_t p11;
    uint8_t p12;
    uint8_t p13;
    uint8_t p14;
    uint8_t p15;
};
    
// DebugScreenCapture
struct s_Pvi4i4i4pi4i4oi4i4i4i4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
    int32_t p8;
    int32_t p9;
    int32_t p10;
    int32_t p11;
};
    
// TransformAccess
struct s_pi4b_
{
    void* p0;
    int32_t p1;
    bool p2;
};
    
// TransformAccessArray
struct s_ppi4i4o_
{
    void* p0;
    void* p1;
    int32_t p2;
    int32_t p3;
    void* p4;
};
    
// SecondaryTileData
struct s_si4u1u1u1u1bsi4sbsbbbbssssss_
{
    void* p0;
    int32_t p1;
    uint8_t p2;
    uint8_t p3;
    uint8_t p4;
    uint8_t p5;
    bool p6;
    void* p7;
    int32_t p8;
    void* p9;
    bool p10;
    void* p11;
    bool p12;
    bool p13;
    bool p14;
    bool p15;
    void* p16;
    void* p17;
    void* p18;
    void* p19;
    void* p20;
    void* p21;
};
    
// PhraseRecognizedEventArgs
struct s_i4osu8i8_
{
    int32_t p0;
    void* p1;
    void* p2;
    uint64_t p3;
    int64_t p4;
};
    
// PhotoCaptureResult
struct s_i4i8_
{
    int32_t p0;
    int64_t p1;
};
    
// CameraParameters
struct s_r4r4i4i4i4_
{
    float p0;
    float p1;
    int32_t p2;
    int32_t p3;
    int32_t p4;
};
    
// PlayerLoopSystem
struct s_ooopp_
{
    void* p0;
    void* p1;
    void* p2;
    void* p3;
    void* p4;
};
    
// AsyncGPUReadbackRequest
struct s_pi4_
{
    void* p0;
    int32_t p1;
};
    
// SubMeshDescriptor
struct s_r4r4r4r4r4r4i4i4i4i4i4i4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    int32_t p6;
    int32_t p7;
    int32_t p8;
    int32_t p9;
    int32_t p10;
    int32_t p11;
};
    
// RenderTargetIdentifier
struct s_i4i4i4pi4i4i4_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    void* p3;
    int32_t p4;
    int32_t p5;
    int32_t p6;
};
    
// RenderTargetBinding
struct s_oi4i4i4pi4i4i4ooi4i4i4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    int32_t p7;
    void* p8;
    void* p9;
    int32_t p10;
    int32_t p11;
    int32_t p12;
};
    
// ReflectionProbeBlendInfo
struct s_or4_
{
    void* p0;
    float p1;
};
    
// GraphicsFence
struct s_pi4i4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
};
    
// SphericalHarmonicsL2
struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    float p22;
    float p23;
    float p24;
    float p25;
    float p26;
};
    
// BatchCullingContext
struct s_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
    int32_t p8;
    void* p9;
    int32_t p10;
    int32_t p11;
    int32_t p12;
    void* p13;
    int32_t p14;
    int32_t p15;
    void* p16;
    int32_t p17;
    void* p18;
    int32_t p19;
    int32_t p20;
    int32_t p21;
    void* p22;
    int32_t p23;
    int32_t p24;
    void* p25;
    int32_t p26;
    void* p27;
    int32_t p28;
    int32_t p29;
    int32_t p30;
    void* p31;
    int32_t p32;
    int32_t p33;
    void* p34;
    int32_t p35;
    int32_t p36;
    float p37;
    float p38;
    float p39;
    float p40;
    float p41;
    int32_t p42;
    float p43;
    float p44;
    float p45;
    float p46;
    float p47;
    float p48;
    float p49;
    float p50;
    float p51;
    float p52;
    float p53;
    float p54;
    float p55;
    float p56;
    float p57;
    float p58;
    float p59;
};
    
// AttachmentDescriptor
struct s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    int32_t p4;
    int32_t p5;
    void* p6;
    int32_t p7;
    int32_t p8;
    int32_t p9;
    int32_t p10;
    int32_t p11;
    int32_t p12;
    void* p13;
    int32_t p14;
    int32_t p15;
    int32_t p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    uint32_t p22;
};
    
// BlendState
struct s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_
{
    uint8_t p0;
    uint8_t p1;
    uint8_t p2;
    uint8_t p3;
    uint8_t p4;
    uint8_t p5;
    uint8_t p6;
    uint8_t p7;
    uint8_t p8;
    uint8_t p9;
    uint8_t p10;
    uint8_t p11;
    uint8_t p12;
    uint8_t p13;
    uint8_t p14;
    uint8_t p15;
    uint8_t p16;
    uint8_t p17;
    uint8_t p18;
    uint8_t p19;
    uint8_t p20;
    uint8_t p21;
    uint8_t p22;
    uint8_t p23;
    uint8_t p24;
    uint8_t p25;
    uint8_t p26;
    uint8_t p27;
    uint8_t p28;
    uint8_t p29;
    uint8_t p30;
    uint8_t p31;
    uint8_t p32;
    uint8_t p33;
    uint8_t p34;
    uint8_t p35;
    uint8_t p36;
    uint8_t p37;
    uint8_t p38;
    uint8_t p39;
    uint8_t p40;
    uint8_t p41;
    uint8_t p42;
    uint8_t p43;
    uint8_t p44;
    uint8_t p45;
    uint8_t p46;
    uint8_t p47;
    uint8_t p48;
    uint8_t p49;
    uint8_t p50;
    uint8_t p51;
    uint8_t p52;
    uint8_t p53;
    uint8_t p54;
    uint8_t p55;
    uint8_t p56;
    uint8_t p57;
    uint8_t p58;
    uint8_t p59;
    uint8_t p60;
    uint8_t p61;
    uint8_t p62;
    uint8_t p63;
    uint8_t p64;
    uint8_t p65;
    int16_t p66;
};
    
// CameraProperties
struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    float p22;
    float p23;
    float p24;
    float p25;
    float p26;
    float p27;
    float p28;
    float p29;
    float p30;
    float p31;
    float p32;
    float p33;
    float p34;
    float p35;
    float p36;
    float p37;
    float p38;
    float p39;
    float p40;
    float p41;
    float p42;
    float p43;
    float p44;
    float p45;
    float p46;
    float p47;
    float p48;
    float p49;
    float p50;
    float p51;
    float p52;
    float p53;
    float p54;
    float p55;
    float p56;
    float p57;
    float p58;
    float p59;
    float p60;
    float p61;
    float p62;
    float p63;
    float p64;
    float p65;
    float p66;
    float p67;
    float p68;
    float p69;
    float p70;
    float p71;
    float p72;
    float p73;
    float p74;
    float p75;
    float p76;
    float p77;
    float p78;
    float p79;
    float p80;
    float p81;
    float p82;
    float p83;
    float p84;
    float p85;
    float p86;
    float p87;
    float p88;
    float p89;
    float p90;
    float p91;
    float p92;
    float p93;
    float p94;
    float p95;
    float p96;
    float p97;
    float p98;
    float p99;
    float p100;
    float p101;
    float p102;
    float p103;
    float p104;
    float p105;
    float p106;
    float p107;
    float p108;
    float p109;
    float p110;
    float p111;
    float p112;
    float p113;
    float p114;
    float p115;
    float p116;
    float p117;
    float p118;
    float p119;
    float p120;
    float p121;
    float p122;
    float p123;
    float p124;
    float p125;
    float p126;
    float p127;
    float p128;
    float p129;
    float p130;
    float p131;
    float p132;
    float p133;
    float p134;
    float p135;
    float p136;
    float p137;
    float p138;
    float p139;
    float p140;
    float p141;
    float p142;
    float p143;
    float p144;
    float p145;
    float p146;
    float p147;
    float p148;
    float p149;
    float p150;
    float p151;
    float p152;
    float p153;
    float p154;
    float p155;
    uint32_t p156;
    uint8_t p157;
    uint8_t p158;
    float p159;
    float p160;
    float p161;
    float p162;
    float p163;
    int32_t p164;
    int32_t p165;
    uint32_t p166;
    int32_t p167;
    uint32_t p168;
    int32_t p169;
    int32_t p170;
};
    
// ScriptableCullingParameters
struct s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_
{
    int32_t p0;
    int32_t p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    int32_t p7;
    uint8_t p8;
    int32_t p9;
    uint32_t p10;
    uint64_t p11;
    float p12;
    int32_t p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    float p22;
    float p23;
    float p24;
    float p25;
    float p26;
    float p27;
    float p28;
    float p29;
    float p30;
    float p31;
    float p32;
    float p33;
    float p34;
    int32_t p35;
    int32_t p36;
    float p37;
    float p38;
    float p39;
    float p40;
    float p41;
    float p42;
    float p43;
    float p44;
    float p45;
    float p46;
    float p47;
    float p48;
    float p49;
    float p50;
    float p51;
    float p52;
    float p53;
    float p54;
    float p55;
    float p56;
    float p57;
    float p58;
    float p59;
    float p60;
    float p61;
    float p62;
    float p63;
    float p64;
    float p65;
    float p66;
    float p67;
    float p68;
    float p69;
    float p70;
    float p71;
    float p72;
    float p73;
    float p74;
    float p75;
    float p76;
    float p77;
    float p78;
    float p79;
    float p80;
    float p81;
    float p82;
    float p83;
    float p84;
    float p85;
    float p86;
    float p87;
    float p88;
    float p89;
    float p90;
    float p91;
    float p92;
    float p93;
    float p94;
    float p95;
    float p96;
    float p97;
    float p98;
    float p99;
    float p100;
    float p101;
    float p102;
    float p103;
    float p104;
    float p105;
    float p106;
    float p107;
    float p108;
    float p109;
    float p110;
    float p111;
    float p112;
    float p113;
    float p114;
    float p115;
    float p116;
    float p117;
    float p118;
    float p119;
    float p120;
    float p121;
    float p122;
    float p123;
    float p124;
    float p125;
    float p126;
    float p127;
    float p128;
    float p129;
    float p130;
    float p131;
    float p132;
    float p133;
    float p134;
    float p135;
    float p136;
    float p137;
    float p138;
    float p139;
    float p140;
    float p141;
    float p142;
    float p143;
    float p144;
    float p145;
    float p146;
    float p147;
    float p148;
    float p149;
    float p150;
    float p151;
    float p152;
    float p153;
    float p154;
    float p155;
    float p156;
    float p157;
    float p158;
    float p159;
    float p160;
    float p161;
    float p162;
    float p163;
    float p164;
    float p165;
    float p166;
    float p167;
    float p168;
    float p169;
    float p170;
    float p171;
    float p172;
    float p173;
    float p174;
    float p175;
    float p176;
    float p177;
    float p178;
    float p179;
    float p180;
    float p181;
    float p182;
    float p183;
    float p184;
    float p185;
    float p186;
    float p187;
    float p188;
    float p189;
    float p190;
    float p191;
    float p192;
    uint32_t p193;
    uint8_t p194;
    uint8_t p195;
    float p196;
    float p197;
    float p198;
    float p199;
    float p200;
    int32_t p201;
    int32_t p202;
    uint32_t p203;
    int32_t p204;
    uint32_t p205;
    int32_t p206;
    int32_t p207;
    float p208;
    int32_t p209;
    float p210;
    float p211;
    float p212;
    float p213;
    float p214;
    float p215;
    float p216;
    float p217;
    float p218;
    float p219;
    float p220;
    float p221;
    float p222;
    float p223;
    float p224;
    float p225;
    float p226;
    float p227;
    float p228;
    float p229;
    float p230;
    float p231;
    float p232;
    float p233;
    float p234;
    float p235;
    float p236;
    float p237;
    float p238;
    float p239;
    float p240;
    float p241;
    float p242;
    int32_t p243;
    bool p244;
    int32_t p245;
};
    
// CullingResults
struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_
{
    void* p0;
    struct s_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_* p1;
    void* p2;
    int32_t p3;
    int32_t p4;
};
    
// DepthState
struct s_u1i1_
{
    uint8_t p0;
    int8_t p1;
};
    
// DrawingSettings
struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    int32_t p22;
    int32_t p23;
    float p24;
    float p25;
    float p26;
    float p27;
    float p28;
    float p29;
    float p30;
    float p31;
    float p32;
    float p33;
    float p34;
    float p35;
    float p36;
    float p37;
    float p38;
    float p39;
    float p40;
    float p41;
    float p42;
    float p43;
    float p44;
    float p45;
    float p46;
    float p47;
    float p48;
    float p49;
    float p50;
    float p51;
    float p52;
    float p53;
    float p54;
    float p55;
    int32_t p56;
    int32_t p57;
    int32_t p58;
    int32_t p59;
    int32_t p60;
    int32_t p61;
    int32_t p62;
    int32_t p63;
};
    
// FilteringSettings
struct s_i4i4i4u4i4i2i2_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    uint32_t p3;
    int32_t p4;
    int16_t p5;
    int16_t p6;
};
    
// LODParameters
struct s_i4r4r4r4r4r4i4_
{
    int32_t p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    int32_t p6;
};
    
// RasterState
struct s_i4i4r4u1u1u1u1_
{
    int32_t p0;
    int32_t p1;
    float p2;
    uint8_t p3;
    uint8_t p4;
    uint8_t p5;
    uint8_t p6;
};
    
// RenderStateBlock
struct s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_
{
    uint8_t p0;
    uint8_t p1;
    uint8_t p2;
    uint8_t p3;
    uint8_t p4;
    uint8_t p5;
    uint8_t p6;
    uint8_t p7;
    uint8_t p8;
    uint8_t p9;
    uint8_t p10;
    uint8_t p11;
    uint8_t p12;
    uint8_t p13;
    uint8_t p14;
    uint8_t p15;
    uint8_t p16;
    uint8_t p17;
    uint8_t p18;
    uint8_t p19;
    uint8_t p20;
    uint8_t p21;
    uint8_t p22;
    uint8_t p23;
    uint8_t p24;
    uint8_t p25;
    uint8_t p26;
    uint8_t p27;
    uint8_t p28;
    uint8_t p29;
    uint8_t p30;
    uint8_t p31;
    uint8_t p32;
    uint8_t p33;
    uint8_t p34;
    uint8_t p35;
    uint8_t p36;
    uint8_t p37;
    uint8_t p38;
    uint8_t p39;
    uint8_t p40;
    uint8_t p41;
    uint8_t p42;
    uint8_t p43;
    uint8_t p44;
    uint8_t p45;
    uint8_t p46;
    uint8_t p47;
    uint8_t p48;
    uint8_t p49;
    uint8_t p50;
    uint8_t p51;
    uint8_t p52;
    uint8_t p53;
    uint8_t p54;
    uint8_t p55;
    uint8_t p56;
    uint8_t p57;
    uint8_t p58;
    uint8_t p59;
    uint8_t p60;
    uint8_t p61;
    uint8_t p62;
    uint8_t p63;
    uint8_t p64;
    uint8_t p65;
    int16_t p66;
    int32_t p67;
    int32_t p68;
    float p69;
    uint8_t p70;
    uint8_t p71;
    uint8_t p72;
    uint8_t p73;
    uint8_t p74;
    int8_t p75;
    uint8_t p76;
    uint8_t p77;
    uint8_t p78;
    uint8_t p79;
    uint8_t p80;
    uint8_t p81;
    uint8_t p82;
    uint8_t p83;
    uint8_t p84;
    uint8_t p85;
    uint8_t p86;
    uint8_t p87;
    int32_t p88;
    int32_t p89;
};
    
// RenderTargetBlendState
struct s_u1u1u1u1u1u1u1u1_
{
    uint8_t p0;
    uint8_t p1;
    uint8_t p2;
    uint8_t p3;
    uint8_t p4;
    uint8_t p5;
    uint8_t p6;
    uint8_t p7;
};
    
// ShadowDrawingSettings
struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_
{
    void* p0;
    struct s_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_* p1;
    void* p2;
    int32_t p3;
    int32_t p4;
    int32_t p5;
    int32_t p6;
    int32_t p7;
    uint8_t p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    int32_t p15;
};
    
// ShadowSplitData
struct s_i4u1r4r4r4r4r4r4_
{
    int32_t p0;
    uint8_t p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
};
    
// SortingLayerRange
struct s_i2i2_
{
    int16_t p0;
    int16_t p1;
};
    
// SortingSettings
struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    int32_t p22;
    int32_t p23;
    float p24;
    float p25;
    float p26;
    float p27;
    float p28;
    float p29;
    float p30;
    float p31;
    float p32;
    float p33;
    float p34;
    float p35;
    float p36;
    float p37;
    float p38;
    float p39;
    float p40;
    float p41;
    float p42;
    float p43;
    float p44;
    float p45;
    float p46;
    float p47;
    float p48;
    float p49;
    float p50;
    float p51;
    float p52;
    float p53;
    float p54;
    float p55;
};
    
// StencilState
struct s_u1u1u1u1u1u1u1u1u1u1u1u1_
{
    uint8_t p0;
    uint8_t p1;
    uint8_t p2;
    uint8_t p3;
    uint8_t p4;
    uint8_t p5;
    uint8_t p6;
    uint8_t p7;
    uint8_t p8;
    uint8_t p9;
    uint8_t p10;
    uint8_t p11;
};
    
// VisibleLight
struct s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_
{
    int32_t p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    float p22;
    float p23;
    float p24;
    float p25;
    float p26;
    int32_t p27;
    int32_t p28;
};
    
// VisibleReflectionProbe
struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    float p22;
    float p23;
    float p24;
    float p25;
    float p26;
    float p27;
    float p28;
    float p29;
    int32_t p30;
    int32_t p31;
    int32_t p32;
    int32_t p33;
};
    
// GlobalKeyword
struct s_su4_
{
    void* p0;
    uint32_t p1;
};
    
// LocalKeyword
struct s_psu4_
{
    void* p0;
    void* p1;
    uint32_t p2;
};
    
// PlatformKeywordSet
struct s_u8_
{
    uint64_t p0;
};
    
// ShaderKeyword
struct s_su4bbb_
{
    void* p0;
    uint32_t p1;
    bool p2;
    bool p3;
    bool p4;
};
    
// ShaderKeywordSet
struct s_pppu8_
{
    void* p0;
    void* p1;
    void* p2;
    uint64_t p3;
};
    
// RendererList
struct s_pu4u4_
{
    void* p0;
    uint32_t p1;
    uint32_t p2;
};
    
// RendererListDesc
struct s_i4i4i4i4bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4obi4i4pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4oi4o_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    bool p4;
    uint8_t p5;
    uint8_t p6;
    uint8_t p7;
    uint8_t p8;
    uint8_t p9;
    uint8_t p10;
    uint8_t p11;
    uint8_t p12;
    uint8_t p13;
    uint8_t p14;
    uint8_t p15;
    uint8_t p16;
    uint8_t p17;
    uint8_t p18;
    uint8_t p19;
    uint8_t p20;
    uint8_t p21;
    uint8_t p22;
    uint8_t p23;
    uint8_t p24;
    uint8_t p25;
    uint8_t p26;
    uint8_t p27;
    uint8_t p28;
    uint8_t p29;
    uint8_t p30;
    uint8_t p31;
    uint8_t p32;
    uint8_t p33;
    uint8_t p34;
    uint8_t p35;
    uint8_t p36;
    uint8_t p37;
    uint8_t p38;
    uint8_t p39;
    uint8_t p40;
    uint8_t p41;
    uint8_t p42;
    uint8_t p43;
    uint8_t p44;
    uint8_t p45;
    uint8_t p46;
    uint8_t p47;
    uint8_t p48;
    uint8_t p49;
    uint8_t p50;
    uint8_t p51;
    uint8_t p52;
    uint8_t p53;
    uint8_t p54;
    uint8_t p55;
    uint8_t p56;
    uint8_t p57;
    uint8_t p58;
    uint8_t p59;
    uint8_t p60;
    uint8_t p61;
    uint8_t p62;
    uint8_t p63;
    uint8_t p64;
    uint8_t p65;
    uint8_t p66;
    uint8_t p67;
    uint8_t p68;
    uint8_t p69;
    uint8_t p70;
    int16_t p71;
    int32_t p72;
    int32_t p73;
    float p74;
    uint8_t p75;
    uint8_t p76;
    uint8_t p77;
    uint8_t p78;
    uint8_t p79;
    int8_t p80;
    uint8_t p81;
    uint8_t p82;
    uint8_t p83;
    uint8_t p84;
    uint8_t p85;
    uint8_t p86;
    uint8_t p87;
    uint8_t p88;
    uint8_t p89;
    uint8_t p90;
    uint8_t p91;
    uint8_t p92;
    int32_t p93;
    int32_t p94;
    void* p95;
    bool p96;
    int32_t p97;
    int32_t p98;
    void* p99;
    struct s_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_* p100;
    void* p101;
    int32_t p102;
    int32_t p103;
    void* p104;
    int32_t p105;
    void* p106;
};
    
// FrameData
struct s_u8r8r4r4r8r4r4i4pu4_
{
    uint64_t p0;
    double p1;
    float p2;
    float p3;
    double p4;
    float p5;
    float p6;
    int32_t p7;
    void* p8;
    uint32_t p9;
};
    
// Playable
struct s_pu4_
{
    void* p0;
    uint32_t p1;
};
    
// PlayableBinding
struct s_sooo_
{
    void* p0;
    void* p1;
    void* p2;
    void* p3;
};
    
// DirectionalLight
struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_
{
    int32_t p0;
    bool p1;
    uint8_t p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
};
    
// PointLight
struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_
{
    int32_t p0;
    bool p1;
    uint8_t p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    uint8_t p20;
};
    
// SpotLight
struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_
{
    int32_t p0;
    bool p1;
    uint8_t p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    uint8_t p22;
    uint8_t p23;
};
    
// RectangleLight
struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_
{
    int32_t p0;
    bool p1;
    uint8_t p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    uint8_t p21;
};
    
// SpotLightBoxShape
struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_
{
    int32_t p0;
    bool p1;
    uint8_t p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
};
    
// Cookie
struct s_i4r4r4r4_
{
    int32_t p0;
    float p1;
    float p2;
    float p3;
};
    
// LightDataGI
struct s_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1u1u1_
{
    int32_t p0;
    int32_t p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    float p21;
    float p22;
    uint8_t p23;
    uint8_t p24;
    uint8_t p25;
    uint8_t p26;
};
    
// CoveredSequencePoint
struct s_ou4u4su4u4_
{
    void* p0;
    uint32_t p1;
    uint32_t p2;
    void* p3;
    uint32_t p4;
    uint32_t p5;
};
    
// CoveredMethodStats
struct s_oi4i4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
};
    
// GIMsg
struct s_i4o_
{
    int32_t p0;
    void* p1;
};
    
// RawMsg
struct s_i4i4ss_
{
    int32_t p0;
    int32_t p1;
    void* p2;
    void* p3;
};
    
// PhyHitInfo
struct s_i8i8i8i8i8i8i8_
{
    int64_t p0;
    int64_t p1;
    int64_t p2;
    int64_t p3;
    int64_t p4;
    int64_t p5;
    int64_t p6;
};
    
// F64
struct s_i8_
{
    int64_t p0;
};
    
// FVector3
struct s_i8i8i8_
{
    int64_t p0;
    int64_t p1;
    int64_t p2;
};
    
// FQuaterion
struct s_i8i8i8i8_
{
    int64_t p0;
    int64_t p1;
    int64_t p2;
    int64_t p3;
};
    
// NavBuildSetting
struct s_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_
{
    int64_t p0;
    int64_t p1;
    int64_t p2;
    int64_t p3;
    int64_t p4;
    int64_t p5;
    int64_t p6;
    int64_t p7;
    int64_t p8;
    int64_t p9;
    int64_t p10;
    int64_t p11;
    int64_t p12;
    int64_t p13;
};
    
// Nullable`1
struct s_bi4i4_
{
    bool p0;
    int32_t p1;
    int32_t p2;
};
    
// Nullable`1
struct s_br4r4r4r4_
{
    bool p0;
    float p1;
    float p2;
    float p3;
    float p4;
};
    
// Nullable`1
struct s_bi4i4i4i4_
{
    bool p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    int32_t p4;
};
    
// RaycastHit
struct s_r4r4r4r4r4r4u4r4r4r4i4_
{
    float p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    uint32_t p6;
    float p7;
    float p8;
    float p9;
    int32_t p10;
};
    
// Nullable`1
struct s_br4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_
{
    bool p0;
    float p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
};
    
// NativeArray`1
struct s_Pvi4i4i4pi4i4oi4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
    int32_t p8;
};
    
// NativeSlice`1
struct s_Pu1i4i4i4i4pi4i4_
{
    uint8_t* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    int32_t p4;
    void* p5;
    int32_t p6;
    int32_t p7;
};
    
// Guid
struct s_i4i2i2u1u1u1u1u1u1u1u1_
{
    int32_t p0;
    int16_t p1;
    int16_t p2;
    uint8_t p3;
    uint8_t p4;
    uint8_t p5;
    uint8_t p6;
    uint8_t p7;
    uint8_t p8;
    uint8_t p9;
    uint8_t p10;
};
    
// ProfilerCategory
struct s_u2_
{
    uint16_t p0;
};
    
// StreamingContext
struct s_Oi4_
{
    void* p0;
    int32_t p1;
};
    
// Void
struct v
{
};
    
// Enumerator
struct s_oi4i4i4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
};
    
// Enumerator
struct s_oi4i4s_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    void* p3;
};
    
// Enumerator
struct s_oi4i4O_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    void* p3;
};
    
// Enumerator
struct s_oi4i4soi4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    void* p3;
    void* p4;
    int32_t p5;
};
    
// Enumerator
struct s_oi4i4i4oi4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
};
    
// Nullable`1
struct s_bi4o_
{
    bool p0;
    int32_t p1;
    void* p2;
};
    
// Nullable`1
struct s_bi4u1u1u1u1_
{
    bool p0;
    int32_t p1;
    uint8_t p2;
    uint8_t p3;
    uint8_t p4;
    uint8_t p5;
};
    
// Nullable`1
struct s_bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_
{
    bool p0;
    uint8_t p1;
    uint8_t p2;
    uint8_t p3;
    uint8_t p4;
    uint8_t p5;
    uint8_t p6;
    uint8_t p7;
    uint8_t p8;
    uint8_t p9;
    uint8_t p10;
    uint8_t p11;
    uint8_t p12;
    uint8_t p13;
    uint8_t p14;
    uint8_t p15;
    uint8_t p16;
    uint8_t p17;
    uint8_t p18;
    uint8_t p19;
    uint8_t p20;
    uint8_t p21;
    uint8_t p22;
    uint8_t p23;
    uint8_t p24;
    uint8_t p25;
    uint8_t p26;
    uint8_t p27;
    uint8_t p28;
    uint8_t p29;
    uint8_t p30;
    uint8_t p31;
    uint8_t p32;
    uint8_t p33;
    uint8_t p34;
    uint8_t p35;
    uint8_t p36;
    uint8_t p37;
    uint8_t p38;
    uint8_t p39;
    uint8_t p40;
    uint8_t p41;
    uint8_t p42;
    uint8_t p43;
    uint8_t p44;
    uint8_t p45;
    uint8_t p46;
    uint8_t p47;
    uint8_t p48;
    uint8_t p49;
    uint8_t p50;
    uint8_t p51;
    uint8_t p52;
    uint8_t p53;
    uint8_t p54;
    uint8_t p55;
    uint8_t p56;
    uint8_t p57;
    uint8_t p58;
    uint8_t p59;
    uint8_t p60;
    uint8_t p61;
    uint8_t p62;
    uint8_t p63;
    uint8_t p64;
    uint8_t p65;
    uint8_t p66;
    int16_t p67;
    int32_t p68;
    int32_t p69;
    float p70;
    uint8_t p71;
    uint8_t p72;
    uint8_t p73;
    uint8_t p74;
    uint8_t p75;
    int8_t p76;
    uint8_t p77;
    uint8_t p78;
    uint8_t p79;
    uint8_t p80;
    uint8_t p81;
    uint8_t p82;
    uint8_t p83;
    uint8_t p84;
    uint8_t p85;
    uint8_t p86;
    uint8_t p87;
    uint8_t p88;
    int32_t p89;
    int32_t p90;
};
    
// NativeOverlapped
struct s_ppi4i4p_
{
    void* p0;
    void* p1;
    int32_t p2;
    int32_t p3;
    void* p4;
};
    
// MeshGeneratorBuffers
struct s_i4oooo_
{
    int32_t p0;
    void* p1;
    void* p2;
    void* p3;
    void* p4;
};
    
// AsyncLocalValueChangedArgs`1
struct s_oob_
{
    void* p0;
    void* p1;
    bool p2;
};
    
// FileSystemEntry
struct s_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_
{
    struct s_u4u4i8i8i8i8i8i8i4u4u4c_* p0;
    void* p1;
    int32_t p2;
    void* p3;
    int32_t p4;
    void* p5;
    int32_t p6;
};
    
// TimerState
struct s_i8i8_
{
    int64_t p0;
    int64_t p1;
};
    
// XRNodeState
struct s_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_
{
    int32_t p0;
    int32_t p1;
    float p2;
    float p3;
    float p4;
    float p5;
    float p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
    float p17;
    float p18;
    float p19;
    float p20;
    int32_t p21;
    uint64_t p22;
};
    
// InputDevice
struct s_u8b_
{
    uint64_t p0;
    bool p1;
};
    
// MeshGenerationResult
struct s_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_
{
    uint64_t p0;
    uint64_t p1;
    void* p2;
    void* p3;
    int32_t p4;
    int32_t p5;
    uint64_t p6;
    float p7;
    float p8;
    float p9;
    float p10;
    float p11;
    float p12;
    float p13;
    float p14;
    float p15;
    float p16;
};
    
// BuildPlayerOptions
struct s_ossi4i4i4i4o_
{
    void* p0;
    void* p1;
    void* p2;
    int32_t p3;
    int32_t p4;
    int32_t p5;
    int32_t p6;
    void* p7;
};
    
// CameraMode
struct s_i4ss_
{
    int32_t p0;
    void* p1;
    void* p2;
};
    
// ObjectChangeEventStream
struct s_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_
{
    void* p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    void* p4;
    int32_t p5;
    int32_t p6;
    void* p7;
    int32_t p8;
    void* p9;
    int32_t p10;
    int32_t p11;
    int32_t p12;
    void* p13;
    int32_t p14;
    int32_t p15;
    void* p16;
    int32_t p17;
};
    
// ActiveProfileChangedEventArgs
struct s_ss_
{
    void* p0;
    void* p1;
};
    
// ShortcutBindingChangedEventArgs
struct s_soo_
{
    void* p0;
    void* p1;
    void* p2;
};
    
// ObjectSelectorTargetInfo
struct s_u8u8u4u4u4u4i4oo_
{
    uint64_t p0;
    uint64_t p1;
    uint32_t p2;
    uint32_t p3;
    uint32_t p4;
    uint32_t p5;
    int32_t p6;
    void* p7;
    void* p8;
};
    
// SubSceneInfo
struct s_oi4osi4u1u1u1u1_
{
    void* p0;
    int32_t p1;
    void* p2;
    void* p3;
    int32_t p4;
    uint8_t p5;
    uint8_t p6;
    uint8_t p7;
    uint8_t p8;
};
    
// TouchEvent
struct s_i4r4r4i4_
{
    int32_t p0;
    float p1;
    float p2;
    int32_t p3;
};
    
// NodeCreationContext
struct s_r4r4oi4_
{
    float p0;
    float p1;
    void* p2;
    int32_t p3;
};
    
// GraphViewChange
struct s_ooor4r4_
{
    void* p0;
    void* p1;
    void* p2;
    float p3;
    float p4;
};
    
// SearchColumnEventArgs
struct s_oooObr4r4r4r4bb_
{
    void* p0;
    void* p1;
    void* p2;
    void* p3;
    bool p4;
    float p5;
    float p6;
    float p7;
    float p8;
    bool p9;
    bool p10;
};
    
// SearchColumnCompareArgs
struct s_oooObr4r4r4r4bboooObr4r4r4r4bbb_
{
    void* p0;
    void* p1;
    void* p2;
    void* p3;
    bool p4;
    float p5;
    float p6;
    float p7;
    float p8;
    bool p9;
    bool p10;
    void* p11;
    void* p12;
    void* p13;
    void* p14;
    bool p15;
    float p16;
    float p17;
    float p18;
    float p19;
    bool p20;
    bool p21;
    bool p22;
};
    
// EventHook
struct s_sOO_
{
    void* p0;
    void* p1;
    void* p2;
};
    
// EditorCurveBinding
struct s_sosi4i4i4i4i4_
{
    void* p0;
    void* p1;
    void* p2;
    int32_t p3;
    int32_t p4;
    int32_t p5;
    int32_t p6;
    int32_t p7;
};
    
// ParseResult`1
struct s_bo_
{
    bool p0;
    void* p1;
};
    
// Nullable`1
struct s_bi4_
{
    bool p0;
    int32_t p1;
};
    
// Nullable`1
struct s_bi8_
{
    bool p0;
    int64_t p1;
};
    
// Nullable`1
struct s_br4_
{
    bool p0;
    float p1;
};
    
// Nullable`1
struct s_br8_
{
    bool p0;
    double p1;
};
    
// Decimal
struct s_i4i4i4i4u8_
{
    int32_t p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    uint64_t p4;
};
    
// Nullable`1
struct s_bi4i4i4i4u8_
{
    bool p0;
    int32_t p1;
    int32_t p2;
    int32_t p3;
    int32_t p4;
    uint64_t p5;
};
    


// System.Object GetItemAssetByURL(System.String)
static bool w_Os(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_Os");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Object GetItemAsset(System.String, System.String)
static bool w_Oss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_Oss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Object get_initiator()
static bool w_Ot(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_Ot");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Object DynamicInvoke(System.Object[])
static bool w_OtVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_OtVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal ref params
    void* p0 = RestArguments<void*>::PackRef(context, info, TIp0, 0);
                

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Object Get(Int32)
static bool w_Oti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_Oti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Object GetItemAsset(FairyGUI.PackageItem)
static bool w_Oto(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_Oto");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Object GetItemAsset(System.String)
static bool w_Ots(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_Ots");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.Object& Address(Int32)
static bool w_POti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_POti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void** (*FuncToCall)(void*,int32_t p0, const void* method);
    void** ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    // unknow ret signature: PO
    return true;
}

// Boolean get_touchScreen()
static bool w_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef bool (*FuncToCall)(const void* method);
    bool ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CollectIncremental(UInt64)
static bool w_bDu8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bDu8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<uint64_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal primitive with default
    uint64_t p0 = OptionalParameter<uint64_t>::GetPrimitive(context, info, method, 0);
                

    typedef bool (*FuncToCall)(uint64_t p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsTweening(System.Object)
static bool w_bO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef bool (*FuncToCall)(void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsTweening(System.Object, FairyGUI.TweenPropType)
static bool w_bOi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bOi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void* p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsKeywordEnabled(UnityEngine.Rendering.GlobalKeyword ByRef)
static bool w_bPs_su4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bPs_su4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_su4_* p0 = nullptr; // valuetype ref
    s_su4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_su4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(struct s_su4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean StartRecording(Boolean)
static bool w_bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(bool p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean StartRecording(Boolean, Boolean)
static bool w_bbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bbb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(bool p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsArabicLetter(Char)
static bool w_bc(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bc");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(Il2CppChar p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsValid(Int32)
static bool w_bi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(int32_t p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SupportsVertexAttributeFormat(UnityEngine.Rendering.VertexAttributeFormat, Int32)
static bool w_bi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bi4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsPlaying(UnityEngine.Object)
static bool w_bo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bo");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef bool (*FuncToCall)(void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryCreatePlaneFromPolygon(UnityEngine.Vector3[], UnityEngine.Plane ByRef)
static bool w_boPs_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_boPs_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Pstruct
    s_r4r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void* p0, struct s_r4r4r4r4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean GetRaycastHitFromCache(UnityEngine.Camera, UnityEngine.RaycastHit ByRef)
static bool w_boPs_r4r4r4r4r4r4u4r4r4r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_boPs_r4r4r4r4r4r4u4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean PeekRemoteAudioCapture(Single[], Int32)
static bool w_boi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_boi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void* p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean GenerateAtlas(UnityEngine.Vector2[], Int32, Int32, System.Collections.Generic.List`1[UnityEngine.Rect])
static bool w_boi4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_boi4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef bool (*FuncToCall)(void* p0, int32_t p1, int32_t p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean ConvertTexture(UnityEngine.Texture, Int32, UnityEngine.Texture, Int32)
static bool w_boi4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_boi4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef bool (*FuncToCall)(void* p0, int32_t p1, void* p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean ConvertTexture(UnityEngine.Texture, UnityEngine.Texture)
static bool w_boo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_boo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef bool (*FuncToCall)(void* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean BlendCubemap(UnityEngine.Texture, UnityEngine.Texture, Single, UnityEngine.RenderTexture)
static bool w_boor4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_boor4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef bool (*FuncToCall)(void* p0, void* p1, float p2, void* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TestPlanesAABB(UnityEngine.Plane[], UnityEngine.Bounds)
static bool w_bos_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bos_r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Approximately(Single, Single)
static bool w_br4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_br4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(float p0, float p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean AreEqual(Single, Single, Single)
static bool w_br4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_br4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef bool (*FuncToCall)(float p0, float p1, float p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean ShowCameraPreviewAt(Single, Single, Single, Single)
static bool w_br4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_br4r4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef bool (*FuncToCall)(float p0, float p1, float p2, float p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean ContainsArabicLetters(System.String)
static bool w_bs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef bool (*FuncToCall)(void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryParseHtmlString(System.String, UnityEngine.Color ByRef)
static bool w_bsPs_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bsPs_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal Pstruct
    s_r4r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void* p0, struct s_r4r4r4r4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Inequality(UnityEngine.Rendering.SortingLayerRange, UnityEngine.Rendering.SortingLayerRange)
static bool w_bs_i2i2_s_i2i2_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_i2i2_s_i2i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i2i2_* pp0 = DataTransfer::GetPointer<s_i2i2_>(context, info[0]);
    s_i2i2_ p0 = pp0 ? *pp0 : s_i2i2_ {};
    // JSValToCSVal struct
    s_i2i2_* pp1 = DataTransfer::GetPointer<s_i2i2_>(context, info[1]);
    s_i2i2_ p1 = pp1 ? *pp1 : s_i2i2_ {};

    typedef bool (*FuncToCall)(struct s_i2i2_ p0, struct s_i2i2_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean RemoveCache(UnityEngine.Cache)
static bool w_bs_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4_* pp0 = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p0 = pp0 ? *pp0 : s_i4_ {};

    typedef bool (*FuncToCall)(struct s_i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Cache, UnityEngine.Cache)
static bool w_bs_i4_s_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_i4_s_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4_* pp0 = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p0 = pp0 ? *pp0 : s_i4_ {};
    // JSValToCSVal struct
    s_i4_* pp1 = DataTransfer::GetPointer<s_i4_>(context, info[1]);
    s_i4_ p1 = pp1 ? *pp1 : s_i4_ {};

    typedef bool (*FuncToCall)(struct s_i4_ p0, struct s_i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsNullOrEmpty(UnityEngine.PropertyName)
static bool w_bs_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4_>(context, info[0]);
    s_i4i4_ p0 = pp0 ? *pp0 : s_i4i4_ {};

    typedef bool (*FuncToCall)(struct s_i4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Vector2Int, UnityEngine.Vector2Int)
static bool w_bs_i4i4_s_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_i4i4_s_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4_>(context, info[0]);
    s_i4i4_ p0 = pp0 ? *pp0 : s_i4i4_ {};
    // JSValToCSVal struct
    s_i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4_>(context, info[1]);
    s_i4i4_ p1 = pp1 ? *pp1 : s_i4i4_ {};

    typedef bool (*FuncToCall)(struct s_i4i4_ p0, struct s_i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Vector3Int, UnityEngine.Vector3Int)
static bool w_bs_i4i4i4_s_i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_i4i4i4_s_i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4_>(context, info[0]);
    s_i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4_ {};
    // JSValToCSVal struct
    s_i4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4_>(context, info[1]);
    s_i4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4_ {};

    typedef bool (*FuncToCall)(struct s_i4i4i4_ p0, struct s_i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.VertexAttributeDescriptor, UnityEngine.Rendering.VertexAttributeDescriptor)
static bool w_bs_i4i4i4i4_s_i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_i4i4i4i4_s_i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4i4_>(context, info[0]);
    s_i4i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4i4_ {};
    // JSValToCSVal struct
    s_i4i4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4i4_>(context, info[1]);
    s_i4i4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4i4_ {};

    typedef bool (*FuncToCall)(struct s_i4i4i4i4_ p0, struct s_i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.BoundsInt, UnityEngine.BoundsInt)
static bool w_bs_i4i4i4i4i4i4_s_i4i4i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_i4i4i4i4i4i4_s_i4i4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4i4i4i4_>(context, info[0]);
    s_i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4i4i4i4_ {};
    // JSValToCSVal struct
    s_i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4i4i4i4_>(context, info[1]);
    s_i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4i4i4i4_ {};

    typedef bool (*FuncToCall)(struct s_i4i4i4i4i4i4_ p0, struct s_i4i4i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.AttachmentDescriptor, UnityEngine.Rendering.AttachmentDescriptor)
static bool w_bs_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_* pp0 = DataTransfer::GetPointer<s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_>(context, info[0]);
    s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_ p0 = pp0 ? *pp0 : s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_ {};
    // JSValToCSVal struct
    s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_* pp1 = DataTransfer::GetPointer<s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_>(context, info[1]);
    s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_ p1 = pp1 ? *pp1 : s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_ {};

    typedef bool (*FuncToCall)(struct s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_ p0, struct s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier)
static bool w_bs_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};

    typedef bool (*FuncToCall)(struct s_i4i4i4pi4i4i4_ p0, struct s_i4i4i4pi4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.FilteringSettings, UnityEngine.Rendering.FilteringSettings)
static bool w_bs_i4i4i4u4i4i2i2_s_i4i4i4u4i4i2i2_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_i4i4i4u4i4i2i2_s_i4i4i4u4i4i2i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4i4u4i4i2i2_* pp0 = DataTransfer::GetPointer<s_i4i4i4u4i4i2i2_>(context, info[0]);
    s_i4i4i4u4i4i2i2_ p0 = pp0 ? *pp0 : s_i4i4i4u4i4i2i2_ {};
    // JSValToCSVal struct
    s_i4i4i4u4i4i2i2_* pp1 = DataTransfer::GetPointer<s_i4i4i4u4i4i2i2_>(context, info[1]);
    s_i4i4i4u4i4i2i2_ p1 = pp1 ? *pp1 : s_i4i4i4u4i4i2i2_ {};

    typedef bool (*FuncToCall)(struct s_i4i4i4u4i4i2i2_ p0, struct s_i4i4i4u4i4i2i2_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.ScriptableCullingParameters, UnityEngine.Rendering.ScriptableCullingParameters)
static bool w_bs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_* pp0 = DataTransfer::GetPointer<s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_>(context, info[0]);
    s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_ p0 = pp0 ? *pp0 : s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_ {};
    // JSValToCSVal struct
    s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_* pp1 = DataTransfer::GetPointer<s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_>(context, info[1]);
    s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_ p1 = pp1 ? *pp1 : s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_ {};

    typedef bool (*FuncToCall)(struct s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_ p0, struct s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.RasterState, UnityEngine.Rendering.RasterState)
static bool w_bs_i4i4r4u1u1u1u1_s_i4i4r4u1u1u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_i4i4r4u1u1u1u1_s_i4i4r4u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4r4u1u1u1u1_* pp0 = DataTransfer::GetPointer<s_i4i4r4u1u1u1u1_>(context, info[0]);
    s_i4i4r4u1u1u1u1_ p0 = pp0 ? *pp0 : s_i4i4r4u1u1u1u1_ {};
    // JSValToCSVal struct
    s_i4i4r4u1u1u1u1_* pp1 = DataTransfer::GetPointer<s_i4i4r4u1u1u1u1_>(context, info[1]);
    s_i4i4r4u1u1u1u1_ p1 = pp1 ? *pp1 : s_i4i4r4u1u1u1u1_ {};

    typedef bool (*FuncToCall)(struct s_i4i4r4u1u1u1u1_ p0, struct s_i4i4r4u1u1u1u1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.LODParameters, UnityEngine.Rendering.LODParameters)
static bool w_bs_i4r4r4r4r4r4i4_s_i4r4r4r4r4r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_i4r4r4r4r4r4i4_s_i4r4r4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4r4r4r4r4r4i4_* pp0 = DataTransfer::GetPointer<s_i4r4r4r4r4r4i4_>(context, info[0]);
    s_i4r4r4r4r4r4i4_ p0 = pp0 ? *pp0 : s_i4r4r4r4r4r4i4_ {};
    // JSValToCSVal struct
    s_i4r4r4r4r4r4i4_* pp1 = DataTransfer::GetPointer<s_i4r4r4r4r4r4i4_>(context, info[1]);
    s_i4r4r4r4r4r4i4_ p1 = pp1 ? *pp1 : s_i4r4r4r4r4r4i4_ {};

    typedef bool (*FuncToCall)(struct s_i4r4r4r4r4r4i4_ p0, struct s_i4r4r4r4r4r4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.VisibleLight, UnityEngine.Rendering.VisibleLight)
static bool w_bs_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_* pp0 = DataTransfer::GetPointer<s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_>(context, info[0]);
    s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_ p0 = pp0 ? *pp0 : s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_ {};
    // JSValToCSVal struct
    s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_* pp1 = DataTransfer::GetPointer<s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_>(context, info[1]);
    s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_ p1 = pp1 ? *pp1 : s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_ {};

    typedef bool (*FuncToCall)(struct s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_ p0, struct s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.ShadowSplitData, UnityEngine.Rendering.ShadowSplitData)
static bool w_bs_i4u1r4r4r4r4r4r4_s_i4u1r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_i4u1r4r4r4r4r4r4_s_i4u1r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4u1r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_i4u1r4r4r4r4r4r4_>(context, info[0]);
    s_i4u1r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_i4u1r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    s_i4u1r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_i4u1r4r4r4r4r4r4_>(context, info[1]);
    s_i4u1r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_i4u1r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_i4u1r4r4r4r4r4r4_ p0, struct s_i4u1r4r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.CullingResults, UnityEngine.Rendering.CullingResults)
static bool w_bs_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_* pp0 = DataTransfer::GetPointer<s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_>(context, info[0]);
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p0 = pp0 ? *pp0 : s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ {};
    // JSValToCSVal struct
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_* pp1 = DataTransfer::GetPointer<s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_>(context, info[1]);
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p1 = pp1 ? *pp1 : s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ {};

    typedef bool (*FuncToCall)(struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p0, struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.ShadowDrawingSettings, UnityEngine.Rendering.ShadowDrawingSettings)
static bool w_bs_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_* pp0 = DataTransfer::GetPointer<s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_>(context, info[0]);
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_ p0 = pp0 ? *pp0 : s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_ {};
    // JSValToCSVal struct
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_* pp1 = DataTransfer::GetPointer<s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_>(context, info[1]);
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_ p1 = pp1 ? *pp1 : s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_ {};

    typedef bool (*FuncToCall)(struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_ p0, struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.LocalKeywordSpace, UnityEngine.Rendering.LocalKeywordSpace)
static bool w_bs_p_s_p_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_p_s_p_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_p_* pp0 = DataTransfer::GetPointer<s_p_>(context, info[0]);
    s_p_ p0 = pp0 ? *pp0 : s_p_ {};
    // JSValToCSVal struct
    s_p_* pp1 = DataTransfer::GetPointer<s_p_>(context, info[1]);
    s_p_ p1 = pp1 ? *pp1 : s_p_ {};

    typedef bool (*FuncToCall)(struct s_p_ p0, struct s_p_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.ScriptableRenderContext, UnityEngine.Rendering.ScriptableRenderContext)
static bool w_bs_ppi4i4_s_ppi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_ppi4i4_s_ppi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_ppi4i4_* pp0 = DataTransfer::GetPointer<s_ppi4i4_>(context, info[0]);
    s_ppi4i4_ p0 = pp0 ? *pp0 : s_ppi4i4_ {};
    // JSValToCSVal struct
    s_ppi4i4_* pp1 = DataTransfer::GetPointer<s_ppi4i4_>(context, info[1]);
    s_ppi4i4_ p1 = pp1 ? *pp1 : s_ppi4i4_ {};

    typedef bool (*FuncToCall)(struct s_ppi4i4_ p0, struct s_ppi4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.LocalKeyword, UnityEngine.Rendering.LocalKeyword)
static bool w_bs_psu4_s_psu4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_psu4_s_psu4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_psu4_* pp0 = DataTransfer::GetPointer<s_psu4_>(context, info[0]);
    s_psu4_ p0 = pp0 ? *pp0 : s_psu4_ {};
    // JSValToCSVal struct
    s_psu4_* pp1 = DataTransfer::GetPointer<s_psu4_>(context, info[1]);
    s_psu4_ p1 = pp1 ? *pp1 : s_psu4_ {};

    typedef bool (*FuncToCall)(struct s_psu4_ p0, struct s_psu4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Playables.PlayableHandle, UnityEngine.Playables.PlayableHandle)
static bool w_bs_pu4_s_pu4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_pu4_s_pu4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_pu4_* pp0 = DataTransfer::GetPointer<s_pu4_>(context, info[0]);
    s_pu4_ p0 = pp0 ? *pp0 : s_pu4_ {};
    // JSValToCSVal struct
    s_pu4_* pp1 = DataTransfer::GetPointer<s_pu4_>(context, info[1]);
    s_pu4_ p1 = pp1 ? *pp1 : s_pu4_ {};

    typedef bool (*FuncToCall)(struct s_pu4_ p0, struct s_pu4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.BoneWeight1, UnityEngine.BoneWeight1)
static bool w_bs_r4i4_s_r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4i4_s_r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4i4_* pp0 = DataTransfer::GetPointer<s_r4i4_>(context, info[0]);
    s_r4i4_ p0 = pp0 ? *pp0 : s_r4i4_ {};
    // JSValToCSVal struct
    s_r4i4_* pp1 = DataTransfer::GetPointer<s_r4i4_>(context, info[1]);
    s_r4i4_ p1 = pp1 ? *pp1 : s_r4i4_ {};

    typedef bool (*FuncToCall)(struct s_r4i4_ p0, struct s_r4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Vector2, UnityEngine.Vector2)
static bool w_bs_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_bs_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Inequality(UnityEngine.Rect, UnityEngine.Rect)
static bool w_bs_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.BoneWeight, UnityEngine.BoneWeight)
static bool w_bs_r4r4r4r4i4i4i4i4_s_r4r4r4r4i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4i4i4i4i4_s_r4r4r4r4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4i4i4i4i4_>(context, info[0]);
    s_r4r4r4r4i4i4i4i4_ p0 = pp0 ? *pp0 : s_r4r4r4r4i4i4i4i4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4i4i4i4i4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4i4i4i4i4_>(context, info[1]);
    s_r4r4r4r4i4i4i4i4_ p1 = pp1 ? *pp1 : s_r4r4r4r4i4i4i4i4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4r4i4i4i4i4_ p0, struct s_r4r4r4r4i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Bounds, UnityEngine.Bounds)
static bool w_bs_r4r4r4r4r4r4_s_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4_s_r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Pose, UnityEngine.Pose)
static bool w_bs_r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Inverse3DAffine(UnityEngine.Matrix4x4, UnityEngine.Matrix4x4 ByRef)
static bool w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Matrix4x4, UnityEngine.Matrix4x4)
static bool w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.SortingSettings, UnityEngine.Rendering.SortingSettings)
static bool w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.DrawingSettings, UnityEngine.Rendering.DrawingSettings)
static bool w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.SphericalHarmonicsL2, UnityEngine.Rendering.SphericalHarmonicsL2)
static bool w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.VisibleReflectionProbe, UnityEngine.Rendering.VisibleReflectionProbe)
static bool w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.CameraProperties, UnityEngine.Rendering.CameraProperties)
static bool w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_ {};

    typedef bool (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsKeywordLocal(UnityEngine.Rendering.ShaderKeyword)
static bool w_bs_su4bbb_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_su4bbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_su4bbb_* pp0 = DataTransfer::GetPointer<s_su4bbb_>(context, info[0]);
    s_su4bbb_ p0 = pp0 ? *pp0 : s_su4bbb_ {};

    typedef bool (*FuncToCall)(struct s_su4bbb_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsVersionCached(UnityEngine.CachedAssetBundle)
static bool w_bs_su8u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_su8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_su8u8_* pp0 = DataTransfer::GetPointer<s_su8u8_>(context, info[0]);
    s_su8u8_ p0 = pp0 ? *pp0 : s_su8u8_ {};

    typedef bool (*FuncToCall)(struct s_su8u8_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.DepthState, UnityEngine.Rendering.DepthState)
static bool w_bs_u1i1_s_u1i1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_u1i1_s_u1i1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_u1i1_* pp0 = DataTransfer::GetPointer<s_u1i1_>(context, info[0]);
    s_u1i1_ p0 = pp0 ? *pp0 : s_u1i1_ {};
    // JSValToCSVal struct
    s_u1i1_* pp1 = DataTransfer::GetPointer<s_u1i1_>(context, info[1]);
    s_u1i1_ p1 = pp1 ? *pp1 : s_u1i1_ {};

    typedef bool (*FuncToCall)(struct s_u1i1_ p0, struct s_u1i1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.RenderTargetBlendState, UnityEngine.Rendering.RenderTargetBlendState)
static bool w_bs_u1u1u1u1u1u1u1u1_s_u1u1u1u1u1u1u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_u1u1u1u1u1u1u1u1_s_u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<s_u1u1u1u1u1u1u1u1_>(context, info[0]);
    s_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : s_u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal struct
    s_u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<s_u1u1u1u1u1u1u1u1_>(context, info[1]);
    s_u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : s_u1u1u1u1u1u1u1u1_ {};

    typedef bool (*FuncToCall)(struct s_u1u1u1u1u1u1u1u1_ p0, struct s_u1u1u1u1u1u1u1u1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.StencilState, UnityEngine.Rendering.StencilState)
static bool w_bs_u1u1u1u1u1u1u1u1u1u1u1u1_s_u1u1u1u1u1u1u1u1u1u1u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_u1u1u1u1u1u1u1u1u1u1u1u1_s_u1u1u1u1u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_u1u1u1u1u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<s_u1u1u1u1u1u1u1u1u1u1u1u1_>(context, info[0]);
    s_u1u1u1u1u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : s_u1u1u1u1u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal struct
    s_u1u1u1u1u1u1u1u1u1u1u1u1_* pp1 = DataTransfer::GetPointer<s_u1u1u1u1u1u1u1u1u1u1u1u1_>(context, info[1]);
    s_u1u1u1u1u1u1u1u1u1u1u1u1_ p1 = pp1 ? *pp1 : s_u1u1u1u1u1u1u1u1u1u1u1u1_ {};

    typedef bool (*FuncToCall)(struct s_u1u1u1u1u1u1u1u1u1u1u1u1_ p0, struct s_u1u1u1u1u1u1u1u1u1u1u1u1_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.BlendState, UnityEngine.Rendering.BlendState)
static bool w_bs_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_* pp0 = DataTransfer::GetPointer<s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_>(context, info[0]);
    s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_ p0 = pp0 ? *pp0 : s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_ {};
    // JSValToCSVal struct
    s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_* pp1 = DataTransfer::GetPointer<s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_>(context, info[1]);
    s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_ p1 = pp1 ? *pp1 : s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_ {};

    typedef bool (*FuncToCall)(struct s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_ p0, struct s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.RenderStateBlock, UnityEngine.Rendering.RenderStateBlock)
static bool w_bs_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_* pp0 = DataTransfer::GetPointer<s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_>(context, info[0]);
    s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_ p0 = pp0 ? *pp0 : s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_ {};
    // JSValToCSVal struct
    s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_* pp1 = DataTransfer::GetPointer<s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_>(context, info[1]);
    s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_ p1 = pp1 ? *pp1 : s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_ {};

    typedef bool (*FuncToCall)(struct s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_ p0, struct s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsCategoryEnabled(Unity.Profiling.ProfilerCategory)
static bool w_bs_u2_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_u2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_u2_* pp0 = DataTransfer::GetPointer<s_u2_>(context, info[0]);
    s_u2_ p0 = pp0 ? *pp0 : s_u2_ {};

    typedef bool (*FuncToCall)(struct s_u2_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Rendering.PassIdentifier, UnityEngine.Rendering.PassIdentifier)
static bool w_bs_u4u4_s_u4u4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_u4u4_s_u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_u4u4_* pp0 = DataTransfer::GetPointer<s_u4u4_>(context, info[0]);
    s_u4u4_ p0 = pp0 ? *pp0 : s_u4u4_ {};
    // JSValToCSVal struct
    s_u4u4_* pp1 = DataTransfer::GetPointer<s_u4u4_>(context, info[1]);
    s_u4u4_ p1 = pp1 ? *pp1 : s_u4u4_ {};

    typedef bool (*FuncToCall)(struct s_u4u4_ p0, struct s_u4u4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean op_Equality(UnityEngine.Hash128, UnityEngine.Hash128)
static bool w_bs_u8u8_s_u8u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bs_u8u8_s_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_u8u8_* pp0 = DataTransfer::GetPointer<s_u8u8_>(context, info[0]);
    s_u8u8_ p0 = pp0 ? *pp0 : s_u8u8_ {};
    // JSValToCSVal struct
    s_u8u8_* pp1 = DataTransfer::GetPointer<s_u8u8_>(context, info[1]);
    s_u8u8_ p1 = pp1 ? *pp1 : s_u8u8_ {};

    typedef bool (*FuncToCall)(struct s_u8u8_ p0, struct s_u8u8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean GetAttributeBool(System.String, Boolean)
static bool w_bsb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bsb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void* p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean PlayFullScreenMovie(System.String, UnityEngine.Color)
static bool w_bss_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bss_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(void* p0, struct s_r4r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean PlayFullScreenMovie(System.String, UnityEngine.Color, UnityEngine.FullScreenMovieControlMode)
static bool w_bss_r4r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bss_r4r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef bool (*FuncToCall)(void* p0, struct s_r4r4r4r4_ p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean PlayFullScreenMovie(System.String, UnityEngine.Color, UnityEngine.FullScreenMovieControlMode, UnityEngine.FullScreenMovieScalingMode)
static bool w_bss_r4r4r4r4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bss_r4r4r4r4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef bool (*FuncToCall)(void* p0, struct s_r4r4r4r4_ p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean ClearCachedVersion(System.String, UnityEngine.Hash128)
static bool w_bss_u8u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bss_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_u8u8_* pp1 = DataTransfer::GetPointer<s_u8u8_>(context, info[1]);
    s_u8u8_ p1 = pp1 ? *pp1 : s_u8u8_ {};

    typedef bool (*FuncToCall)(void* p0, struct s_u8u8_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean get_fairyBatching()
static bool w_bt(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bt");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef bool (*FuncToCall)(void*,const void* method);
    bool ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Call(System.Object)
static bool w_btO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef bool (*FuncToCall)(void*,void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryGetCullingParameters(UnityEngine.Rendering.ScriptableCullingParameters ByRef)
static bool w_btPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_* p0 = nullptr; // valuetype ref
    s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsKeywordEnabled(UnityEngine.Rendering.LocalKeyword ByRef)
static bool w_btPs_psu4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btPs_psu4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_psu4_* p0 = nullptr; // valuetype ref
    s_psu4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_psu4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct s_psu4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryGetCameraToWorldMatrix(UnityEngine.Matrix4x4 ByRef)
static bool w_btPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Evaluate(Boolean)
static bool w_btb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(void*,bool p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryGetCullingParameters(Boolean, UnityEngine.Rendering.ScriptableCullingParameters ByRef)
static bool w_btbPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btbPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal Pstruct
    s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_* p1 = nullptr; // valuetype ref
    s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void*,bool p0, struct s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean HasCharacter(Char)
static bool w_btc(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btc");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(void*,Il2CppChar p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean GetGlyph(Char, Single ByRef, Single ByRef, Single ByRef)
static bool w_btcPr4Pr4Pr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btcPr4Pr4Pr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(context, info[0]);
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[1]);
    float* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[2]);
    float* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    float up3 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[3]);
    float* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }

    typedef bool (*FuncToCall)(void*,Il2CppChar p0, float* p1, float* p2, float* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<float>::toScript(context, *p1));
    }
    
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<float>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<float>::toScript(context, *p3));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean CloseModalWait(Int32)
static bool w_bti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(void*,int32_t p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Remove(Int32, System.Collections.Generic.List`1[System.Int32] ByRef)
static bool w_bti4Po(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4Po");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal Po/PO
    void* up1 = nullptr; // object ref
    void** p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        up1 = JsValueToCSRef(context, tp1, TIp1);
    }
        

    typedef bool (*FuncToCall)(void*,int32_t p0, void** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, CSRefToJsValue(isolate, context, *p1));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean FindTextureStack(Int32, System.String ByRef, Int32 ByRef)
static bool w_bti4PsPi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4PsPi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal Ps
    void* up1 = nullptr; // string ref
    void** p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        v8::String::Utf8Value tp1(isolate, op1->Get(context, 0).ToLocalChecked());
        up1 = CStringToCSharpString(*tp1);
    }
        
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(context, info[2]);
    int32_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }

    typedef bool (*FuncToCall)(void*,int32_t p0, void** p1, int32_t* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, CSAnyToJsValue(isolate, context, *p1));
    }
    
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int32_t>::toScript(context, *p2));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean GetShadowCasterBounds(Int32, UnityEngine.Bounds ByRef)
static bool w_bti4Ps_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4Ps_r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef bool (*FuncToCall)(void*,int32_t p0, struct s_r4r4r4r4r4r4_* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean ComputeSpotShadowMatricesAndCullingPrimitives(Int32, UnityEngine.Matrix4x4 ByRef, UnityEngine.Matrix4x4 ByRef, UnityEngine.Rendering.ShadowSplitData ByRef)
static bool w_bti4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4u1r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4u1r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i4u1r4r4r4r4r4r4_* p3 = nullptr; // valuetype ref
    s_i4u1r4r4r4r4r4r4_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i4u1r4r4r4r4r4r4_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef bool (*FuncToCall)(void*,int32_t p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p1, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p2, struct s_i4u1r4r4r4r4r4r4_* p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Seek(Int32, Int32)
static bool w_bti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Reinitialize(Int32, Int32, UnityEngine.TextureFormat, Boolean)
static bool w_bti4i4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4i4i4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef bool (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, bool p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean WalkAble(Int32, Int32, Int32, Int32)
static bool w_bti4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef bool (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean ComputeDirectionalShadowMatricesAndCullingPrimitives(Int32, Int32, Int32, UnityEngine.Vector3, Int32, Single, UnityEngine.Matrix4x4 ByRef, UnityEngine.Matrix4x4 ByRef, UnityEngine.Rendering.ShadowSplitData ByRef)
static bool w_bti4i4i4s_r4r4r4_i4r4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4u1r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4i4i4s_r4r4r4_i4r4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4u1r4r4r4r4r4r4_");
    
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp6 = wrapData->TypeInfos[1];
    auto TIp7 = wrapData->TypeInfos[2];
    auto TIp8 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
        if (!info[6]->IsObject()) return false;
        if (!info[7]->IsObject()) return false;
        if (!info[8]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p6 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up6;
    v8::Local<v8::Object> op6;
    if (!info[6].IsEmpty() && info[6]->IsObject()) {
        op6 = info[6]->ToObject(context).ToLocalChecked();
        auto tp6 = op6->Get(context, 0).ToLocalChecked();
        p6 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp6);
    }
    if (!p6) {
        p6 = &up6;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p7 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up7;
    v8::Local<v8::Object> op7;
    if (!info[7].IsEmpty() && info[7]->IsObject()) {
        op7 = info[7]->ToObject(context).ToLocalChecked();
        auto tp7 = op7->Get(context, 0).ToLocalChecked();
        p7 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp7);
    }
    if (!p7) {
        p7 = &up7;
    }
        
    // JSValToCSVal Pstruct
    s_i4u1r4r4r4r4r4r4_* p8 = nullptr; // valuetype ref
    s_i4u1r4r4r4r4r4r4_ up8;
    v8::Local<v8::Object> op8;
    if (!info[8].IsEmpty() && info[8]->IsObject()) {
        op8 = info[8]->ToObject(context).ToLocalChecked();
        auto tp8 = op8->Get(context, 0).ToLocalChecked();
        p8 = DataTransfer::GetPointer<s_i4u1r4r4r4r4r4r4_>(context, tp8);
    }
    if (!p8) {
        p8 = &up8;
    }
        

    typedef bool (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, struct s_r4r4r4_ p3, int32_t p4, float p5, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p6, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p7, struct s_i4u1r4r4r4r4r4r4_* p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    if (!op6.IsEmpty() && p6 == &up6)
    {
        auto _unused = op6->Set(context, 0, CopyValueType(isolate, context, TIp6, p6, sizeof(*p6)));
    }
            
    if (!op7.IsEmpty() && p7 == &up7)
    {
        auto _unused = op7->Set(context, 0, CopyValueType(isolate, context, TIp7, p7, sizeof(*p7)));
    }
            
    if (!op8.IsEmpty() && p8 == &up8)
    {
        auto _unused = op8->Set(context, 0, CopyValueType(isolate, context, TIp8, p8, sizeof(*p8)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean ComputePointShadowMatricesAndCullingPrimitives(Int32, UnityEngine.CubemapFace, Single, UnityEngine.Matrix4x4 ByRef, UnityEngine.Matrix4x4 ByRef, UnityEngine.Rendering.ShadowSplitData ByRef)
static bool w_bti4i4r4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4u1r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4i4r4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4u1r4r4r4r4r4r4_");
    
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
        if (!info[5]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p3 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p4 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
        auto tp4 = op4->Get(context, 0).ToLocalChecked();
        p4 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp4);
    }
    if (!p4) {
        p4 = &up4;
    }
        
    // JSValToCSVal Pstruct
    s_i4u1r4r4r4r4r4r4_* p5 = nullptr; // valuetype ref
    s_i4u1r4r4r4r4r4r4_ up5;
    v8::Local<v8::Object> op5;
    if (!info[5].IsEmpty() && info[5]->IsObject()) {
        op5 = info[5]->ToObject(context).ToLocalChecked();
        auto tp5 = op5->Get(context, 0).ToLocalChecked();
        p5 = DataTransfer::GetPointer<s_i4u1r4r4r4r4r4r4_>(context, tp5);
    }
    if (!p5) {
        p5 = &up5;
    }
        

    typedef bool (*FuncToCall)(void*,int32_t p0, int32_t p1, float p2, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p3, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p4, struct s_i4u1r4r4r4r4r4r4_* p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
            
    if (!op4.IsEmpty() && p4 == &up4)
    {
        auto _unused = op4->Set(context, 0, CopyValueType(isolate, context, TIp4, p4, sizeof(*p4)));
    }
            
    if (!op5.IsEmpty() && p5 == &up5)
    {
        auto _unused = op5->Set(context, 0, CopyValueType(isolate, context, TIp5, p5, sizeof(*p5)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryAdd(Int32, System.Collections.Generic.List`1[System.Int32])
static bool w_bti4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bti4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef bool (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Contains(FairyGUI.DisplayObject)
static bool w_bto(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bto");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef bool (*FuncToCall)(void*,void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryGetComponent(System.Type, UnityEngine.Component ByRef)
static bool w_btoPo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btoPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Po/PO
    void* up1 = nullptr; // object ref
    void** p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        up1 = JsValueToCSRef(context, tp1, TIp1);
    }
        

    typedef bool (*FuncToCall)(void*,void* p0, void** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, CSRefToJsValue(isolate, context, *p1));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean RenderToCubemap(UnityEngine.Cubemap, Int32)
static bool w_btoi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btoi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean RenderToCubemap(UnityEngine.RenderTexture, Int32, MonoOrStereoscopicEye)
static bool w_btoi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btoi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef bool (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(Single, Single)
static bool w_btr4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btr4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void*,float p0, float p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryGetProjectionMatrix(Single, Single, UnityEngine.Matrix4x4 ByRef)
static bool w_btr4r4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btr4r4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef bool (*FuncToCall)(void*,float p0, float p1, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean hasEventListeners(System.String)
static bool w_bts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef bool (*FuncToCall)(void*,void* p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean DispatchEvent(System.String, System.Object)
static bool w_btsO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btsO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef bool (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean DispatchEvent(System.String, System.Object, System.Object)
static bool w_btsOO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btsOO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef bool (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Remove(System.String, System.Collections.Generic.List`1[System.Int32] ByRef)
static bool w_btsPo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btsPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal Po/PO
    void* up1 = nullptr; // object ref
    void** p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        up1 = JsValueToCSRef(context, tp1, TIp1);
    }
        

    typedef bool (*FuncToCall)(void*,void* p0, void** p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, CSRefToJsValue(isolate, context, *p1));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.SortingLayerRange)
static bool w_bts_i2i2_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i2i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i2i2_* pp0 = DataTransfer::GetPointer<s_i2i2_>(context, info[0]);
    s_i2i2_ p0 = pp0 ? *pp0 : s_i2i2_ {};

    typedef bool (*FuncToCall)(void*,struct s_i2i2_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Cache)
static bool w_bts_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4_* pp0 = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p0 = pp0 ? *pp0 : s_i4_ {};

    typedef bool (*FuncToCall)(void*,struct s_i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean BlockUntilRecvMsg(System.Guid, Int32)
static bool w_bts_i4i2i2u1u1u1u1u1u1u1u1_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i4i2i2u1u1u1u1u1u1u1u1_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<s_i4i2i2u1u1u1u1u1u1u1u1_>(context, info[0]);
    s_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : s_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void*,struct s_i4i2i2u1u1u1u1u1u1u1u1_ p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TrySend(System.Guid, Byte[])
static bool w_bts_i4i2i2u1u1u1u1u1u1u1u1_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i4i2i2u1u1u1u1u1u1u1u1_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<s_i4i2i2u1u1u1u1u1u1u1u1_>(context, info[0]);
    s_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : s_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef bool (*FuncToCall)(void*,struct s_i4i2i2u1u1u1u1u1u1u1u1_ p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Contains(UnityEngine.Vector2Int)
static bool w_bts_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4_>(context, info[0]);
    s_i4i4_ p0 = pp0 ? *pp0 : s_i4i4_ {};

    typedef bool (*FuncToCall)(void*,struct s_i4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Contains(UnityEngine.Vector3Int)
static bool w_bts_i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4_>(context, info[0]);
    s_i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4_ {};

    typedef bool (*FuncToCall)(void*,struct s_i4i4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Overlaps(UnityEngine.RectInt)
static bool w_bts_i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4i4_>(context, info[0]);
    s_i4i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4i4_ {};

    typedef bool (*FuncToCall)(void*,struct s_i4i4i4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.BoundsInt)
static bool w_bts_i4i4i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i4i4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4i4i4i4_>(context, info[0]);
    s_i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4i4i4i4_ {};

    typedef bool (*FuncToCall)(void*,struct s_i4i4i4i4i4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.AttachmentDescriptor)
static bool w_bts_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_* pp0 = DataTransfer::GetPointer<s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_>(context, info[0]);
    s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_ p0 = pp0 ? *pp0 : s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_ {};

    typedef bool (*FuncToCall)(void*,struct s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.RenderTargetIdentifier)
static bool w_bts_i4i4i4pi4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i4i4i4pi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};

    typedef bool (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.FilteringSettings)
static bool w_bts_i4i4i4u4i4i2i2_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i4i4i4u4i4i2i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4u4i4i2i2_* pp0 = DataTransfer::GetPointer<s_i4i4i4u4i4i2i2_>(context, info[0]);
    s_i4i4i4u4i4i2i2_ p0 = pp0 ? *pp0 : s_i4i4i4u4i4i2i2_ {};

    typedef bool (*FuncToCall)(void*,struct s_i4i4i4u4i4i2i2_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.ScriptableCullingParameters)
static bool w_bts_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_* pp0 = DataTransfer::GetPointer<s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_>(context, info[0]);
    s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_ p0 = pp0 ? *pp0 : s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_ {};

    typedef bool (*FuncToCall)(void*,struct s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.RasterState)
static bool w_bts_i4i4r4u1u1u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i4i4r4u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4r4u1u1u1u1_* pp0 = DataTransfer::GetPointer<s_i4i4r4u1u1u1u1_>(context, info[0]);
    s_i4i4r4u1u1u1u1_ p0 = pp0 ? *pp0 : s_i4i4r4u1u1u1u1_ {};

    typedef bool (*FuncToCall)(void*,struct s_i4i4r4u1u1u1u1_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.LODParameters)
static bool w_bts_i4r4r4r4r4r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i4r4r4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4r4r4r4r4r4i4_* pp0 = DataTransfer::GetPointer<s_i4r4r4r4r4r4i4_>(context, info[0]);
    s_i4r4r4r4r4r4i4_ p0 = pp0 ? *pp0 : s_i4r4r4r4r4r4i4_ {};

    typedef bool (*FuncToCall)(void*,struct s_i4r4r4r4r4r4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.VisibleLight)
static bool w_bts_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_* pp0 = DataTransfer::GetPointer<s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_>(context, info[0]);
    s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_ p0 = pp0 ? *pp0 : s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_ {};

    typedef bool (*FuncToCall)(void*,struct s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.ShadowSplitData)
static bool w_bts_i4u1r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i4u1r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4u1r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_i4u1r4r4r4r4r4r4_>(context, info[0]);
    s_i4u1r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_i4u1r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_i4u1r4r4r4r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Raycast(GCore.FVector3, GCore.FVector3, Int64, Int32, Int32, Int32)
static bool w_bts_i8i8i8_s_i8i8i8_i8i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i8i8i8_s_i8i8i8_i8i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef bool (*FuncToCall)(void*,struct s_i8i8i8_ p0, struct s_i8i8i8_ p1, int64_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean RaycastSimple(GCore.FVector3, GCore.FVector3, Int64, Int32, Int32, Int32, Int64)
static bool w_bts_i8i8i8_s_i8i8i8_i8i4i4i4i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_i8i8i8_s_i8i8i8_i8i4i4i4i8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int64_t p6 = converter::Converter<int64_t>::toCpp(context, info[6]);

    typedef bool (*FuncToCall)(void*,struct s_i8i8i8_ p0, struct s_i8i8i8_ p1, int64_t p2, int32_t p3, int32_t p4, int32_t p5, int64_t p6, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Add(ShaderVariant)
static bool w_bts_oi4o_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_oi4o_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_oi4o_* pp0 = DataTransfer::GetPointer<s_oi4o_>(context, info[0]);
    s_oi4o_ p0 = pp0 ? *pp0 : s_oi4o_ {};

    typedef bool (*FuncToCall)(void*,struct s_oi4o_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.CullingResults)
static bool w_bts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_* pp0 = DataTransfer::GetPointer<s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_>(context, info[0]);
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p0 = pp0 ? *pp0 : s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ {};

    typedef bool (*FuncToCall)(void*,struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.ShadowDrawingSettings)
static bool w_bts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_* pp0 = DataTransfer::GetPointer<s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_>(context, info[0]);
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_ p0 = pp0 ? *pp0 : s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_ {};

    typedef bool (*FuncToCall)(void*,struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.LocalKeywordSpace)
static bool w_bts_p_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_p_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_p_* pp0 = DataTransfer::GetPointer<s_p_>(context, info[0]);
    s_p_ p0 = pp0 ? *pp0 : s_p_ {};

    typedef bool (*FuncToCall)(void*,struct s_p_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.ScriptableRenderContext)
static bool w_bts_ppi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_ppi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_ppi4i4_* pp0 = DataTransfer::GetPointer<s_ppi4i4_>(context, info[0]);
    s_ppi4i4_ p0 = pp0 ? *pp0 : s_ppi4i4_ {};

    typedef bool (*FuncToCall)(void*,struct s_ppi4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.LocalKeyword)
static bool w_bts_psu4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_psu4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_psu4_* pp0 = DataTransfer::GetPointer<s_psu4_>(context, info[0]);
    s_psu4_ p0 = pp0 ? *pp0 : s_psu4_ {};

    typedef bool (*FuncToCall)(void*,struct s_psu4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Playables.Playable)
static bool w_bts_pu4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_pu4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_pu4_* pp0 = DataTransfer::GetPointer<s_pu4_>(context, info[0]);
    s_pu4_ p0 = pp0 ? *pp0 : s_pu4_ {};

    typedef bool (*FuncToCall)(void*,struct s_pu4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.BoneWeight1)
static bool w_bts_r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4i4_* pp0 = DataTransfer::GetPointer<s_r4i4_>(context, info[0]);
    s_r4i4_ p0 = pp0 ? *pp0 : s_r4i4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Contains(UnityEngine.Vector2)
static bool w_bts_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Contains(UnityEngine.Vector3)
static bool w_bts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Contains(UnityEngine.Vector3, Boolean)
static bool w_bts_r4r4r4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4_ p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SameSide(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_bts_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Overlaps(UnityEngine.Rect)
static bool w_bts_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Overlaps(UnityEngine.Rect, Boolean)
static bool w_bts_r4r4r4r4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean HitTest(UnityEngine.Rect, UnityEngine.Vector2)
static bool w_bts_r4r4r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, struct s_r4r4_ p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.BoneWeight)
static bool w_bts_r4r4r4r4i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4i4i4i4i4_>(context, info[0]);
    s_r4r4r4r4i4i4i4i4_ p0 = pp0 ? *pp0 : s_r4r4r4r4i4i4i4i4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4i4i4i4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Bounds)
static bool w_bts_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IntersectRay(UnityEngine.Ray, Single ByRef)
static bool w_bts_r4r4r4r4r4r4_Pr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4r4r4_Pr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[1]);
    float* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4r4r4_ p0, float* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<float>::toScript(context, *p1));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Pose)
static bool w_bts_r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Matrix4x4)
static bool w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.SortingSettings)
static bool w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.DrawingSettings)
static bool w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.SphericalHarmonicsL2)
static bool w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.VisibleReflectionProbe)
static bool w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.CameraProperties)
static bool w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_ {};

    typedef bool (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsEnabled(UnityEngine.Rendering.GlobalKeyword)
static bool w_bts_su4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_su4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_su4_* pp0 = DataTransfer::GetPointer<s_su4_>(context, info[0]);
    s_su4_ p0 = pp0 ? *pp0 : s_su4_ {};

    typedef bool (*FuncToCall)(void*,struct s_su4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean IsEnabled(UnityEngine.Rendering.ShaderKeyword)
static bool w_bts_su4bbb_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_su4bbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_su4bbb_* pp0 = DataTransfer::GetPointer<s_su4bbb_>(context, info[0]);
    s_su4bbb_ p0 = pp0 ? *pp0 : s_su4bbb_ {};

    typedef bool (*FuncToCall)(void*,struct s_su4bbb_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.DepthState)
static bool w_bts_u1i1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_u1i1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u1i1_* pp0 = DataTransfer::GetPointer<s_u1i1_>(context, info[0]);
    s_u1i1_ p0 = pp0 ? *pp0 : s_u1i1_ {};

    typedef bool (*FuncToCall)(void*,struct s_u1i1_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.RenderTargetBlendState)
static bool w_bts_u1u1u1u1u1u1u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<s_u1u1u1u1u1u1u1u1_>(context, info[0]);
    s_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : s_u1u1u1u1u1u1u1u1_ {};

    typedef bool (*FuncToCall)(void*,struct s_u1u1u1u1u1u1u1u1_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.StencilState)
static bool w_bts_u1u1u1u1u1u1u1u1u1u1u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_u1u1u1u1u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u1u1u1u1u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<s_u1u1u1u1u1u1u1u1u1u1u1u1_>(context, info[0]);
    s_u1u1u1u1u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : s_u1u1u1u1u1u1u1u1u1u1u1u1_ {};

    typedef bool (*FuncToCall)(void*,struct s_u1u1u1u1u1u1u1u1u1u1u1u1_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.BlendState)
static bool w_bts_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_* pp0 = DataTransfer::GetPointer<s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_>(context, info[0]);
    s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_ p0 = pp0 ? *pp0 : s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_ {};

    typedef bool (*FuncToCall)(void*,struct s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Rendering.RenderStateBlock)
static bool w_bts_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_* pp0 = DataTransfer::GetPointer<s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_>(context, info[0]);
    s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_ p0 = pp0 ? *pp0 : s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_ {};

    typedef bool (*FuncToCall)(void*,struct s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.RefreshRate)
static bool w_bts_u4u4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_u4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u4u4_* pp0 = DataTransfer::GetPointer<s_u4u4_>(context, info[0]);
    s_u4u4_ p0 = pp0 ? *pp0 : s_u4u4_ {};

    typedef bool (*FuncToCall)(void*,struct s_u4u4_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.DisplayInfo)
static bool w_bts_u8i4i4u4u4i4i4i4i4s_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_u8i4i4u4u4i4i4i4i4s_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u8i4i4u4u4i4i4i4i4s_* pp0 = DataTransfer::GetPointer<s_u8i4i4u4u4i4i4i4i4s_>(context, info[0]);
    s_u8i4i4u4u4i4i4i4i4s_ p0 = pp0 ? *pp0 : s_u8i4i4u4u4i4i4i4i4s_ {};

    typedef bool (*FuncToCall)(void*,struct s_u8i4i4u4u4i4i4i4i4s_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean Equals(UnityEngine.Hash128)
static bool w_bts_u8u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bts_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u8u8_* pp0 = DataTransfer::GetPointer<s_u8u8_>(context, info[0]);
    s_u8u8_ p0 = pp0 ? *pp0 : s_u8u8_ {};

    typedef bool (*FuncToCall)(void*,struct s_u8u8_ p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean GetBool(System.String, Boolean)
static bool w_btsb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btsb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean TryAdd(System.String, System.Collections.Generic.List`1[System.Int32])
static bool w_btso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef bool (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean pay(System.String, System.String, System.String, Int32, Int32, System.String, Int64, System.String, System.Action`2[System.Int32,System.String])
static bool w_btsssi4i4si8so(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btsssi4i4si8so");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp7 = wrapData->TypeInfos[4];
    auto TIp8 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsString() && !info[5]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int64_t>::accept(context, info[6])) return false;
        if (!info[7]->IsString() && !info[7]->IsNullOrUndefined()) return false;
        if (!info[8]->IsNullOrUndefined() && (!info[8]->IsObject() || (info[8]->IsFunction() ? !IsDelegate(TIp8) : !IsAssignableFrom(TIp8, GetTypeId(info[8].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal s
    v8::String::Utf8Value tp5(isolate, info[5]);
    void* p5 = CStringToCSharpString(*tp5);
    // JSValToCSVal P any
    int64_t p6 = converter::Converter<int64_t>::toCpp(context, info[6]);
    // JSValToCSVal s
    v8::String::Utf8Value tp7(isolate, info[7]);
    void* p7 = CStringToCSharpString(*tp7);
    // JSValToCSVal o/O
    void* p8 = JsValueToCSRef(context, info[8], TIp8);

    typedef bool (*FuncToCall)(void*,void* p0, void* p1, void* p2, int32_t p3, int32_t p4, void* p5, int64_t p6, void* p7, void* p8, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean C_EnttValid(UInt32)
static bool w_btu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btu4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(void*,uint32_t p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean C_HasCom(UInt32, Int32)
static bool w_btu4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_btu4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef bool (*FuncToCall)(void*,uint32_t p0, int32_t p1, const void* method);
    bool ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Boolean SetTempAllocatorRequestedSize(UInt32)
static bool w_bu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_bu4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);

    typedef bool (*FuncToCall)(uint32_t p0, const void* method);
    bool ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Char get_character()
static bool w_ct(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ct");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef Il2CppChar (*FuncToCall)(void*,const void* method);
    Il2CppChar ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int16 ReadShort()
static bool w_i2t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i2t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef int16_t (*FuncToCall)(void*,const void* method);
    int16_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 get_layer()
static bool w_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef int32_t (*FuncToCall)(const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 Min(Int32[])
static bool w_i4Vi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4Vi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
        if (!info[0]->IsNullOrUndefined() && !converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal primitive params
    void* p0 = RestArguments<int32_t>::PackPrimitive(context, info, TIp0, 0);
                

    typedef int32_t (*FuncToCall)(void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetMask(System.String[])
static bool w_i4Vs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4Vs");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
        if (!info[0]->IsNullOrUndefined() && !info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal string params
    void* p0 = RestArguments<void*>::PackString(context, info, TIp0, 0);
                

    typedef int32_t (*FuncToCall)(void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 CharToHex(Char)
static bool w_i4c(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4c");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(context, info[0]);

    typedef int32_t (*FuncToCall)(Il2CppChar p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetLayerValueFromID(Int32)
static bool w_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef int32_t (*FuncToCall)(int32_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UnityEngine.Experimental.Rendering.GraphicsFormat GetGraphicsFormat(UnityEngine.TextureFormat, Boolean)
static bool w_i4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4i4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(int32_t p0, bool p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 Min(Int32, Int32)
static bool w_i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 Clamp(Int32, Int32, Int32)
static bool w_i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetAllCameras(UnityEngine.Camera[])
static bool w_i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef int32_t (*FuncToCall)(void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetSQLConnCode(IntPtr)
static bool w_i4p(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4p");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);

    typedef int32_t (*FuncToCall)(void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 MapPos2Idx(IntPtr, GCore.F64 ByRef, GCore.F64 ByRef, Int32)
static bool w_i4pPs_i8_Ps_i8_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pPs_i8_Ps_i8_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8_* p1 = nullptr; // valuetype ref
    s_i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8_* p2 = nullptr; // valuetype ref
    s_i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef int32_t (*FuncToCall)(void* p0, struct s_i8_* p1, struct s_i8_* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 grid_pos2idx(IntPtr, GCore.FVector3 ByRef, Int32, Int32)
static bool w_i4pPs_i8i8i8_Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pPs_i8i8i8_Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef int32_t (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 grid_raycast(IntPtr, GCore.FVector3 ByRef, GCore.FVector3 ByRef, Int64 ByRef, Int32, Int32, Int32, GCore.FVector3 ByRef)
static bool w_i4pPs_i8i8i8_Ps_i8i8i8_Pi8i4i4i4Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pPs_i8i8i8_Ps_i8i8i8_Pi8i4i4i4Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p7 = nullptr; // valuetype ref
    s_i8i8i8_ up7;
    v8::Local<v8::Object> op7;
    if (!info[7].IsEmpty() && info[7]->IsObject()) {
        op7 = info[7]->ToObject(context).ToLocalChecked();
        auto tp7 = op7->Get(context, 0).ToLocalChecked();
        p7 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp7);
    }
    if (!p7) {
        p7 = &up7;
    }
        

    typedef int32_t (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, int64_t* p3, int32_t p4, int32_t p5, int32_t p6, struct s_i8i8i8_* p7, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    if (!op7.IsEmpty() && p7 == &up7)
    {
        auto _unused = op7->Set(context, 0, CopyValueType(isolate, context, TIp7, p7, sizeof(*p7)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 grid_raycastsm(IntPtr, GCore.FVector3 ByRef, GCore.FVector3 ByRef, Int64 ByRef, Int32, Int32, Int32, GCore.FVector3 ByRef, Int64 ByRef)
static bool w_i4pPs_i8i8i8_Ps_i8i8i8_Pi8i4i4i4Ps_i8i8i8_Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pPs_i8i8i8_Ps_i8i8i8_Pi8i4i4i4Ps_i8i8i8_Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsObject()) return false;
        if (!info[8]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p7 = nullptr; // valuetype ref
    s_i8i8i8_ up7;
    v8::Local<v8::Object> op7;
    if (!info[7].IsEmpty() && info[7]->IsObject()) {
        op7 = info[7]->ToObject(context).ToLocalChecked();
        auto tp7 = op7->Get(context, 0).ToLocalChecked();
        p7 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp7);
    }
    if (!p7) {
        p7 = &up7;
    }
        
    // JSValToCSVal P primitive
    int64_t up8 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[8]);
    int64_t* p8 = &up8;
    v8::Local<v8::Object> op8;
    if (!info[8].IsEmpty() && info[8]->IsObject()) {
        op8 = info[8]->ToObject(context).ToLocalChecked();
    }

    typedef int32_t (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, int64_t* p3, int32_t p4, int32_t p5, int32_t p6, struct s_i8i8i8_* p7, int64_t* p8, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    if (!op7.IsEmpty() && p7 == &up7)
    {
        auto _unused = op7->Set(context, 0, CopyValueType(isolate, context, TIp7, p7, sizeof(*p7)));
    }
            
    if (!op8.IsEmpty())
    {
        auto _unused = op8->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p8));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 doRaycast(IntPtr, GCore.FVector3 ByRef, GCore.FVector3 ByRef, GCore.F64 ByRef)
static bool w_i4pPs_i8i8i8_Ps_i8i8i8_Ps_i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pPs_i8i8i8_Ps_i8i8i8_Ps_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8_* p3 = nullptr; // valuetype ref
    s_i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef int32_t (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, struct s_i8_* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 findStraightPath(IntPtr, GCore.FVector3 ByRef, GCore.FVector3 ByRef, Int64[])
static bool w_i4pPs_i8i8i8_Ps_i8i8i8_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pPs_i8i8i8_Ps_i8i8i8_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef int32_t (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 ReadInt32(IntPtr, Int32)
static bool w_i4pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 entt_find_path(IntPtr, Int32, GCore.FVector3 ByRef, GCore.FVector3 ByRef, Int64[])
static bool w_i4pi4Ps_i8i8i8_Ps_i8i8i8_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pi4Ps_i8i8i8_Ps_i8i8i8_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);

    typedef int32_t (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, void* p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 entt_phy_raycastall(IntPtr, Int32, GCore.FVector3 ByRef, GCore.FVector3 ByRef, GCore.PhyHitInfo[], Int64 ByRef)
static bool w_i4pi4Ps_i8i8i8_Ps_i8i8i8_oPi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pi4Ps_i8i8i8_Ps_i8i8i8_oPi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!info[5]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P primitive
    int64_t up5 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[5]);
    int64_t* p5 = &up5;
    v8::Local<v8::Object> op5;
    if (!info[5].IsEmpty() && info[5]->IsObject()) {
        op5 = info[5]->ToObject(context).ToLocalChecked();
    }

    typedef int32_t (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, void* p4, int64_t* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
            
    if (!op5.IsEmpty())
    {
        auto _unused = op5->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p5));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 randomInt(IntPtr, Int32, Int32)
static bool w_i4pi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void* p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 grid_walktype(IntPtr, Int32, Int32, Int32, Int32)
static bool w_i4pi4i4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pi4i4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef int32_t (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 grid_walkable(IntPtr, Int32, Int32, Int32, Int32)
static bool w_i4pi4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pi4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef int32_t (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 dump(IntPtr, Byte[])
static bool w_i4po(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef int32_t (*FuncToCall)(void* p0, void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 SQLRekey(IntPtr, Byte[], Int32)
static bool w_i4poi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4poi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void* p0, void* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 PGNoQuery(IntPtr, System.String)
static bool w_i4ps(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ps");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef int32_t (*FuncToCall)(void* p0, void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 entt_isvalid(IntPtr, UInt32)
static bool w_i4pu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pu4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void* p0, uint32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 entt_has_com(IntPtr, UInt32, Int32)
static bool w_i4pu4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pu4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void* p0, uint32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 entt_do_phytest(IntPtr, UInt32, GCore.PhyHitInfo[])
static bool w_i4pu4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4pu4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef int32_t (*FuncToCall)(void* p0, uint32_t p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 CeilToInt(Single)
static bool w_i4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef int32_t (*FuncToCall)(float p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// DirectionType DetectTextDirection(System.String)
static bool w_i4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef int32_t (*FuncToCall)(void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 op_Implicit(UnityEngine.LayerMask)
static bool w_i4s_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4_* pp0 = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p0 = pp0 ? *pp0 : s_i4_ {};

    typedef int32_t (*FuncToCall)(struct s_i4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetRenderTextureSupportedMSAASampleCount(UnityEngine.RenderTextureDescriptor)
static bool w_i4s_i4i4i4i4i4i4i4i4i4i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(context, info[0]);
    s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};

    typedef int32_t (*FuncToCall)(struct s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UnityEngine.Rendering.ShaderKeywordType GetGlobalKeywordType(UnityEngine.Rendering.ShaderKeyword)
static bool w_i4s_su4bbb_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4s_su4bbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_su4bbb_* pp0 = DataTransfer::GetPointer<s_su4bbb_>(context, info[0]);
    s_su4bbb_ p0 = pp0 ? *pp0 : s_su4bbb_ {};

    typedef int32_t (*FuncToCall)(struct s_su4bbb_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetAttributeInt(System.String, Int32)
static bool w_i4si4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4si4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 get_numChildren()
static bool w_i4t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef int32_t (*FuncToCall)(void*,const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 CompareTo(System.Object)
static bool w_i4tO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef int32_t (*FuncToCall)(void*,void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 IndexOf(System.Object, Int32)
static bool w_i4tOi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tOi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 IndexOf(System.Object, Int32, Int32)
static bool w_i4tOi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tOi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BinarySearch(System.Object, System.Collections.Generic.IComparer`1[System.Object])
static bool w_i4tOo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tOo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef int32_t (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 QueryIndices(Boolean, Int32, Int32[], Int32)
static bool w_i4tbi4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tbi4oi4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef int32_t (*FuncToCall)(void*,bool p0, int32_t p1, void* p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 QueryIndices(Boolean, Int32[], Int32)
static bool w_i4tboi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tboi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void*,bool p0, void* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetLineHeight(Int32)
static bool w_i4ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 IndexOf(Int32, Int32)
static bool w_i4ti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BinarySearch(Int32, Int32, System.Object, System.Collections.Generic.IComparer`1[System.Object])
static bool w_i4ti4i4Oo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4i4Oo");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, void* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 IndexOf(Int32, Int32, Int32)
static bool w_i4ti4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 WalkType(Int32, Int32, Int32, Int32)
static bool w_i4ti4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BinarySearch(Int32, Int32, Int32, System.Collections.Generic.IComparer`1[System.Int32])
static bool w_i4ti4i4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4i4i4o");
    
    auto TIp3 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 FindIndex(Int32, Int32, System.Predicate`1[System.Int32])
static bool w_i4ti4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4i4o");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, void* p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BinarySearch(Int32, Int32, System.String, System.Collections.Generic.IComparer`1[System.String])
static bool w_i4ti4i4so(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4i4so");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, int32_t p1, void* p2, void* p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetPhysicsShape(Int32, System.Collections.Generic.List`1[UnityEngine.Vector2])
static bool w_i4ti4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 QueryIndices(Int32, Int32[], Int32)
static bool w_i4ti4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4oi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void*,int32_t p0, void* p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 MoveKey(Int32, UnityEngine.Keyframe)
static bool w_i4ti4s_r4r4r4r4i4i4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti4s_r4r4r4r4i4i4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4i4i4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4i4i4r4r4_>(context, info[1]);
    s_r4r4r4r4i4i4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4i4i4r4r4_ {};

    typedef int32_t (*FuncToCall)(void*,int32_t p0, struct s_r4r4r4r4i4i4r4r4_ p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 Pos2Idx(Int64, Int64, Int32)
static bool w_i4ti8i8i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti8i8i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void*,int64_t p0, int64_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 Pos2Idx(Int64, Int64, Int32, Int32)
static bool w_i4ti8i8i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti8i8i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef int32_t (*FuncToCall)(void*,int64_t p0, int64_t p1, int32_t p2, int32_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 AddObstacle(Int64, Int64, Int64, Int64)
static bool w_i4ti8i8i8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ti8i8i8i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);

    typedef int32_t (*FuncToCall)(void*,int64_t p0, int64_t p1, int64_t p2, int64_t p3, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetChildIndex(FairyGUI.DisplayObject)
static bool w_i4to(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4to");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef int32_t (*FuncToCall)(void*,void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 SetChildIndexBefore(FairyGUI.GObject, Int32)
static bool w_i4toi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4toi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 AddBatch(UnityEngine.Mesh, Int32, UnityEngine.Material, Int32, UnityEngine.Rendering.ShadowCastingMode, Boolean, Boolean, UnityEngine.Bounds, Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.GameObject, UInt64, UInt32)
static bool w_i4toi4oi4i4bbs_r4r4r4r4r4r4_i4ooDu8Du4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4toi4oi4i4bbs_r4r4r4r4r4r4_i4ooDu8Du4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp7 = wrapData->TypeInfos[2];
    auto TIp9 = wrapData->TypeInfos[3];
    auto TIp10 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 11) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<bool>::accept(context, info[5])) return false;
        if (!converter::Converter<bool>::accept(context, info[6])) return false;
        if ((!info[7]->IsObject() || !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (!info[9]->IsNullOrUndefined() && (!info[9]->IsObject() || (info[9]->IsFunction() ? !IsDelegate(TIp9) : !IsAssignableFrom(TIp9, GetTypeId(info[9].As<v8::Object>()))))) return false;
        if (!info[10]->IsNullOrUndefined() && (!info[10]->IsObject() || (info[10]->IsFunction() ? !IsDelegate(TIp10) : !IsAssignableFrom(TIp10, GetTypeId(info[10].As<v8::Object>()))))) return false;
        if (length > 11 && !converter::Converter<uint64_t>::accept(context, info[11])) return false;
        if (length > 12 && !converter::Converter<uint32_t>::accept(context, info[12])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(context, info[5]);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(context, info[6]);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp7 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[7]);
    s_r4r4r4r4r4r4_ p7 = pp7 ? *pp7 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);
    // JSValToCSVal o/O
    void* p9 = JsValueToCSRef(context, info[9], TIp9);
    // JSValToCSVal o/O
    void* p10 = JsValueToCSRef(context, info[10], TIp10);
    // JSValToCSVal primitive with default
    uint64_t p11 = OptionalParameter<uint64_t>::GetPrimitive(context, info, method, 11);
                
    // JSValToCSVal primitive with default
    uint32_t p12 = OptionalParameter<uint32_t>::GetPrimitive(context, info, method, 12);
                

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, int32_t p3, int32_t p4, bool p5, bool p6, struct s_r4r4r4r4r4r4_ p7, int32_t p8, void* p9, void* p10, uint64_t p11, uint32_t p12, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetSprites(UnityEngine.Sprite[], System.String)
static bool w_i4tos(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tos");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef int32_t (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetHashCode(Single)
static bool w_i4tr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef int32_t (*FuncToCall)(void*,float p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 AddKey(Single, Single)
static bool w_i4tr4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tr4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void*,float p0, float p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 DrawGlyph(Single, Single, System.Collections.Generic.List`1[UnityEngine.Vector3], System.Collections.Generic.List`1[UnityEngine.Vector2], System.Collections.Generic.List`1[UnityEngine.Vector2], System.Collections.Generic.List`1[UnityEngine.Color32])
static bool w_i4tr4r4oooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tr4r4oooo");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);

    typedef int32_t (*FuncToCall)(void*,float p0, float p1, void* p2, void* p3, void* p4, void* p5, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 DrawLine(Single, Single, Single, Int32, Int32, System.Collections.Generic.List`1[UnityEngine.Vector3], System.Collections.Generic.List`1[UnityEngine.Vector2], System.Collections.Generic.List`1[UnityEngine.Vector2], System.Collections.Generic.List`1[UnityEngine.Color32])
static bool w_i4tr4r4r4i4i4oooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tr4r4r4i4i4oooo");
    
    auto TIp5 = wrapData->TypeInfos[0];
    auto TIp6 = wrapData->TypeInfos[1];
    auto TIp7 = wrapData->TypeInfos[2];
    auto TIp8 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
        if (!info[8]->IsNullOrUndefined() && (!info[8]->IsObject() || (info[8]->IsFunction() ? !IsDelegate(TIp8) : !IsAssignableFrom(TIp8, GetTypeId(info[8].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);
    // JSValToCSVal o/O
    void* p8 = JsValueToCSRef(context, info[8], TIp8);

    typedef int32_t (*FuncToCall)(void*,float p0, float p1, float p2, int32_t p3, int32_t p4, void* p5, void* p6, void* p7, void* p8, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetInt(System.String)
static bool w_i4ts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef int32_t (*FuncToCall)(void*,void* p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetPositions(Unity.Collections.NativeSlice`1[UnityEngine.Vector3])
static bool w_i4ts_Pu1i4i4i4i4pi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts_Pu1i4i4i4i4pi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pu1i4i4i4i4pi4i4_* pp0 = DataTransfer::GetPointer<s_Pu1i4i4i4i4pi4i4_>(context, info[0]);
    s_Pu1i4i4i4i4pi4i4_ p0 = pp0 ? *pp0 : s_Pu1i4i4i4i4pi4i4_ {};

    typedef int32_t (*FuncToCall)(void*,struct s_Pu1i4i4i4i4pi4i4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetPositions(Unity.Collections.NativeArray`1[UnityEngine.Vector3])
static bool w_i4ts_Pvi4i4i4pi4i4oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts_Pvi4i4i4pi4i4oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};

    typedef int32_t (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UnityEngine.Rendering.RendererUtils.RendererListStatus QueryRendererListStatus(UnityEngine.Rendering.RendererUtils.RendererList)
static bool w_i4ts_pu4u4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts_pu4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_pu4u4_* pp0 = DataTransfer::GetPointer<s_pu4u4_>(context, info[0]);
    s_pu4u4_ p0 = pp0 ? *pp0 : s_pu4u4_ {};

    typedef int32_t (*FuncToCall)(void*,struct s_pu4u4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 AddKey(UnityEngine.Keyframe)
static bool w_i4ts_r4r4r4r4i4i4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts_r4r4r4r4i4i4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4i4i4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4i4i4r4r4_>(context, info[0]);
    s_r4r4r4r4i4i4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4i4i4r4r4_ {};

    typedef int32_t (*FuncToCall)(void*,struct s_r4r4r4r4i4i4r4r4_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 CompareTo(UnityEngine.Hash128)
static bool w_i4ts_u8u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4ts_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u8u8_* pp0 = DataTransfer::GetPointer<s_u8u8_>(context, info[0]);
    s_u8u8_ p0 = pp0 ? *pp0 : s_u8u8_ {};

    typedef int32_t (*FuncToCall)(void*,struct s_u8u8_ p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 GetInt(System.String, Int32)
static bool w_i4tsi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tsi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 IndexOf(System.String, Int32, Int32)
static bool w_i4tsi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tsi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef int32_t (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 BinarySearch(System.String, System.Collections.Generic.IComparer`1[System.String])
static bool w_i4tso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef int32_t (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int32 C_GetCrowdState(UInt32)
static bool w_i4tu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i4tu4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);

    typedef int32_t (*FuncToCall)(void*,uint32_t p0, const void* method);
    int32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Int64 get_spaceOccupied()
static bool w_i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef int64_t (*FuncToCall)(const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 f_log(Int64 ByRef)
static bool w_i8Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8Pi8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    
    // JSValToCSVal P primitive
    int64_t up0 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[0]);
    int64_t* p0 = &up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
    }

    typedef int64_t (*FuncToCall)(int64_t* p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    if (!op0.IsEmpty())
    {
        auto _unused = op0->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p0));
    }
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 f_mul(Int64 ByRef, Int64 ByRef)
static bool w_i8Pi8Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8Pi8Pi8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal P primitive
    int64_t up0 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[0]);
    int64_t* p0 = &up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up1 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[1]);
    int64_t* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }

    typedef int64_t (*FuncToCall)(int64_t* p0, int64_t* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty())
    {
        auto _unused = op0->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p0));
    }
    
    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p1));
    }
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 fv_magnitude(GCore.FVector3 ByRef)
static bool w_i8Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef int64_t (*FuncToCall)(struct s_i8i8i8_* p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 fv_dot(GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_i8Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef int64_t (*FuncToCall)(struct s_i8i8i8_* p0, struct s_i8i8i8_* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 fq_length2(GCore.FQuaterion ByRef)
static bool w_i8Ps_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8Ps_i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef int64_t (*FuncToCall)(struct s_i8i8i8i8_* p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 GetRuntimeMemorySizeLong(UnityEngine.Object)
static bool w_i8o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8o");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef int64_t (*FuncToCall)(void* p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 SetRVOAgentRadius(IntPtr, GCore.F64 ByRef)
static bool w_i8pPs_i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8pPs_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8_* p1 = nullptr; // valuetype ref
    s_i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef int64_t (*FuncToCall)(void* p0, struct s_i8_* p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 AddRvoAgent(IntPtr, GCore.F64 ByRef, GCore.F64 ByRef, GCore.FVector3 ByRef)
static bool w_i8pPs_i8_Ps_i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8pPs_i8_Ps_i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8_* p1 = nullptr; // valuetype ref
    s_i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8_* p2 = nullptr; // valuetype ref
    s_i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef int64_t (*FuncToCall)(void* p0, struct s_i8_* p1, struct s_i8_* p2, struct s_i8i8i8_* p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 ReadInt64(IntPtr, Int32)
static bool w_i8pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef int64_t (*FuncToCall)(void* p0, int32_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 GetTotalFragmentationInfo(Unity.Collections.NativeArray`1[System.Int32])
static bool w_i8s_Pvi4i4i4pi4i4oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8s_Pvi4i4i4pi4i4oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};

    typedef int64_t (*FuncToCall)(struct s_Pvi4i4i4pi4i4oi4_ p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 ReadLong()
static bool w_i8t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef int64_t (*FuncToCall)(void*,const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 ReadInt64(Int32)
static bool w_i8ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8ti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef int64_t (*FuncToCall)(void*,int32_t p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 C_NavRaycast(Int32, GCore.FVector3, GCore.FVector3)
static bool w_i8ti4s_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8ti4s_i8i8i8_s_i8i8i8_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef int64_t (*FuncToCall)(void*,int32_t p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 C_Sin(Int64)
static bool w_i8ti8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8ti8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);

    typedef int64_t (*FuncToCall)(void*,int64_t p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 C_Mul(Int64, Int64)
static bool w_i8ti8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8ti8i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);

    typedef int64_t (*FuncToCall)(void*,int64_t p0, int64_t p1, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 AddAgent(Int64, Int64, Int64, Int64)
static bool w_i8ti8i8i8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8ti8i8i8i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);

    typedef int64_t (*FuncToCall)(void*,int64_t p0, int64_t p1, int64_t p2, int64_t p3, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 Dot(GCore.FVector3)
static bool w_i8ts_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8ts_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};

    typedef int64_t (*FuncToCall)(void*,struct s_i8i8i8_ p0, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// Int64 NavRaycast(System.String, GCore.FVector3, GCore.FVector3)
static bool w_i8tss_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_i8tss_i8i8i8_s_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef int64_t (*FuncToCall)(void*,void* p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, const void* method);
    int64_t ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
    return true;
}

// FairyGUI.VertexBuffer Begin()
static bool w_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_o");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef void* (*FuncToCall)(const void* method);
    void* ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener GetTween(System.Object)
static bool w_oO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener GetTween(System.Object, FairyGUI.TweenPropType)
static bool w_oOi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oOi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Reflection.MethodInfo GetValidMethodInfo(System.Object, System.String, System.Type[])
static bool w_oOso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oOso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.AsyncOperation MoveMainWindowTo(UnityEngine.DisplayInfo ByRef, UnityEngine.Vector2Int)
static bool w_oPs_u8i4i4u4u4i4i4i4i4s_s_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oPs_u8i4i4u4u4i4i4i4i4s_s_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal Pstruct
    s_u8i4i4u4u4i4i4i4i4s_* p0 = nullptr; // valuetype ref
    s_u8i4i4u4u4i4i4i4i4s_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_u8i4i4u4u4i4i4i4i4s_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal struct
    s_i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4_>(context, info[1]);
    s_i4i4_ p1 = pp1 ? *pp1 : s_i4i4_ {};

    typedef void* (*FuncToCall)(struct s_u8i4i4u4u4i4i4i4i4s_* p0, struct s_i4i4_ p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate Combine(System.Delegate[])
static bool w_oVo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oVo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
        if (!info[0]->IsNullOrUndefined() && !info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal ref params
    void* p0 = RestArguments<void*>::PackRef(context, info, TIp0, 0);
                

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.ControllerAction CreateAction(ActionType)
static bool w_oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Light[] GetLights(UnityEngine.LightType, Int32)
static bool w_oi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RenderTexture CreateRenderTexture(Int32, Int32, Boolean)
static bool w_oi4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4i4b");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(int32_t p0, int32_t p1, bool p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Cubemap CreateExternalTexture(Int32, UnityEngine.TextureFormat, Boolean, IntPtr)
static bool w_oi4i4bp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4i4bp");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!info[3]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(context, info[3]);

    typedef void* (*FuncToCall)(int32_t p0, int32_t p1, bool p2, void* p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32)
static bool w_oi4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Texture2D CreateExternalTexture(Int32, Int32, UnityEngine.TextureFormat, Boolean, Boolean, IntPtr)
static bool w_oi4i4i4bbp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4i4i4bbp");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!info[5]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal P any
    void* p5 = DataTransfer::GetPointer<void>(context, info[5]);

    typedef void* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, bool p3, bool p4, void* p5, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat)
static bool w_oi4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Texture3D CreateExternalTexture(Int32, Int32, Int32, UnityEngine.TextureFormat, Boolean, IntPtr)
static bool w_oi4i4i4i4bp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4i4i4i4bp");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!info[5]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal P any
    void* p5 = DataTransfer::GetPointer<void>(context, info[5]);

    typedef void* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, bool p4, void* p5, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32)
static bool w_oi4i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, UnityEngine.RenderTextureMemoryless)
static bool w_oi4i4i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, UnityEngine.RenderTextureMemoryless, UnityEngine.VRTextureUsage)
static bool w_oi4i4i4i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4i4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef void* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, UnityEngine.RenderTextureMemoryless, UnityEngine.VRTextureUsage, Boolean)
static bool w_oi4i4i4i4i4i4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4i4i4i4i4i4i4b");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);

    typedef void* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, bool p7, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, UnityEngine.RenderTextureMemoryless, UnityEngine.VRTextureUsage)
static bool w_oi4i4i4i4i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4i4i4i4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);

    typedef void* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RenderTexture GetTemporary(Int32, Int32, Int32, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, UnityEngine.RenderTextureMemoryless, UnityEngine.VRTextureUsage, Boolean)
static bool w_oi4i4i4i4i4i4i4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4i4i4i4i4i4i4i4b");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);

    typedef void* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, bool p8, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.AsyncOperation LoadSceneAsync(Int32, UnityEngine.SceneManagement.LoadSceneParameters)
static bool w_oi4s_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oi4s_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4_>(context, info[1]);
    s_i4i4_ p1 = pp1 ? *pp1 : s_i4i4_ {};

    typedef void* (*FuncToCall)(int32_t p0, struct s_i4i4_ p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.VertexBuffer Begin(FairyGUI.VertexBuffer)
static bool w_oo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GObject NewObject(FairyGUI.PackageItem, System.Type)
static bool w_ooDo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal ref  with default
    void* p1 = OptionalParameter<void*>::GetRefType(context, info, method, 1, TIp1);
                

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.Reflection.MethodInfo)
static bool w_ooOo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooOo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.Reflection.MethodInfo, Boolean)
static bool w_ooOob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooOob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, bool p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.String)
static bool w_ooOs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooOs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.String, Boolean)
static bool w_ooOsb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooOsb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, bool p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Object, System.String, Boolean, Boolean)
static bool w_ooOsbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooOsbb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, bool p3, bool p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object[] FindObjectsOfType(System.Type, Boolean)
static bool w_oob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object[] FindObjectsByType(System.Type, UnityEngine.FindObjectsSortMode)
static bool w_ooi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object[] FindObjectsByType(System.Type, UnityEngine.FindObjectsInactive, UnityEngine.FindObjectsSortMode)
static bool w_ooi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, int32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.UIPackage AddPackage(UnityEngine.AssetBundle, UnityEngine.AssetBundle)
static bool w_ooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Transform, Boolean)
static bool w_ooob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void* p0, void* p1, bool p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.UIPackage AddPackage(UnityEngine.AssetBundle, UnityEngine.AssetBundle, System.String)
static bool w_ooos(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Type, System.String, Boolean)
static bool w_ooosb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooosb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, bool p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Delegate CreateDelegate(System.Type, System.Type, System.String, Boolean, Boolean)
static bool w_ooosbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooosbb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, bool p3, bool p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object GetBuiltinResource(System.Type, System.String)
static bool w_oos(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Vector3, UnityEngine.Quaternion)
static bool w_oos_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oos_r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void* (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Object Instantiate(UnityEngine.Object, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Transform)
static bool w_oos_r4r4r4_s_r4r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oos_r4r4r4_s_r4r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void* (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, void* p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Sprite Create(UnityEngine.Texture2D, UnityEngine.Rect, UnityEngine.Vector2)
static bool w_oos_r4r4r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oos_r4r4r4r4_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4_>(context, info[2]);
    s_r4r4_ p2 = pp2 ? *pp2 : s_r4r4_ {};

    typedef void* (*FuncToCall)(void* p0, struct s_r4r4r4r4_ p1, struct s_r4r4_ p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Sprite Create(UnityEngine.Texture2D, UnityEngine.Rect, UnityEngine.Vector2, Single)
static bool w_oos_r4r4r4r4_s_r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oos_r4r4r4r4_s_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4_>(context, info[2]);
    s_r4r4_ p2 = pp2 ? *pp2 : s_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(void* p0, struct s_r4r4r4r4_ p1, struct s_r4r4_ p2, float p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Sprite Create(UnityEngine.Texture2D, UnityEngine.Rect, UnityEngine.Vector2, Single, UInt32)
static bool w_oos_r4r4r4r4_s_r4r4_r4u4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oos_r4r4r4r4_s_r4r4_r4u4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4_>(context, info[2]);
    s_r4r4_ p2 = pp2 ? *pp2 : s_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(void* p0, struct s_r4r4r4r4_ p1, struct s_r4r4_ p2, float p3, uint32_t p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Sprite Create(UnityEngine.Texture2D, UnityEngine.Rect, UnityEngine.Vector2, Single, UInt32, UnityEngine.SpriteMeshType)
static bool w_oos_r4r4r4r4_s_r4r4_r4u4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oos_r4r4r4r4_s_r4r4_r4u4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4_>(context, info[2]);
    s_r4r4_ p2 = pp2 ? *pp2 : s_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void* (*FuncToCall)(void* p0, struct s_r4r4r4r4_ p1, struct s_r4r4_ p2, float p3, uint32_t p4, int32_t p5, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Sprite Create(UnityEngine.Texture2D, UnityEngine.Rect, UnityEngine.Vector2, Single, UInt32, UnityEngine.SpriteMeshType, UnityEngine.Vector4)
static bool w_oos_r4r4r4r4_s_r4r4_r4u4i4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oos_r4r4r4r4_s_r4r4_r4u4i4s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if ((!info[6]->IsObject() || !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4_>(context, info[2]);
    s_r4r4_ p2 = pp2 ? *pp2 : s_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp6 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[6]);
    s_r4r4r4r4_ p6 = pp6 ? *pp6 : s_r4r4r4r4_ {};

    typedef void* (*FuncToCall)(void* p0, struct s_r4r4r4r4_ p1, struct s_r4r4_ p2, float p3, uint32_t p4, int32_t p5, struct s_r4r4r4r4_ p6, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Sprite Create(UnityEngine.Texture2D, UnityEngine.Rect, UnityEngine.Vector2, Single, UInt32, UnityEngine.SpriteMeshType, UnityEngine.Vector4, Boolean)
static bool w_oos_r4r4r4r4_s_r4r4_r4u4i4s_r4r4r4r4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oos_r4r4r4r4_s_r4r4_r4u4i4s_r4r4r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if ((!info[6]->IsObject() || !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4_>(context, info[2]);
    s_r4r4_ p2 = pp2 ? *pp2 : s_r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp6 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[6]);
    s_r4r4r4r4_ p6 = pp6 ? *pp6 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);

    typedef void* (*FuncToCall)(void* p0, struct s_r4r4r4r4_ p1, struct s_r4r4_ p2, float p3, uint32_t p4, int32_t p5, struct s_r4r4r4r4_ p6, bool p7, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.UIPackage AddPackage(Byte[], System.String, LoadResource)
static bool w_ooso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ooso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener DelayedCall(Single)
static bool w_or4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_or4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(float p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener To(Single, Single, Single)
static bool w_or4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_or4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(float p0, float p1, float p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.AnimationCurve Linear(Single, Single, Single, Single)
static bool w_or4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_or4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(float p0, float p1, float p2, float p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener ToDouble(Double, Double, Single)
static bool w_or8r8r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_or8r8r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<double>::accept(context, info[0])) return false;
        if (!converter::Converter<double>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(context, info[0]);
    // JSValToCSVal P any
    double p1 = converter::Converter<double>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(double p0, double p1, float p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Shader GetShader(System.String)
static bool w_os(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Profiling.CustomSampler Create(System.String, Boolean)
static bool w_osDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_osDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void* (*FuncToCall)(void* p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.AsyncOperation UnloadSceneAsync(UnityEngine.SceneManagement.Scene)
static bool w_os_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4_* pp0 = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p0 = pp0 ? *pp0 : s_i4_ {};

    typedef void* (*FuncToCall)(struct s_i4_ p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.AsyncOperation UnloadSceneAsync(UnityEngine.SceneManagement.Scene, UnityEngine.SceneManagement.UnloadSceneOptions)
static bool w_os_i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_i4_* pp0 = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p0 = pp0 ? *pp0 : s_i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(struct s_i4_ p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.Generic.IEnumerable`1[System.Single] GetSupportedFrameRatesForResolution(UnityEngine.Resolution)
static bool w_os_i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4_>(context, info[0]);
    s_i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4_ {};

    typedef void* (*FuncToCall)(struct s_i4i4i4_ p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.RenderTexture GetTemporary(UnityEngine.RenderTextureDescriptor)
static bool w_os_i4i4i4i4i4i4i4i4i4i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(context, info[0]);
    s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};

    typedef void* (*FuncToCall)(struct s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener To(UnityEngine.Vector2, UnityEngine.Vector2, Single)
static bool w_os_r4r4_s_r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4_s_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, float p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener Shake(UnityEngine.Vector3, Single, Single)
static bool w_os_r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, float p1, float p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener To(UnityEngine.Vector3, UnityEngine.Vector3, Single)
static bool w_os_r4r4r4_s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4_s_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener To(UnityEngine.Vector4, UnityEngine.Vector4, Single)
static bool w_os_r4r4r4r4_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4r4_s_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, float p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Plane[] CalculateFrustumPlanes(UnityEngine.Matrix4x4)
static bool w_os_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void* (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.WSA.Tile CreateOrUpdateSecondary(UnityEngine.WSA.SecondaryTileData)
static bool w_os_si4u1u1u1u1bsi4sbsbbbbssssss_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_si4u1u1u1u1bsi4sbsbbbbssssss_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_si4u1u1u1u1bsi4sbsbbbbssssss_* pp0 = DataTransfer::GetPointer<s_si4u1u1u1u1bsi4sbsbbbbssssss_>(context, info[0]);
    s_si4u1u1u1u1bsi4sbsbbbbssssss_ p0 = pp0 ? *pp0 : s_si4u1u1u1u1bsi4sbsbbbbssssss_ {};

    typedef void* (*FuncToCall)(struct s_si4u1u1u1u1bsi4sbsbbbbssssss_ p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.WSA.Tile CreateOrUpdateSecondary(UnityEngine.WSA.SecondaryTileData, UnityEngine.Vector2)
static bool w_os_si4u1u1u1u1bsi4sbsbbbbssssss_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_si4u1u1u1u1bsi4sbsbbbbssssss_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_si4u1u1u1u1bsi4sbsbbbbssssss_* pp0 = DataTransfer::GetPointer<s_si4u1u1u1u1bsi4sbsbbbbssssss_>(context, info[0]);
    s_si4u1u1u1u1bsi4sbsbbbbssssss_ p0 = pp0 ? *pp0 : s_si4u1u1u1u1bsi4sbsbbbbssssss_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef void* (*FuncToCall)(struct s_si4u1u1u1u1bsi4sbsbbbbssssss_ p0, struct s_r4r4_ p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.WSA.Tile CreateOrUpdateSecondary(UnityEngine.WSA.SecondaryTileData, UnityEngine.Rect)
static bool w_os_si4u1u1u1u1bsi4sbsbbbbssssss_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_os_si4u1u1u1u1bsi4sbsbbbbssssss_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_si4u1u1u1u1bsi4sbsbbbbssssss_* pp0 = DataTransfer::GetPointer<s_si4u1u1u1u1bsi4sbsbbbbssssss_>(context, info[0]);
    s_si4u1u1u1u1bsi4sbsbbbbssssss_ p0 = pp0 ? *pp0 : s_si4u1u1u1u1bsi4sbsbbbbssssss_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef void* (*FuncToCall)(struct s_si4u1u1u1u1bsi4sbsbbbbssssss_ p0, struct s_r4r4r4r4_ p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Camera CreateCamera(System.String, Int32)
static bool w_osi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_osi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.TouchScreenKeyboard Open(System.String, UnityEngine.TouchScreenKeyboardType, Boolean)
static bool w_osi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_osi4b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, bool p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.TouchScreenKeyboard Open(System.String, UnityEngine.TouchScreenKeyboardType, Boolean, Boolean)
static bool w_osi4bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_osi4bb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, bool p2, bool p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.TouchScreenKeyboard Open(System.String, UnityEngine.TouchScreenKeyboardType, Boolean, Boolean, Boolean)
static bool w_osi4bbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_osi4bbb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, bool p2, bool p3, bool p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.TouchScreenKeyboard Open(System.String, UnityEngine.TouchScreenKeyboardType, Boolean, Boolean, Boolean, Boolean)
static bool w_osi4bbbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_osi4bbbb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!converter::Converter<bool>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(context, info[5]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, bool p2, bool p3, bool p4, bool p5, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.TouchScreenKeyboard Open(System.String, UnityEngine.TouchScreenKeyboardType, Boolean, Boolean, Boolean, Boolean, System.String)
static bool w_osi4bbbbs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_osi4bbbbs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!converter::Converter<bool>::accept(context, info[5])) return false;
        if (!info[6]->IsString() && !info[6]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(context, info[5]);
    // JSValToCSVal s
    v8::String::Utf8Value tp6(isolate, info[6]);
    void* p6 = CStringToCSharpString(*tp6);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, bool p2, bool p3, bool p4, bool p5, void* p6, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.TouchScreenKeyboard Open(System.String, UnityEngine.TouchScreenKeyboardType, Boolean, Boolean, Boolean, Boolean, System.String, Int32)
static bool w_osi4bbbbsi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_osi4bbbbsi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!converter::Converter<bool>::accept(context, info[5])) return false;
        if (!info[6]->IsString() && !info[6]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(context, info[5]);
    // JSValToCSVal s
    v8::String::Utf8Value tp6(isolate, info[6]);
    void* p6 = CStringToCSharpString(*tp6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, bool p2, bool p3, bool p4, bool p5, void* p6, int32_t p7, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.UIPackage AddPackage(System.String, LoadResource)
static bool w_oso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GObject CreateObject(System.String, System.String)
static bool w_oss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.AsyncOperation LoadSceneAsync(System.String, UnityEngine.SceneManagement.LoadSceneParameters)
static bool w_oss_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oss_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4_>(context, info[1]);
    s_i4i4_ p1 = pp1 ? *pp1 : s_i4i4_ {};

    typedef void* (*FuncToCall)(void* p0, struct s_i4i4_ p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GObject CreateObject(System.String, System.String, System.Type)
static bool w_osso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_osso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.DisplayObject[] GetChildren()
static bool w_ot(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ot");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener SetTarget(System.Object)
static bool w_otO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener SetTarget(System.Object, FairyGUI.TweenPropType)
static bool w_otOi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otOi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.Generic.IEnumerator`1[FairyGUI.DisplayObject] GetDescendants(Boolean)
static bool w_otb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otb");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,bool p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.DisplayObject GetChildAt(Int32)
static bool w_oti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener SetRepeat(Int32, Boolean)
static bool w_oti4Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4Db");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void* (*FuncToCall)(void*,int32_t p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.DisplayObject RemoveChildAt(Int32, Boolean)
static bool w_oti4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4b");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,int32_t p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Color[] GetPixels(UnityEngine.CubemapFace, Int32)
static bool w_oti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Color[] GetPixels(UnityEngine.CubemapFace, Int32, Int32)
static bool w_oti4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Color[] GetPixels(Int32, Int32, Int32, Int32)
static bool w_oti4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Color[] GetPixels(Int32, Int32, Int32, Int32, Int32)
static bool w_oti4i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4i4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void* (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Material GetMaterial(Int32, FairyGUI.BlendMode, UInt32)
static bool w_oti4i4u4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4i4u4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void*,int32_t p0, int32_t p1, uint32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener SetEase(FairyGUI.EaseType, FairyGUI.CustomEase)
static bool w_oti4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// GCore.HtpServer NewServer(Int32, System.String)
static bool w_oti4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.Generic.List`1[GCore.FVector3] C_FindPath(Int32, GCore.FVector3, GCore.FVector3)
static bool w_oti4s_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4s_i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef void* (*FuncToCall)(void*,int32_t p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// GCore.PhyHitInfo[] C_PhyRaycastAll(Int32, GCore.FVector3, GCore.FVector3, Int64, Int32 ByRef)
static bool w_oti4s_i8i8i8_s_i8i8i8_i8Pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti4s_i8i8i8_s_i8i8i8_i8Pi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!info[4]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P primitive
    int32_t up4 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(context, info[4]);
    int32_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }

    typedef void* (*FuncToCall)(void*,int32_t p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, int64_t p3, int32_t* p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int32_t>::toScript(context, *p4));
    }
    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// GCore.C_GridMap CreateGridMap(Int64, Int64, Int32, Int32, Int32)
static bool w_oti8i8Di4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oti8i8Di4Di4Di4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef void* (*FuncToCall)(void*,int64_t p0, int64_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.DisplayObject AddChild(FairyGUI.DisplayObject)
static bool w_oto(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_oto");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.IEnumerator checkDBUpdate(System.Action`2[System.Int64,System.Int32], Boolean)
static bool w_otoDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otoDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void* (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.DisplayObject RemoveChild(FairyGUI.DisplayObject, Boolean)
static bool w_otob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otob");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.DisplayObject AddChildAt(FairyGUI.DisplayObject, Int32)
static bool w_otoi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otoi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// Byte[] ReadBytes(Byte[], Int32, Int32)
static bool w_otoi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otoi4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Rect[] PackTextures(UnityEngine.Texture2D[], Int32, Int32, Boolean)
static bool w_otoi4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otoi4i4b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, bool p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.Utils.IHtmlObject CreateObject(FairyGUI.RichTextField, FairyGUI.Utils.HtmlElement)
static bool w_otoo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otoo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GObject GetChildInGroup(FairyGUI.GGroup, System.String)
static bool w_otos(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otos");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Component AddOrGetComponent(UnityEngine.GameObject, System.String, Boolean)
static bool w_otosDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otosDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, bool p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Runtime.Serialization.ISerializationSurrogate GetSurrogate(System.Type, System.Runtime.Serialization.StreamingContext, System.Runtime.Serialization.ISurrogateSelector ByRef)
static bool w_otos_Oi4_Po(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otos_Oi4_Po");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_Oi4_* pp1 = DataTransfer::GetPointer<s_Oi4_>(context, info[1]);
    s_Oi4_ p1 = pp1 ? *pp1 : s_Oi4_ {};
    // JSValToCSVal Po/PO
    void* up2 = nullptr; // object ref
    void** p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        up2 = JsValueToCSRef(context, tp2, TIp2);
    }
        

    typedef void* (*FuncToCall)(void*,void* p0, struct s_Oi4_ p1, void** p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, CSRefToJsValue(isolate, context, *p2));
    }
    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.IEnumerator Print(Single)
static bool w_otr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otr4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,float p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener TweenMoveX(Single, Single)
static bool w_otr4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otr4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,float p0, float p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener TweenValue(Double, Single)
static bool w_otr8r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otr8r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<double>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,double p0, float p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.DisplayObject GetChild(System.String)
static bool w_ots(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.IEnumerator loadScene(System.String, UnityEngine.SceneManagement.LoadSceneMode, System.Action`2[System.Single,System.Boolean])
static bool w_otsDi4Do(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsDi4Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal ref  with default
    void* p2 = OptionalParameter<void*>::GetRefType(context, info, method, 2, TIp2);
                

    typedef void* (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.Generic.List`1[System.String] collectDependences(System.String, System.Collections.Generic.List`1[System.String])
static bool w_otsDo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal ref  with default
    void* p1 = OptionalParameter<void*>::GetRefType(context, info, method, 1, TIp1);
                

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Object[] DoString(System.String, System.String)
static bool w_otsDs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsDs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal string  with default
    void* p1 = OptionalParameter<void*>::GetString(context, info, method, 1);
                

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Coroutine StartCoroutine(System.String, System.Object)
static bool w_otsO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Object[] CallFunction(System.String, System.Object[])
static bool w_otsVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsVO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal ref params
    void* p1 = RestArguments<void*>::PackRef(context, info, TIp1, 1);
                

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Texture2D GetScreenShot(System.Nullable`1[FairyGUI.Margin], Single)
static bool w_ots_bi4i4i4i4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots_bi4i4i4i4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_bi4i4i4i4_* pp0 = DataTransfer::GetPointer<s_bi4i4i4i4_>(context, info[0]);
    s_bi4i4i4i4_ p0 = pp0 ? *pp0 : s_bi4i4i4i4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,struct s_bi4i4i4i4_ p0, float p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// Int32[] GetTriangleOccupyCells(GCore.FVector3, GCore.FVector3, GCore.FVector3)
static bool w_ots_i8i8i8_s_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots_i8i8i8_s_i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef void* (*FuncToCall)(void*,struct s_i8i8i8_ p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// Int32[] GetRectOccupyCells(GCore.FVector3, GCore.FVector3, GCore.FVector3, GCore.FVector3)
static bool w_ots_i8i8i8_s_i8i8i8_s_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots_i8i8i8_s_i8i8i8_s_i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp3 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[3]);
    s_i8i8i8_ p3 = pp3 ? *pp3 : s_i8i8i8_ {};

    typedef void* (*FuncToCall)(void*,struct s_i8i8i8_ p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, struct s_i8i8i8_ p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.DisplayObject HitTest(UnityEngine.Vector2, Boolean)
static bool w_ots_r4r4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots_r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,struct s_r4r4_ p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTweener TweenMove(UnityEngine.Vector2, Single)
static bool w_ots_r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,struct s_r4r4_ p0, float p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// Client.LineRendererHelp Init(UnityEngine.Vector3, UnityEngine.Vector3, Int32)
static bool w_ots_r4r4r4_s_r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ots_r4r4r4_s_r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void* (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, int32_t p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// Puerts.ArrayBuffer LoadEditorMap(System.String, Boolean)
static bool w_otsb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.String[] GetAttributeArray(System.String, Char)
static bool w_otsc(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsc");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,void* p0, Il2CppChar p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GButton AddItemAt(System.String, Int32, FairyGUI.EventCallback1)
static bool w_otsi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsi4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GButton AddItem(System.String, FairyGUI.EventCallback0)
static bool w_otso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// FairyGUI.GTextField SetVar(System.String, System.String)
static bool w_otss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.Generic.List`1[System.Int64] FindNavPath(System.String, GCore.FVector3, GCore.FVector3)
static bool w_otss_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otss_i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef void* (*FuncToCall)(void*,void* p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.IEnumerator getWebRequestTexture(System.String, System.String, System.Action`1[UnityEngine.Texture2D])
static bool w_otsso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.AssetBundle loadBundle(System.String, UInt32)
static bool w_otsu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsu4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,void* p0, uint32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// System.Collections.IEnumerator syncLoadBundle(System.String, UInt32, System.Action`1[UnityEngine.AssetBundle])
static bool w_otsu4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otsu4o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void* (*FuncToCall)(void*,void* p0, uint32_t p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// GCore.PhyHitInfo[] C_DoPhyTest(UInt32, Int32 ByRef)
static bool w_otu4Pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_otu4Pi4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(context, info[1]);
    int32_t* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }

    typedef void* (*FuncToCall)(void*,uint32_t p0, int32_t* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<int32_t>::toScript(context, *p1));
    }
    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
    return true;
}

// IntPtr GetGlobalEventQueue()
static bool w_p(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_p");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef void* (*FuncToCall)(const void* method);
    void* ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr grid_create(Int64 ByRef, Int64 ByRef, Int32, Int32, Int32)
static bool w_pPi8Pi8Di4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pPi8Pi8Di4Di4Di4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P primitive
    int64_t up0 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[0]);
    int64_t* p0 = &up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up1 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[1]);
    int64_t* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef void* (*FuncToCall)(int64_t* p0, int64_t* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op0.IsEmpty())
    {
        auto _unused = op0->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p0));
    }
    
    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p1));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr NewRvoSimulator(GCore.F64 ByRef)
static bool w_pPs_i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pPs_i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8_* p0 = nullptr; // valuetype ref
    s_i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef void* (*FuncToCall)(struct s_i8_* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr NewRandMap(Int32, Int32, Int32, GCore.F64 ByRef, Int32, Int32, Int32)
static bool w_pi4i4i4Ps_i8_i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pi4i4i4Ps_i8_i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal Pstruct
    s_i8_* p3 = nullptr; // valuetype ref
    s_i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef void* (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, struct s_i8_* p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr entt_create_world(Int32, IntPtr, Int64 ByRef, Int64 ByRef, GCore.OnCollideCallback, GCore.RunActionCallback)
static bool w_pi4pPi8Pi8oo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pi4pPi8Pi8oo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[2]);
    int64_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);

    typedef void* (*FuncToCall)(int32_t p0, void* p1, int64_t* p2, int64_t* p3, void* p4, void* p5, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr load(Byte[])
static bool w_po(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_po");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr buildSimple(GCore.F64[], Int32, Int32[], Int32, Int64 ByRef, Int64 ByRef, Int64 ByRef, Int64 ByRef)
static bool w_poi4oi4Pi8Pi8Pi8Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_poi4oi4Pi8Pi8Pi8Pi8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsObject()) return false;
        if (!info[5]->IsObject()) return false;
        if (!info[6]->IsObject()) return false;
        if (!info[7]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P primitive
    int64_t up4 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[4]);
    int64_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up5 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[5]);
    int64_t* p5 = &up5;
    v8::Local<v8::Object> op5;
    if (!info[5].IsEmpty() && info[5]->IsObject()) {
        op5 = info[5]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up6 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[6]);
    int64_t* p6 = &up6;
    v8::Local<v8::Object> op6;
    if (!info[6].IsEmpty() && info[6]->IsObject()) {
        op6 = info[6]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up7 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[7]);
    int64_t* p7 = &up7;
    v8::Local<v8::Object> op7;
    if (!info[7].IsEmpty() && info[7]->IsObject()) {
        op7 = info[7]->ToObject(context).ToLocalChecked();
    }

    typedef void* (*FuncToCall)(void* p0, int32_t p1, void* p2, int32_t p3, int64_t* p4, int64_t* p5, int64_t* p6, int64_t* p7, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p4));
    }
    
    if (!op5.IsEmpty())
    {
        auto _unused = op5->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p5));
    }
    
    if (!op6.IsEmpty())
    {
        auto _unused = op6->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p6));
    }
    
    if (!op7.IsEmpty())
    {
        auto _unused = op7->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p7));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr build(GCore.F64[], Int32, Int32[], Int32, GCore.NavBuildSetting ByRef)
static bool w_poi4oi4Ps_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_poi4oi4Ps_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal Pstruct
    s_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_* p4 = nullptr; // valuetype ref
    s_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_ up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
        auto tp4 = op4->Get(context, 0).ToLocalChecked();
        p4 = DataTransfer::GetPointer<s_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_>(context, tp4);
    }
    if (!p4) {
        p4 = &up4;
    }
        

    typedef void* (*FuncToCall)(void* p0, int32_t p1, void* p2, int32_t p3, struct s_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_* p4, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op4.IsEmpty() && p4 == &up4)
    {
        auto _unused = op4->Set(context, 0, CopyValueType(isolate, context, TIp4, p4, sizeof(*p4)));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr SQLReader(IntPtr)
static bool w_pp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pp");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr entt_create_gridmap(IntPtr, Int64 ByRef, Int64 ByRef, Int32, Int32, Int32)
static bool w_ppPi8Pi8i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ppPi8Pi8i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P primitive
    int64_t up1 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[1]);
    int64_t* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[2]);
    int64_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void* (*FuncToCall)(void* p0, int64_t* p1, int64_t* p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p1));
    }
    
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p2));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr AddRVOObstacle(IntPtr, GCore.F64 ByRef, GCore.F64 ByRef, GCore.FVector3 ByRef)
static bool w_ppPs_i8_Ps_i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ppPs_i8_Ps_i8_Ps_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];
    auto TIp3 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8_* p1 = nullptr; // valuetype ref
    s_i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8_* p2 = nullptr; // valuetype ref
    s_i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef void* (*FuncToCall)(void* p0, struct s_i8_* p1, struct s_i8_* p2, struct s_i8i8i8_* p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr ReadText(IntPtr, Int32)
static bool w_ppi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ppi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr entt_set_phy_friction(IntPtr, UInt32, Int64 ByRef)
static bool w_ppu4Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ppu4Pi8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[2]);
    int64_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }

    typedef void* (*FuncToCall)(void* p0, uint32_t p1, int64_t* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p2));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr entt_add_meshphy(IntPtr, UInt32, Int64[], Int32, Int32[], Int32, Int32, Int64 ByRef, Int32, Int32, Int64 ByRef, Int32)
static bool w_ppu4oi4oi4i4Pi8i4i4Pi8i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ppu4oi4oi4i4Pi8i4i4Pi8i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 12) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[9])) return false;
        if (!info[10]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[11])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P primitive
    int64_t up7 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[7]);
    int64_t* p7 = &up7;
    v8::Local<v8::Object> op7;
    if (!info[7].IsEmpty() && info[7]->IsObject()) {
        op7 = info[7]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(context, info[9]);
    // JSValToCSVal P primitive
    int64_t up10 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[10]);
    int64_t* p10 = &up10;
    v8::Local<v8::Object> op10;
    if (!info[10].IsEmpty() && info[10]->IsObject()) {
        op10 = info[10]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(context, info[11]);

    typedef void* (*FuncToCall)(void* p0, uint32_t p1, void* p2, int32_t p3, void* p4, int32_t p5, int32_t p6, int64_t* p7, int32_t p8, int32_t p9, int64_t* p10, int32_t p11, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    if (!op7.IsEmpty())
    {
        auto _unused = op7->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p7));
    }
    
    if (!op10.IsEmpty())
    {
        auto _unused = op10->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p10));
    }
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr OpenPGSQL(System.String)
static bool w_ps(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ps");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr OpenSqlite(System.String, Int32, Byte[], Int32)
static bool w_psi4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_psi4oi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, void* p2, int32_t p3, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr GetNativeRenderBufferPtr()
static bool w_pt(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pt");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// IntPtr GetNativeVertexBufferPtr(Int32)
static bool w_pti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_pti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
    return true;
}

// Single get_devicePixelRatio()
static bool w_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef float (*FuncToCall)(const void* method);
    float ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Min(Single[])
static bool w_r4Vr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4Vr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
        if (!info[0]->IsNullOrUndefined() && !converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal primitive params
    void* p0 = RestArguments<float>::PackPrimitive(context, info, TIp0, 0);
                

    typedef float (*FuncToCall)(void* p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GetGlobalFloat(Int32)
static bool w_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef float (*FuncToCall)(int32_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Evaluate(FairyGUI.EaseType, Single, Single, Single, Single, FairyGUI.CustomEase)
static bool w_r4i4r4r4Dr4Dr4Do(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4i4r4r4Dr4Dr4Do");
    
    auto TIp5 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<float>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<float>::accept(context, info[4])) return false;
        if (length > 5 && !info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    float p4 = OptionalParameter<float>::GetPrimitive(context, info, method, 4);
                
    // JSValToCSVal ref  with default
    void* p5 = OptionalParameter<void*>::GetRefType(context, info, method, 5, TIp5);
                

    typedef float (*FuncToCall)(int32_t p0, float p1, float p2, float p3, float p4, void* p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single ExtractInnerCone(UnityEngine.Light)
static bool w_r4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4o");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef float (*FuncToCall)(void* p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GammaToLinearSpace(Single)
static bool w_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef float (*FuncToCall)(float p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single FocalLengthToFieldOfView(Single, Single)
static bool w_r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef float (*FuncToCall)(float p0, float p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single SmoothDamp(Single, Single, Single ByRef, Single)
static bool w_r4r4r4Pr4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4r4r4Pr4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[2]);
    float* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef float (*FuncToCall)(float p0, float p1, float* p2, float p3, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<float>::toScript(context, *p2));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single SmoothDamp(Single, Single, Single ByRef, Single, Single)
static bool w_r4r4r4Pr4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4r4r4Pr4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[2]);
    float* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef float (*FuncToCall)(float p0, float p1, float* p2, float p3, float p4, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<float>::toScript(context, *p2));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single SmoothDamp(Single, Single, Single ByRef, Single, Single, Single)
static bool w_r4r4r4Pr4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4r4r4Pr4r4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[2]);
    float* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef float (*FuncToCall)(float p0, float p1, float* p2, float p3, float p4, float p5, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<float>::toScript(context, *p2));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Clamp(Single, Single, Single)
static bool w_r4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4r4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef float (*FuncToCall)(float p0, float p1, float p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GetAttributeFloat(System.String)
static bool w_r4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef float (*FuncToCall)(void* p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Distance(UnityEngine.Vector2Int, UnityEngine.Vector2Int)
static bool w_r4s_i4i4_s_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_i4i4_s_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4_>(context, info[0]);
    s_i4i4_ p0 = pp0 ? *pp0 : s_i4i4_ {};
    // JSValToCSVal struct
    s_i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4_>(context, info[1]);
    s_i4i4_ p1 = pp1 ? *pp1 : s_i4i4_ {};

    typedef float (*FuncToCall)(struct s_i4i4_ p0, struct s_i4i4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Distance(UnityEngine.Vector3Int, UnityEngine.Vector3Int)
static bool w_r4s_i4i4i4_s_i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_i4i4i4_s_i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4_>(context, info[0]);
    s_i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4_ {};
    // JSValToCSVal struct
    s_i4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4_>(context, info[1]);
    s_i4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4_ {};

    typedef float (*FuncToCall)(struct s_i4i4i4_ p0, struct s_i4i4i4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single SqrMagnitude(UnityEngine.Vector2)
static bool w_r4s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Dot(UnityEngine.Vector2, UnityEngine.Vector2)
static bool w_r4s_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Magnitude(UnityEngine.Vector3)
static bool w_r4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Dot(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_r4s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single SignedAngle(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_r4s_r4r4r4_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4_s_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Magnitude(UnityEngine.Vector4)
static bool w_r4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4r4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Dot(UnityEngine.Quaternion, UnityEngine.Quaternion)
static bool w_r4s_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Determinant(UnityEngine.Matrix4x4)
static bool w_r4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef float (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GetAttributeFloat(System.String, Single)
static bool w_r4sr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4sr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef float (*FuncToCall)(void* p0, float p1, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single get_alpha()
static bool w_r4t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef float (*FuncToCall)(void*,const void* method);
    float ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GetSegmentLength(Int32)
static bool w_r4ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4ti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef float (*FuncToCall)(void*,int32_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GetBlendShapeFrameWeight(Int32, Int32)
static bool w_r4ti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4ti4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef float (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single Evaluate(Single)
static bool w_r4tr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4tr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef float (*FuncToCall)(void*,float p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GetLabelTime(System.String)
static bool w_r4ts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4ts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef float (*FuncToCall)(void*,void* p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single SqrDistance(UnityEngine.Vector3)
static bool w_r4ts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4ts_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef float (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single GetFloat(System.String, Single)
static bool w_r4tsr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4tsr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef float (*FuncToCall)(void*,void* p0, float p1, const void* method);
    float ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Single HalfToFloat(UInt16)
static bool w_r4u2(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r4u2");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint16_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(context, info[0]);

    typedef float (*FuncToCall)(uint16_t p0, const void* method);
    float ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Double get_timeAsDouble()
static bool w_r8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef double (*FuncToCall)(const void* method);
    double ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Double ReadDouble(IntPtr, Int32)
static bool w_r8pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r8pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef double (*FuncToCall)(void* p0, int32_t p1, const void* method);
    double ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Double get_min()
static bool w_r8t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r8t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef double (*FuncToCall)(void*,const void* method);
    double ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Double ReadDouble(Int32)
static bool w_r8ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_r8ti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef double (*FuncToCall)(void*,int32_t p0, const void* method);
    double ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// System.String get_branch()
static bool w_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef void* (*FuncToCall)(const void* method);
    void* ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetRawText(Boolean)
static bool w_sDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sDb");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<bool>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(context, info, method, 0);
                

    typedef void* (*FuncToCall)(bool p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ExtractStringFromException(System.Object)
static bool w_sO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sO");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// MeshDataArray AllocateWritableMeshData(Int32)
static bool w_s_Ppi4i4i4pi4i4o_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_Ppi4i4i4pi4i4o_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_Ppi4i4i4pi4i4o_ (*FuncToCall)(int32_t p0, const void* method);
    struct s_Ppi4i4i4pi4i4o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// MeshDataArray AcquireReadOnlyMeshData(UnityEngine.Mesh)
static bool w_s_Ppi4i4i4pi4i4o_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_Ppi4i4i4pi4i4o_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef struct s_Ppi4i4i4pi4i4o_ (*FuncToCall)(void* p0, const void* method);
    struct s_Ppi4i4i4pi4i4o_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Unity.Collections.NativeArray`1[UnityEngine.BoneWeight1] GetAllBoneWeights()
static bool w_s_Pvi4i4i4pi4i4oi4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_Pvi4i4i4pi4i4oi4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_Pvi4i4i4pi4i4oi4_ (*FuncToCall)(void*,const void* method);
    struct s_Pvi4i4i4pi4i4oi4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Unity.Collections.NativeArray`1[UnityEngine.Matrix4x4] GetBatchMatrices(Int32)
static bool w_s_Pvi4i4i4pi4i4oi4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_Pvi4i4i4pi4i4oi4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_Pvi4i4i4pi4i4oi4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_Pvi4i4i4pi4i4oi4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Unity.Collections.NativeArray`1[System.Int32] GetBatchScalarArrayInt(Int32, Int32)
static bool w_s_Pvi4i4i4pi4i4oi4_ti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_Pvi4i4i4pi4i4oi4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef struct s_Pvi4i4i4pi4i4oi4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    struct s_Pvi4i4i4pi4i4oi4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Unity.Collections.NativeArray`1[System.Int32] GetBatchScalarArrayInt(Int32, System.String)
static bool w_s_Pvi4i4i4pi4i4oi4_ti4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_Pvi4i4i4pi4i4oi4_ti4s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef struct s_Pvi4i4i4pi4i4oi4_ (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    struct s_Pvi4i4i4pi4i4oi4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.Nullable`1[GCore.GIMsg] ConsumeReceiveMsg()
static bool w_s_bi4o_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_bi4o_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_bi4o_ (*FuncToCall)(void*,const void* method);
    struct s_bi4o_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.Nullable`1[UnityEngine.Rect] get_clipRect()
static bool w_s_br4r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_br4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_br4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_br4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.SortingLayerRange get_all()
static bool w_s_i2i2_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i2i2_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_i2i2_ (*FuncToCall)(const void* method);
    struct s_i2i2_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.SortingLayerRange get_sortingLayerRange()
static bool w_s_i2i2_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i2i2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i2i2_ (*FuncToCall)(void*,const void* method);
    struct s_i2i2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Cache get_defaultCache()
static bool w_s_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_i4_ (*FuncToCall)(const void* method);
    struct s_i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Cache GetCacheAt(Int32)
static bool w_s_i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct s_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.SceneManagement.Scene LoadScene(Int32, UnityEngine.SceneManagement.LoadSceneParameters)
static bool w_s_i4_i4s_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4_i4s_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4_>(context, info[1]);
    s_i4i4_ p1 = pp1 ? *pp1 : s_i4i4_ {};

    typedef struct s_i4_ (*FuncToCall)(int32_t p0, struct s_i4i4_ p1, const void* method);
    struct s_i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Cache AddCache(System.String)
static bool w_s_i4_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_i4_ (*FuncToCall)(void* p0, const void* method);
    struct s_i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.SceneManagement.Scene CreateScene(System.String, UnityEngine.SceneManagement.CreateSceneParameters)
static bool w_s_i4_ss_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4_ss_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_i4_* pp1 = DataTransfer::GetPointer<s_i4_>(context, info[1]);
    s_i4_ p1 = pp1 ? *pp1 : s_i4_ {};

    typedef struct s_i4_ (*FuncToCall)(void* p0, struct s_i4_ p1, const void* method);
    struct s_i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.SceneManagement.Scene LoadScene(System.String, UnityEngine.SceneManagement.LoadSceneParameters)
static bool w_s_i4_ss_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4_ss_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4_>(context, info[1]);
    s_i4i4_ p1 = pp1 ? *pp1 : s_i4i4_ {};

    typedef struct s_i4_ (*FuncToCall)(void* p0, struct s_i4i4_ p1, const void* method);
    struct s_i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.SceneManagement.Scene get_scene()
static bool w_s_i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4_ (*FuncToCall)(void*,const void* method);
    struct s_i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.ShaderTagId GetShaderPassName(Int32)
static bool w_s_i4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.ShaderTagId FindPassTagValue(Int32, Int32, UnityEngine.Rendering.ShaderTagId)
static bool w_s_i4_ti4i4s_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4_ti4i4s_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_i4_* pp2 = DataTransfer::GetPointer<s_i4_>(context, info[2]);
    s_i4_ p2 = pp2 ? *pp2 : s_i4_ {};

    typedef struct s_i4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, struct s_i4_ p2, const void* method);
    struct s_i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.ShaderTagId FindPassTagValue(Int32, UnityEngine.Rendering.ShaderTagId)
static bool w_s_i4_ti4s_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4_ti4s_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i4_* pp1 = DataTransfer::GetPointer<s_i4_>(context, info[1]);
    s_i4_ p1 = pp1 ? *pp1 : s_i4_ {};

    typedef struct s_i4_ (*FuncToCall)(void*,int32_t p0, struct s_i4_ p1, const void* method);
    struct s_i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2Int get_mainWindowPosition()
static bool w_s_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_i4i4_ (*FuncToCall)(const void* method);
    struct s_i4i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.PropertyName op_Implicit(Int32)
static bool w_s_i4i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_i4i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct s_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2Int op_Multiply(Int32, UnityEngine.Vector2Int)
static bool w_s_i4i4_i4s_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4_i4s_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4_>(context, info[1]);
    s_i4i4_ p1 = pp1 ? *pp1 : s_i4i4_ {};

    typedef struct s_i4i4_ (*FuncToCall)(int32_t p0, struct s_i4i4_ p1, const void* method);
    struct s_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.PropertyName op_Implicit(System.String)
static bool w_s_i4i4_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_i4i4_ (*FuncToCall)(void* p0, const void* method);
    struct s_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2Int op_UnaryNegation(UnityEngine.Vector2Int)
static bool w_s_i4i4_s_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4_s_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4_>(context, info[0]);
    s_i4i4_ p0 = pp0 ? *pp0 : s_i4i4_ {};

    typedef struct s_i4i4_ (*FuncToCall)(struct s_i4i4_ p0, const void* method);
    struct s_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2Int op_Multiply(UnityEngine.Vector2Int, Int32)
static bool w_s_i4i4_s_i4i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4_s_i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4_>(context, info[0]);
    s_i4i4_ p0 = pp0 ? *pp0 : s_i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef struct s_i4i4_ (*FuncToCall)(struct s_i4i4_ p0, int32_t p1, const void* method);
    struct s_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2Int Min(UnityEngine.Vector2Int, UnityEngine.Vector2Int)
static bool w_s_i4i4_s_i4i4_s_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4_s_i4i4_s_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4_>(context, info[0]);
    s_i4i4_ p0 = pp0 ? *pp0 : s_i4i4_ {};
    // JSValToCSVal struct
    s_i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4_>(context, info[1]);
    s_i4i4_ p1 = pp1 ? *pp1 : s_i4i4_ {};

    typedef struct s_i4i4_ (*FuncToCall)(struct s_i4i4_ p0, struct s_i4i4_ p1, const void* method);
    struct s_i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2Int op_Explicit(UnityEngine.Vector3Int)
static bool w_s_i4i4_s_i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4_s_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4_>(context, info[0]);
    s_i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4_ {};

    typedef struct s_i4i4_ (*FuncToCall)(struct s_i4i4i4_ p0, const void* method);
    struct s_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2Int FloorToInt(UnityEngine.Vector2)
static bool w_s_i4i4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef struct s_i4i4_ (*FuncToCall)(struct s_r4r4_ p0, const void* method);
    struct s_i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2Int get_min()
static bool w_s_i4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4i4_ (*FuncToCall)(void*,const void* method);
    struct s_i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Resolution get_currentResolution()
static bool w_s_i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_i4i4i4_ (*FuncToCall)(const void* method);
    struct s_i4i4i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3Int op_Multiply(Int32, UnityEngine.Vector3Int)
static bool w_s_i4i4i4_i4s_i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4_i4s_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4_>(context, info[1]);
    s_i4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4_ {};

    typedef struct s_i4i4i4_ (*FuncToCall)(int32_t p0, struct s_i4i4i4_ p1, const void* method);
    struct s_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3Int op_Explicit(UnityEngine.Vector2Int)
static bool w_s_i4i4i4_s_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4_s_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4_>(context, info[0]);
    s_i4i4_ p0 = pp0 ? *pp0 : s_i4i4_ {};

    typedef struct s_i4i4i4_ (*FuncToCall)(struct s_i4i4_ p0, const void* method);
    struct s_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3Int op_UnaryNegation(UnityEngine.Vector3Int)
static bool w_s_i4i4i4_s_i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4_s_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4_>(context, info[0]);
    s_i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4_ {};

    typedef struct s_i4i4i4_ (*FuncToCall)(struct s_i4i4i4_ p0, const void* method);
    struct s_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3Int op_Multiply(UnityEngine.Vector3Int, Int32)
static bool w_s_i4i4i4_s_i4i4i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4_s_i4i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4_>(context, info[0]);
    s_i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef struct s_i4i4i4_ (*FuncToCall)(struct s_i4i4i4_ p0, int32_t p1, const void* method);
    struct s_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3Int Min(UnityEngine.Vector3Int, UnityEngine.Vector3Int)
static bool w_s_i4i4i4_s_i4i4i4_s_i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4_s_i4i4i4_s_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4_>(context, info[0]);
    s_i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4_ {};
    // JSValToCSVal struct
    s_i4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4_>(context, info[1]);
    s_i4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4_ {};

    typedef struct s_i4i4i4_ (*FuncToCall)(struct s_i4i4i4_ p0, struct s_i4i4i4_ p1, const void* method);
    struct s_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3Int FloorToInt(UnityEngine.Vector3)
static bool w_s_i4i4i4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_i4i4i4_ (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    struct s_i4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3Int get_min()
static bool w_s_i4i4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct s_i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// State get_state()
static bool w_s_i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_i4i4i4i4_ (*FuncToCall)(const void* method);
    struct s_i4i4i4i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// FairyGUI.Margin get_margin()
static bool w_s_i4i4i4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct s_i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.VertexAttributeDescriptor GetVertexAttribute(Int32)
static bool w_s_i4i4i4i4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_i4i4i4i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.LightBakingOutput get_bakingOutput()
static bool w_s_i4i4i4i4b_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4i4b_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4i4i4i4b_ (*FuncToCall)(void*,const void* method);
    struct s_i4i4i4i4b_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// PositionEnumerator get_allPositionsWithin()
static bool w_s_i4i4i4i4i4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4i4i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct s_i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// PositionEnumerator get_allPositionsWithin()
static bool w_s_i4i4i4i4i4i4i4i4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4i4i4i4i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4i4i4i4i4i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct s_i4i4i4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.RenderTextureDescriptor get_descriptor()
static bool w_s_i4i4i4i4i4i4i4i4i4i4i4i4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4i4i4i4i4i4i4i4i4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ (*FuncToCall)(void*,const void* method);
    struct s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.RenderTargetIdentifier op_Implicit(UnityEngine.Rendering.BuiltinRenderTextureType)
static bool w_s_i4i4i4pi4i4i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4pi4i4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_i4i4i4pi4i4i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct s_i4i4i4pi4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.RenderTargetIdentifier op_Implicit(UnityEngine.Texture)
static bool w_s_i4i4i4pi4i4i4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4pi4i4i4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef struct s_i4i4i4pi4i4i4_ (*FuncToCall)(void* p0, const void* method);
    struct s_i4i4i4pi4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.RenderTargetIdentifier op_Implicit(System.String)
static bool w_s_i4i4i4pi4i4i4_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4pi4i4i4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_i4i4i4pi4i4i4_ (*FuncToCall)(void* p0, const void* method);
    struct s_i4i4i4pi4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.RenderTargetIdentifier op_Implicit(UnityEngine.RenderBuffer)
static bool w_s_i4i4i4pi4i4i4_s_i4p_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4pi4i4i4_s_i4p_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4p_* pp0 = DataTransfer::GetPointer<s_i4p_>(context, info[0]);
    s_i4p_ p0 = pp0 ? *pp0 : s_i4p_ {};

    typedef struct s_i4i4i4pi4i4i4_ (*FuncToCall)(struct s_i4p_ p0, const void* method);
    struct s_i4i4i4pi4i4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.RenderTargetIdentifier get_depthRenderTarget()
static bool w_s_i4i4i4pi4i4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4pi4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4i4i4pi4i4i4_ (*FuncToCall)(void*,const void* method);
    struct s_i4i4i4pi4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.FilteringSettings get_defaultValue()
static bool w_s_i4i4i4u4i4i2i2_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4i4u4i4i2i2_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_i4i4i4u4i4i2i2_ (*FuncToCall)(const void* method);
    struct s_i4i4i4u4i4i2i2_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.RasterState get_rasterState()
static bool w_s_i4i4r4u1u1u1u1_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4i4r4u1u1u1u1_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4i4r4u1u1u1u1_ (*FuncToCall)(void*,const void* method);
    struct s_i4i4r4u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.RenderBuffer get_activeColorBuffer()
static bool w_s_i4p_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4p_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_i4p_ (*FuncToCall)(const void* method);
    struct s_i4p_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.RenderBuffer get_colorBuffer()
static bool w_s_i4p_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4p_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4p_ (*FuncToCall)(void*,const void* method);
    struct s_i4p_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Experimental.GlobalIllumination.Cookie Defaults()
static bool w_s_i4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_i4r4r4r4_ (*FuncToCall)(const void* method);
    struct s_i4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.LODParameters get_lodParameters()
static bool w_s_i4r4r4r4r4r4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4r4r4r4r4r4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4r4r4r4r4r4i4_ (*FuncToCall)(void*,const void* method);
    struct s_i4r4r4r4r4r4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.ShadowSplitData get_splitData()
static bool w_s_i4u1r4r4r4r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4u1r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4u1r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_i4u1r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color32 Lerp(UnityEngine.Color32, UnityEngine.Color32, Single)
static bool w_s_i4u1u1u1u1_s_i4u1u1u1u1_s_i4u1u1u1u1_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4u1u1u1u1_s_i4u1u1u1u1_s_i4u1u1u1u1_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_i4u1u1u1u1_* pp0 = DataTransfer::GetPointer<s_i4u1u1u1u1_>(context, info[0]);
    s_i4u1u1u1u1_ p0 = pp0 ? *pp0 : s_i4u1u1u1u1_ {};
    // JSValToCSVal struct
    s_i4u1u1u1u1_* pp1 = DataTransfer::GetPointer<s_i4u1u1u1u1_>(context, info[1]);
    s_i4u1u1u1u1_ p1 = pp1 ? *pp1 : s_i4u1u1u1u1_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_i4u1u1u1u1_ (*FuncToCall)(struct s_i4u1u1u1u1_ p0, struct s_i4u1u1u1u1_ p1, float p2, const void* method);
    struct s_i4u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color32 op_Implicit(UnityEngine.Color)
static bool w_s_i4u1u1u1u1_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4u1u1u1u1_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef struct s_i4u1u1u1u1_ (*FuncToCall)(struct s_r4r4r4r4_ p0, const void* method);
    struct s_i4u1u1u1u1_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color32 get_color()
static bool w_s_i4u1u1u1u1_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i4u1u1u1u1_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i4u1u1u1u1_ (*FuncToCall)(void*,const void* method);
    struct s_i4u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.F64 op_Implicit(Int32)
static bool w_s_i8_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_i8_ (*FuncToCall)(int32_t p0, const void* method);
    struct s_i8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.F64 op_Implicit(Int64)
static bool w_s_i8_i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8_i8");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);

    typedef struct s_i8_ (*FuncToCall)(int64_t p0, const void* method);
    struct s_i8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.F64 op_Implicit(Single)
static bool w_s_i8_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef struct s_i8_ (*FuncToCall)(float p0, const void* method);
    struct s_i8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 Get(Int64, Int64, Int64)
static bool w_s_i8i8i8_Di8Di8Di8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_Di8Di8Di8");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int64_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal primitive with default
    int64_t p0 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int64_t p1 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int64_t p2 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 2);
                

    typedef struct s_i8i8i8_ (*FuncToCall)(int64_t p0, int64_t p1, int64_t p2, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 op_Multiply(GCore.FVector3, Int64)
static bool w_s_i8i8i8_s_i8i8i8_i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_s_i8i8i8_i8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);

    typedef struct s_i8i8i8_ (*FuncToCall)(struct s_i8i8i8_ p0, int64_t p1, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 op_Addition(GCore.FVector3, GCore.FVector3)
static bool w_s_i8i8i8_s_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_s_i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};

    typedef struct s_i8i8i8_ (*FuncToCall)(struct s_i8i8i8_ p0, struct s_i8i8i8_ p1, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 C_FVector()
static bool w_s_i8i8i8_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 Idx2Pos(Int32)
static bool w_s_i8i8i8_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 Idx2Pos(Int32, Int32, Int32)
static bool w_s_i8i8i8_ti4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_ti4Di4Di4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 Cr2Pos(Int32, Int32)
static bool w_s_i8i8i8_ti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_ti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 C_FindNearestPos(Int32, GCore.FVector3, Int64)
static bool w_s_i8i8i8_ti4s_i8i8i8_i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_ti4s_i8i8i8_i8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,int32_t p0, struct s_i8i8i8_ p1, int64_t p2, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 C_GetSurfacePos(Int32, GCore.FVector3, GCore.FVector3)
static bool w_s_i8i8i8_ti4s_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_ti4s_i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,int32_t p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 GetAgentPosition(Int64)
static bool w_s_i8i8i8_ti8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_ti8");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,int64_t p0, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 Cross(GCore.FVector3)
static bool w_s_i8i8i8_ts_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_ts_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,struct s_i8i8i8_ p0, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 RotateByRad(GCore.FVector3, Int64)
static bool w_s_i8i8i8_ts_i8i8i8_i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_ts_i8i8i8_i8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,struct s_i8i8i8_ p0, int64_t p1, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 GetNearest(System.String, GCore.FVector3, GCore.FVector3)
static bool w_s_i8i8i8_tss_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_tss_i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,void* p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 C_GetPosition(UInt32)
static bool w_s_i8i8i8_tu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_tu4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,uint32_t p0, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FVector3 C_Local2World(UInt32, GCore.FVector3)
static bool w_s_i8i8i8_tu4s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8_tu4s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};

    typedef struct s_i8i8i8_ (*FuncToCall)(void*,uint32_t p0, struct s_i8i8i8_ p1, const void* method);
    struct s_i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FQuaterion Get(Int64, Int64, Int64, Int64)
static bool w_s_i8i8i8i8_Di8Di8Di8Di8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8_Di8Di8Di8Di8");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal primitive with default
    int64_t p0 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int64_t p1 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int64_t p2 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int64_t p3 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 3);
                

    typedef struct s_i8i8i8i8_ (*FuncToCall)(int64_t p0, int64_t p1, int64_t p2, int64_t p3, const void* method);
    struct s_i8i8i8i8_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FQuaterion LookAt(GCore.FVector3)
static bool w_s_i8i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};

    typedef struct s_i8i8i8i8_ (*FuncToCall)(struct s_i8i8i8_ p0, const void* method);
    struct s_i8i8i8i8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FQuaterion op_Multiply(GCore.FQuaterion, GCore.FVector3)
static bool w_s_i8i8i8i8_s_i8i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8_s_i8i8i8i8_s_i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i8i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, info[0]);
    s_i8i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};

    typedef struct s_i8i8i8i8_ (*FuncToCall)(struct s_i8i8i8i8_ p0, struct s_i8i8i8_ p1, const void* method);
    struct s_i8i8i8i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FQuaterion op_Multiply(GCore.FQuaterion, GCore.FQuaterion)
static bool w_s_i8i8i8i8_s_i8i8i8i8_s_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8_s_i8i8i8i8_s_i8i8i8i8_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i8i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, info[0]);
    s_i8i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, info[1]);
    s_i8i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8i8_ {};

    typedef struct s_i8i8i8i8_ (*FuncToCall)(struct s_i8i8i8i8_ p0, struct s_i8i8i8i8_ p1, const void* method);
    struct s_i8i8i8i8_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FQuaterion C_FVector4()
static bool w_s_i8i8i8i8_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_i8i8i8i8_ (*FuncToCall)(void*,const void* method);
    struct s_i8i8i8i8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FQuaterion SetEuler(Int64, Int64, Int64)
static bool w_s_i8i8i8i8_ti8i8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8_ti8i8i8");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);

    typedef struct s_i8i8i8i8_ (*FuncToCall)(void*,int64_t p0, int64_t p1, int64_t p2, const void* method);
    struct s_i8i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FQuaterion Rotate(GCore.FVector3, Int64)
static bool w_s_i8i8i8i8_ts_i8i8i8_i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8_ts_i8i8i8_i8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);

    typedef struct s_i8i8i8i8_ (*FuncToCall)(void*,struct s_i8i8i8_ p0, int64_t p1, const void* method);
    struct s_i8i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.FQuaterion C_GetRotation(UInt32)
static bool w_s_i8i8i8i8_tu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8_tu4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);

    typedef struct s_i8i8i8i8_ (*FuncToCall)(void*,uint32_t p0, const void* method);
    struct s_i8i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// GCore.PhyHitInfo C_PhyRaycast(Int32, GCore.FVector3, GCore.FVector3, Int64)
static bool w_s_i8i8i8i8i8i8i8_ti4s_i8i8i8_s_i8i8i8_i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_i8i8i8i8i8i8i8_ti4s_i8i8i8_s_i8i8i8_i8");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);

    typedef struct s_i8i8i8i8i8i8i8_ (*FuncToCall)(void*,int32_t p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, int64_t p3, const void* method);
    struct s_i8i8i8i8i8i8i8_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Enumerator GetEnumerator()
static bool w_s_oi4i4O_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_oi4i4O_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_oi4i4O_ (*FuncToCall)(void*,const void* method);
    struct s_oi4i4O_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.TestTools.CoveredMethodStats GetStatsFor(System.Reflection.MethodBase)
static bool w_s_oi4i4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_oi4i4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef struct s_oi4i4_ (*FuncToCall)(void* p0, const void* method);
    struct s_oi4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Enumerator GetEnumerator()
static bool w_s_oi4i4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_oi4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_oi4i4i4_ (*FuncToCall)(void*,const void* method);
    struct s_oi4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Enumerator GetEnumerator()
static bool w_s_oi4i4i4oi4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_oi4i4i4oi4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_oi4i4i4oi4_ (*FuncToCall)(void*,const void* method);
    struct s_oi4i4i4oi4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Enumerator GetEnumerator()
static bool w_s_oi4i4s_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_oi4i4s_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_oi4i4s_ (*FuncToCall)(void*,const void* method);
    struct s_oi4i4s_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Enumerator GetEnumerator()
static bool w_s_oi4i4soi4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_oi4i4soi4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_oi4i4soi4_ (*FuncToCall)(void*,const void* method);
    struct s_oi4i4soi4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.LowLevel.PlayerLoopSystem GetDefaultPlayerLoop()
static bool w_s_ooopp_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_ooopp_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_ooopp_ (*FuncToCall)(const void* method);
    struct s_ooopp_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Enumerator GetEnumerator()
static bool w_s_osi4i4o_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_osi4i4o_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_osi4i4o_ (*FuncToCall)(void*,const void* method);
    struct s_osi4i4o_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// Enumerator GetEnumerator(System.String)
static bool w_s_osi4i4o_ts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_osi4i4o_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_osi4i4o_ (*FuncToCall)(void*,void* p0, const void* method);
    struct s_osi4i4o_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.CullingResults get_cullingResults()
static bool w_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ (*FuncToCall)(void*,const void* method);
    struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.CullingResults Cull(UnityEngine.Rendering.ScriptableCullingParameters ByRef)
static bool w_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_tPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_tPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_* p0 = nullptr; // valuetype ref
    s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ (*FuncToCall)(void*,struct s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_* p0, const void* method);
    struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.LocalKeywordSpace get_keywordSpace()
static bool w_s_p_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_p_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_p_ (*FuncToCall)(void*,const void* method);
    struct s_p_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.AsyncGPUReadbackRequest Request(UnityEngine.Texture, Int32, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest])
static bool w_s_pi4_oDi4Do(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pi4_oDi4Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal ref  with default
    void* p2 = OptionalParameter<void*>::GetRefType(context, info, method, 2, TIp2);
                

    typedef struct s_pi4_ (*FuncToCall)(void* p0, int32_t p1, void* p2, const void* method);
    struct s_pi4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.AsyncGPUReadbackRequest Request(UnityEngine.ComputeBuffer, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest])
static bool w_s_pi4_oDo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pi4_oDo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal ref  with default
    void* p1 = OptionalParameter<void*>::GetRefType(context, info, method, 1, TIp1);
                

    typedef struct s_pi4_ (*FuncToCall)(void* p0, void* p1, const void* method);
    struct s_pi4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.AsyncGPUReadbackRequest Request(UnityEngine.ComputeBuffer, Int32, Int32, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest])
static bool w_s_pi4_oi4i4Do(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pi4_oi4i4Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal ref  with default
    void* p3 = OptionalParameter<void*>::GetRefType(context, info, method, 3, TIp3);
                

    typedef struct s_pi4_ (*FuncToCall)(void* p0, int32_t p1, int32_t p2, void* p3, const void* method);
    struct s_pi4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.AsyncGPUReadbackRequest Request(UnityEngine.Texture, Int32, Int32, Int32, Int32, Int32, Int32, Int32, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest])
static bool w_s_pi4_oi4i4i4i4i4i4i4Do(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pi4_oi4i4i4i4i4i4i4Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp8 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 8) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (length > 8 && !info[8]->IsNullOrUndefined() && (!info[8]->IsObject() || (info[8]->IsFunction() ? !IsDelegate(TIp8) : !IsAssignableFrom(TIp8, GetTypeId(info[8].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal ref  with default
    void* p8 = OptionalParameter<void*>::GetRefType(context, info, method, 8, TIp8);
                

    typedef struct s_pi4_ (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, void* p8, const void* method);
    struct s_pi4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.AsyncGPUReadbackRequest Request(UnityEngine.Texture, Int32, Int32, Int32, Int32, Int32, Int32, Int32, UnityEngine.TextureFormat, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest])
static bool w_s_pi4_oi4i4i4i4i4i4i4i4Do(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pi4_oi4i4i4i4i4i4i4i4Do");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp9 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 9) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (length > 9 && !info[9]->IsNullOrUndefined() && (!info[9]->IsObject() || (info[9]->IsFunction() ? !IsDelegate(TIp9) : !IsAssignableFrom(TIp9, GetTypeId(info[9].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);
    // JSValToCSVal ref  with default
    void* p9 = OptionalParameter<void*>::GetRefType(context, info, method, 9, TIp9);
                

    typedef struct s_pi4_ (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, void* p9, const void* method);
    struct s_pi4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.GraphicsFence CreateAsyncGraphicsFence()
static bool w_s_pi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pi4i4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_pi4i4_ (*FuncToCall)(const void* method);
    struct s_pi4i4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.GraphicsFence CreateAsyncGraphicsFence(UnityEngine.Rendering.SynchronisationStage)
static bool w_s_pi4i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pi4i4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_pi4i4_ (*FuncToCall)(int32_t p0, const void* method);
    struct s_pi4i4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.GraphicsFence CreateGraphicsFence(UnityEngine.Rendering.GraphicsFenceType, UnityEngine.Rendering.SynchronisationStageFlags)
static bool w_s_pi4i4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pi4i4_i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef struct s_pi4i4_ (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    struct s_pi4i4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.GraphicsFence CreateAsyncGraphicsFence()
static bool w_s_pi4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pi4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_pi4i4_ (*FuncToCall)(void*,const void* method);
    struct s_pi4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.GraphicsFence CreateAsyncGraphicsFence(UnityEngine.Rendering.SynchronisationStage)
static bool w_s_pi4i4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pi4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_pi4i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_pi4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.GraphicsFence CreateGraphicsFence(UnityEngine.Rendering.GraphicsFenceType, UnityEngine.Rendering.SynchronisationStageFlags)
static bool w_s_pi4i4_ti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pi4i4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef struct s_pi4i4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    struct s_pi4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// MeshData get_Item(Int32)
static bool w_s_ppi4i4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_ppi4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_ppi4i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_ppi4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.ScopedRenderPass BeginScopedRenderPass(Int32, Int32, Int32, Unity.Collections.NativeArray`1[UnityEngine.Rendering.AttachmentDescriptor], Int32)
static bool w_s_ppi4i4_ti4i4i4s_Pvi4i4i4pi4i4oi4_Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_ppi4i4_ti4i4i4s_Pvi4i4i4pi4i4oi4_Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp3 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[3]);
    s_Pvi4i4i4pi4i4oi4_ p3 = pp3 ? *pp3 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef struct s_ppi4i4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, struct s_Pvi4i4i4pi4i4oi4_ p3, int32_t p4, const void* method);
    struct s_ppi4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.ScopedSubPass BeginScopedSubPass(Unity.Collections.NativeArray`1[System.Int32], Boolean)
static bool w_s_ppi4i4_ts_Pvi4i4i4pi4i4oi4_Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_ppi4i4_ts_Pvi4i4i4pi4i4oi4_Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef struct s_ppi4i4_ (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, bool p1, const void* method);
    struct s_ppi4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.ScopedSubPass BeginScopedSubPass(Unity.Collections.NativeArray`1[System.Int32], Boolean, Boolean)
static bool w_s_ppi4i4_ts_Pvi4i4i4pi4i4oi4_bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_ppi4i4_ts_Pvi4i4i4pi4i4oi4_bb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef struct s_ppi4i4_ (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, bool p1, bool p2, const void* method);
    struct s_ppi4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.ScopedSubPass BeginScopedSubPass(Unity.Collections.NativeArray`1[System.Int32], Unity.Collections.NativeArray`1[System.Int32], Boolean)
static bool w_s_ppi4i4_ts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_ppi4i4_ts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_Db");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp1 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[1]);
    s_Pvi4i4i4pi4i4oi4_ p1 = pp1 ? *pp1 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                

    typedef struct s_ppi4i4_ (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, struct s_Pvi4i4i4pi4i4oi4_ p1, bool p2, const void* method);
    struct s_ppi4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.ScopedSubPass BeginScopedSubPass(Unity.Collections.NativeArray`1[System.Int32], Unity.Collections.NativeArray`1[System.Int32], Boolean, Boolean)
static bool w_s_ppi4i4_ts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_ppi4i4_ts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_bb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp1 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[1]);
    s_Pvi4i4i4pi4i4oi4_ p1 = pp1 ? *pp1 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef struct s_ppi4i4_ (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, struct s_Pvi4i4i4pi4i4oi4_ p1, bool p2, bool p3, const void* method);
    struct s_ppi4i4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.LocalKeyword FindKeyword(System.String)
static bool w_s_psu4_ts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_psu4_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_psu4_ (*FuncToCall)(void*,void* p0, const void* method);
    struct s_psu4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Playables.Playable get_Null()
static bool w_s_pu4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pu4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_pu4_ (*FuncToCall)(const void* method);
    struct s_pu4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Playables.PlayableGraph Create(System.String)
static bool w_s_pu4_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pu4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_pu4_ (*FuncToCall)(void* p0, const void* method);
    struct s_pu4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Playables.PlayableOutput op_Implicit(UnityEngine.Playables.ScriptPlayableOutput)
static bool w_s_pu4_s_pu4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pu4_s_pu4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_pu4_* pp0 = DataTransfer::GetPointer<s_pu4_>(context, info[0]);
    s_pu4_ p0 = pp0 ? *pp0 : s_pu4_ {};

    typedef struct s_pu4_ (*FuncToCall)(struct s_pu4_ p0, const void* method);
    struct s_pu4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Playables.Playable Create(UnityEngine.Playables.PlayableGraph, Int32)
static bool w_s_pu4_s_pu4_Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pu4_s_pu4_Di4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_pu4_* pp0 = DataTransfer::GetPointer<s_pu4_>(context, info[0]);
    s_pu4_ p0 = pp0 ? *pp0 : s_pu4_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                

    typedef struct s_pu4_ (*FuncToCall)(struct s_pu4_ p0, int32_t p1, const void* method);
    struct s_pu4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Experimental.Playables.CameraPlayable Create(UnityEngine.Playables.PlayableGraph, UnityEngine.Camera)
static bool w_s_pu4_s_pu4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pu4_s_pu4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_pu4_* pp0 = DataTransfer::GetPointer<s_pu4_>(context, info[0]);
    s_pu4_ p0 = pp0 ? *pp0 : s_pu4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef struct s_pu4_ (*FuncToCall)(struct s_pu4_ p0, void* p1, const void* method);
    struct s_pu4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Experimental.Playables.MaterialEffectPlayable Create(UnityEngine.Playables.PlayableGraph, UnityEngine.Material, Int32)
static bool w_s_pu4_s_pu4_oDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pu4_s_pu4_oDi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_pu4_* pp0 = DataTransfer::GetPointer<s_pu4_>(context, info[0]);
    s_pu4_ p0 = pp0 ? *pp0 : s_pu4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef struct s_pu4_ (*FuncToCall)(struct s_pu4_ p0, void* p1, int32_t p2, const void* method);
    struct s_pu4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Playables.ScriptPlayableOutput Create(UnityEngine.Playables.PlayableGraph, System.String)
static bool w_s_pu4_s_pu4_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pu4_s_pu4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal struct
    s_pu4_* pp0 = DataTransfer::GetPointer<s_pu4_>(context, info[0]);
    s_pu4_ p0 = pp0 ? *pp0 : s_pu4_ {};
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef struct s_pu4_ (*FuncToCall)(struct s_pu4_ p0, void* p1, const void* method);
    struct s_pu4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Experimental.Playables.TexturePlayableOutput Create(UnityEngine.Playables.PlayableGraph, System.String, UnityEngine.RenderTexture)
static bool w_s_pu4_s_pu4_so(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pu4_s_pu4_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_pu4_* pp0 = DataTransfer::GetPointer<s_pu4_>(context, info[0]);
    s_pu4_ p0 = pp0 ? *pp0 : s_pu4_ {};
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef struct s_pu4_ (*FuncToCall)(struct s_pu4_ p0, void* p1, void* p2, const void* method);
    struct s_pu4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Playables.PlayableOutput get_output()
static bool w_s_pu4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pu4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_pu4_ (*FuncToCall)(void*,const void* method);
    struct s_pu4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Playables.Playable GetRootPlayable(Int32)
static bool w_s_pu4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pu4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_pu4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_pu4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.RendererUtils.RendererList CreateRendererList(UnityEngine.Rendering.RendererUtils.RendererListDesc)
static bool w_s_pu4u4_ts_i4i4i4i4bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4obi4i4pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4oi4o_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_pu4u4_ts_i4i4i4i4bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4obi4i4pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4oi4o_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4i4bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4obi4i4pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4oi4o_* pp0 = DataTransfer::GetPointer<s_i4i4i4i4bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4obi4i4pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4oi4o_>(context, info[0]);
    s_i4i4i4i4bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4obi4i4pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4oi4o_ p0 = pp0 ? *pp0 : s_i4i4i4i4bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4obi4i4pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4oi4o_ {};

    typedef struct s_pu4u4_ (*FuncToCall)(void*,struct s_i4i4i4i4bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4obi4i4pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4oi4o_ p0, const void* method);
    struct s_pu4u4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 get_zero()
static bool w_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_r4r4_ (*FuncToCall)(const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 GetMinSize(UnityEngine.Sprite)
static bool w_s_r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef struct s_r4r4_ (*FuncToCall)(void* p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 op_Multiply(Single, UnityEngine.Vector2)
static bool w_s_r4r4_r4s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_r4s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(float p0, struct s_r4r4_ p1, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 op_Implicit(UnityEngine.Vector2Int)
static bool w_s_r4r4_s_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4_>(context, info[0]);
    s_i4i4_ p0 = pp0 ? *pp0 : s_i4i4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(struct s_i4i4_ p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 Perpendicular(UnityEngine.Vector2)
static bool w_s_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 ClampMagnitude(UnityEngine.Vector2, Single)
static bool w_s_r4r4_s_r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, float p1, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 Scale(UnityEngine.Vector2, UnityEngine.Vector2)
static bool w_s_r4r4_s_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single)
static bool w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, struct s_r4r4_* p2, float p3, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single, Single)
static bool w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, struct s_r4r4_* p2, float p3, float p4, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 SmoothDamp(UnityEngine.Vector2, UnityEngine.Vector2, UnityEngine.Vector2 ByRef, Single, Single, Single)
static bool w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, struct s_r4r4_* p2, float p3, float p4, float p5, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 Lerp(UnityEngine.Vector2, UnityEngine.Vector2, Single)
static bool w_s_r4r4_s_r4r4_s_r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4_s_r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4_ p0, struct s_r4r4_ p1, float p2, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 op_Implicit(UnityEngine.Vector3)
static bool w_s_r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 op_Implicit(UnityEngine.Vector4)
static bool w_s_r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 NormalizedToPoint(UnityEngine.Rect, UnityEngine.Vector2)
static bool w_s_r4r4_s_r4r4r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_s_r4r4r4r4_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4_ p1, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 get_xy()
static bool w_s_r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 GetTouchPosition(Int32)
static bool w_s_r4r4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 GetPoupPosition(FairyGUI.GObject, FairyGUI.GObject, FairyGUI.PopupDirection)
static bool w_s_r4r4_tooi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_tooi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef struct s_r4r4_ (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 GetPoint(Single)
static bool w_s_r4r4_tr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_tr4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef struct s_r4r4_ (*FuncToCall)(void*,float p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 GetAttributeVector(System.String)
static bool w_s_r4r4_ts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_r4r4_ (*FuncToCall)(void*,void* p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 GlobalToLocal(UnityEngine.Vector2)
static bool w_s_r4r4_ts_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_ts_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(void*,struct s_r4r4_ p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 GetUVAtPosition(UnityEngine.Vector2, Boolean)
static bool w_s_r4r4_ts_r4r4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_ts_r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef struct s_r4r4_ (*FuncToCall)(void*,struct s_r4r4_ p0, bool p1, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 TransformPoint(UnityEngine.Vector2, FairyGUI.DisplayObject)
static bool w_s_r4r4_ts_r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_ts_r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef struct s_r4r4_ (*FuncToCall)(void*,struct s_r4r4_ p0, void* p1, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 WorldToLocal(UnityEngine.Vector3)
static bool w_s_r4r4_ts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_ts_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector2 WorldToLocal(UnityEngine.Vector3, UnityEngine.Camera)
static bool w_s_r4r4_ts_r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4_ts_r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef struct s_r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, void* p1, const void* method);
    struct s_r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 get_shadowCascade4Split()
static bool w_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_r4r4r4_ (*FuncToCall)(const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 op_Multiply(Single, UnityEngine.Vector3)
static bool w_s_r4r4r4_r4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_r4s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(float p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 op_Implicit(UnityEngine.Vector3Int)
static bool w_s_r4r4r4_s_i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_i4i4i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4_>(context, info[0]);
    s_i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_i4i4i4_ p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 op_Implicit(UnityEngine.Vector2)
static bool w_s_r4r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4_ p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 RelativeMouseAt(UnityEngine.Vector3)
static bool w_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 ClampMagnitude(UnityEngine.Vector3, Single)
static bool w_s_r4r4r4_s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, float p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 Scale(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 Snap(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.SnapAxis)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Du1(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Du1");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (length > 2 && !converter::Converter<uint8_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal primitive with default
    uint8_t p2 = OptionalParameter<uint8_t>::GetPrimitive(context, info, method, 2);
                

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, uint8_t p2, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_* p2, float p3, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_* p2, float p3, float p4, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 SmoothDamp(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3 ByRef, Single, Single, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_* p2, float p3, float p4, float p5, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 Slerp(UnityEngine.Vector3, UnityEngine.Vector3, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 RotateTowards(UnityEngine.Vector3, UnityEngine.Vector3, Single, Single)
static bool w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, float p3, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 op_Implicit(UnityEngine.Vector4)
static bool w_s_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 op_Multiply(UnityEngine.Quaternion, UnityEngine.Vector3)
static bool w_s_r4r4r4_s_r4r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_s_r4r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 get_position()
static bool w_s_r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 GetPosition(Int32)
static bool w_s_r4r4r4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 GetPointAt(Single)
static bool w_s_r4r4r4_tr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_tr4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,float p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 TransformDirection(Single, Single, Single)
static bool w_s_r4r4r4_tr4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_tr4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,float p0, float p1, float p2, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 LocalToWorld(UnityEngine.Vector3)
static bool w_s_r4r4r4_ts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_ts_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 ScreenToWorld(UnityEngine.Vector3, Single)
static bool w_s_r4r4r4_ts_r4r4r4_Dr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_ts_r4r4r4_Dr4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (length > 1 && !converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(context, info, method, 1);
                

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, float p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 WorldToScreenPoint(UnityEngine.Vector3, MonoOrStereoscopicEye)
static bool w_s_r4r4r4_ts_r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_ts_r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, int32_t p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector3 WorldToLocal(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_s_r4r4r4_ts_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4_ts_r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 get_defaultTextureHDRDecodeValues()
static bool w_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_r4r4r4r4_ (*FuncToCall)(const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rect Intersection(UnityEngine.Rect ByRef, UnityEngine.Rect ByRef)
static bool w_s_r4r4r4r4_Ps_r4r4r4r4_Ps_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_Ps_r4r4r4r4_Ps_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_r4r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_* p0, struct s_r4r4r4r4_* p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color ColorFromRGB(Int32)
static bool w_s_r4r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(int32_t p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 GetInnerUV(UnityEngine.Sprite)
static bool w_s_r4r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void* p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color CorrelatedColorTemperatureToRGB(Single)
static bool w_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color ColorHSV(Single, Single)
static bool w_s_r4r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, float p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color HSVToRGB(Single, Single, Single)
static bool w_s_r4r4r4r4_r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color HSVToRGB(Single, Single, Single, Boolean)
static bool w_s_r4r4r4r4_r4r4r4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4r4r4b");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, bool p3, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rect MinMaxRect(Single, Single, Single, Single)
static bool w_s_r4r4r4r4_r4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, float p3, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color ColorHSV(Single, Single, Single, Single, Single, Single)
static bool w_s_r4r4r4r4_r4r4r4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, float p3, float p4, float p5, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color ColorHSV(Single, Single, Single, Single, Single, Single, Single, Single)
static bool w_s_r4r4r4r4_r4r4r4r4r4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4r4r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
        if (!converter::Converter<float>::accept(context, info[6])) return false;
        if (!converter::Converter<float>::accept(context, info[7])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(context, info[6]);
    // JSValToCSVal P any
    float p7 = converter::Converter<float>::toCpp(context, info[7]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, float p3, float p4, float p5, float p6, float p7, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Quaternion AngleAxis(Single, UnityEngine.Vector3)
static bool w_s_r4r4r4r4_r4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color op_Multiply(Single, UnityEngine.Color)
static bool w_s_r4r4r4r4_r4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_r4s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(float p0, struct s_r4r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color ConvertFromHtmlColor(System.String)
static bool w_s_r4r4r4r4_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void* p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color op_Implicit(UnityEngine.Color32)
static bool w_s_r4r4r4r4_s_i4u1u1u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_i4u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4u1u1u1u1_* pp0 = DataTransfer::GetPointer<s_i4u1u1u1u1_>(context, info[0]);
    s_i4u1u1u1u1_ p0 = pp0 ? *pp0 : s_i4u1u1u1u1_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_i4u1u1u1u1_ p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 op_Implicit(UnityEngine.Vector2)
static bool w_s_r4r4r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4_ p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Quaternion LookRotation(UnityEngine.Vector3)
static bool w_s_r4r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Quaternion FromToRotation(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_s_r4r4r4r4_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 op_Implicit(UnityEngine.Color)
static bool w_s_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color op_Multiply(UnityEngine.Color, Single)
static bool w_s_r4r4r4r4_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, float p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Plane Translate(UnityEngine.Plane, UnityEngine.Vector3)
static bool w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color op_Addition(UnityEngine.Color, UnityEngine.Color)
static bool w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color Lerp(UnityEngine.Color, UnityEngine.Color, Single)
static bool w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, float p2, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 op_Multiply(UnityEngine.Matrix4x4, UnityEngine.Vector4)
static bool w_s_r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color get_color()
static bool w_s_r4r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 GetPropertyDefaultVectorValue(Int32)
static bool w_s_r4r4r4r4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color GetPixel(Int32, Int32)
static bool w_s_r4r4r4r4_ti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_ti4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color GetPixel(Int32, Int32, Int32)
static bool w_s_r4r4r4r4_ti4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_ti4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color GetPixel(UnityEngine.CubemapFace, Int32, Int32, Int32)
static bool w_s_r4r4r4r4_ti4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_ti4i4i4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rect GetBounds(FairyGUI.DisplayObject)
static bool w_s_r4r4r4r4_to(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,void* p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color Evaluate(Single)
static bool w_s_r4r4r4r4_tr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_tr4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,float p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color GetPixelBilinear(Single, Single)
static bool w_s_r4r4r4r4_tr4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_tr4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,float p0, float p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color GetPixelBilinear(Single, Single, Int32)
static bool w_s_r4r4r4r4_tr4r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_tr4r4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,float p0, float p1, int32_t p2, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color GetPixelBilinear(Single, Single, Single)
static bool w_s_r4r4r4r4_tr4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_tr4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,float p0, float p1, float p2, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color GetPixelBilinear(Single, Single, Single, Int32)
static bool w_s_r4r4r4r4_tr4r4r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_tr4r4r4i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,float p0, float p1, float p2, int32_t p3, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Vector4 GetVector(System.String)
static bool w_s_r4r4r4r4_ts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,void* p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rect GetDrawRect(UnityEngine.Rect)
static bool w_s_r4r4r4r4_ts_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_ts_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rect TransformRect(UnityEngine.Rect, FairyGUI.DisplayObject)
static bool w_s_r4r4r4r4_ts_r4r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_ts_r4r4r4r4_o");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, void* p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color GetColor(System.String, UnityEngine.Color)
static bool w_s_r4r4r4r4_tss_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_tss_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4_ (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Color ColorFromRGBA(UInt32)
static bool w_s_r4r4r4r4_u4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4_u4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4_ (*FuncToCall)(uint32_t p0, const void* method);
    struct s_r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Keyframe get_Item(Int32)
static bool w_s_r4r4r4r4i4i4r4r4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4i4i4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4i4i4r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_r4r4r4r4i4i4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Bounds CalculateBounds(UnityEngine.Vector3[], UnityEngine.Matrix4x4)
static bool w_s_r4r4r4r4r4r4_os_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4_os_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4_ (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Bounds get_bounds()
static bool w_s_r4r4r4r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Ray ViewportPointToRay(UnityEngine.Vector3)
static bool w_s_r4r4r4r4r4r4_ts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4_ts_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Ray ViewportPointToRay(UnityEngine.Vector3, MonoOrStereoscopicEye)
static bool w_s_r4r4r4r4r4r4_ts_r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4_ts_r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef struct s_r4r4r4r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4_ p0, int32_t p1, const void* method);
    struct s_r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.SubMeshDescriptor GetSubMesh(Int32)
static bool w_s_r4r4r4r4r4r4i4i4i4i4i4i4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4i4i4i4i4i4i4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4r4r4i4i4i4i4i4i4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_r4r4r4r4r4r4i4i4i4i4i4i4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Pose get_identity()
static bool w_s_r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_r4r4r4r4r4r4r4_ (*FuncToCall)(const void* method);
    struct s_r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Pose GetTransformedBy(UnityEngine.Transform)
static bool w_s_r4r4r4r4r4r4r4_to(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4_to");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef struct s_r4r4r4r4r4r4r4_ (*FuncToCall)(void*,void* p0, const void* method);
    struct s_r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Pose GetTransformedBy(UnityEngine.Pose)
static bool w_s_r4r4r4r4r4r4r4_ts_r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4_ts_r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 get_matrix()
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 GetGlobalMatrix(Int32)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(int32_t p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 Perspective(Single, Single, Single, Single)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, float p3, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 Ortho(Single, Single, Single, Single, Single, Single)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4r4r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p0, float p1, float p2, float p3, float p4, float p5, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 GetGlobalMatrix(System.String)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void* p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 Scale(UnityEngine.Vector3)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 LookAt(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 TRS(UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_s_r4r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_s_r4r4r4r4_s_r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4r4_ p1, struct s_r4r4r4_ p2, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 Rotate(UnityEngine.Quaternion)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 Frustum(UnityEngine.FrustumPlanes)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 Inverse(UnityEngine.Matrix4x4)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 GetGPUProjectionMatrix(UnityEngine.Matrix4x4, Boolean)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_b");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, bool p1, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 op_Multiply(UnityEngine.Matrix4x4, UnityEngine.Matrix4x4)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 get_cullingMatrix()
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 GetStereoNonJitteredProjectionMatrix(StereoscopicEye)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,int32_t p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 GetMatrix(System.String)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,void* p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Matrix4x4 CalculateObliqueMatrix(UnityEngine.Vector4)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.SortingSettings get_sortingSettings()
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.SphericalHarmonicsL2 get_ambientProbe()
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.SphericalHarmonicsL2 op_Multiply(Single, UnityEngine.Rendering.SphericalHarmonicsL2)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(float p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.SphericalHarmonicsL2 op_Multiply(UnityEngine.Rendering.SphericalHarmonicsL2, Single)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, float p1, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.SphericalHarmonicsL2 op_Addition(UnityEngine.Rendering.SphericalHarmonicsL2, UnityEngine.Rendering.SphericalHarmonicsL2)
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.CameraProperties get_cameraProperties()
static bool w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_ (*FuncToCall)(void*,const void* method);
    struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Playables.PlayableBinding Create(System.String, UnityEngine.Object)
static bool w_s_sooo_so(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_sooo_so");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef struct s_sooo_ (*FuncToCall)(void* p0, void* p1, const void* method);
    struct s_sooo_ ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Playables.PlayableBinding Create(System.String, UnityEngine.Object, System.Type)
static bool w_s_sooo_soo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_sooo_soo");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];
    auto TIp2 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef struct s_sooo_ (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    struct s_sooo_ ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.GlobalKeyword Create(System.String)
static bool w_s_su4_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_su4_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_su4_ (*FuncToCall)(void* p0, const void* method);
    struct s_su4_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.DepthState get_defaultValue()
static bool w_s_u1i1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u1i1_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_u1i1_ (*FuncToCall)(const void* method);
    struct s_u1i1_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.DepthState get_depthState()
static bool w_s_u1i1_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u1i1_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_u1i1_ (*FuncToCall)(void*,const void* method);
    struct s_u1i1_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.RenderTargetBlendState get_defaultValue()
static bool w_s_u1u1u1u1u1u1u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_u1u1u1u1u1u1u1u1_ (*FuncToCall)(const void* method);
    struct s_u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.RenderTargetBlendState get_blendState0()
static bool w_s_u1u1u1u1u1u1u1u1_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u1u1u1u1u1u1u1u1_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_u1u1u1u1u1u1u1u1_ (*FuncToCall)(void*,const void* method);
    struct s_u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.StencilState get_defaultValue()
static bool w_s_u1u1u1u1u1u1u1u1u1u1u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u1u1u1u1u1u1u1u1u1u1u1u1_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_u1u1u1u1u1u1u1u1u1u1u1u1_ (*FuncToCall)(const void* method);
    struct s_u1u1u1u1u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.StencilState get_stencilState()
static bool w_s_u1u1u1u1u1u1u1u1u1u1u1u1_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u1u1u1u1u1u1u1u1u1u1u1u1_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_u1u1u1u1u1u1u1u1u1u1u1u1_ (*FuncToCall)(void*,const void* method);
    struct s_u1u1u1u1u1u1u1u1u1u1u1u1_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.BlendState get_defaultValue()
static bool w_s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_ (*FuncToCall)(const void* method);
    struct s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Rendering.BlendState get_blendState()
static bool w_s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_ (*FuncToCall)(void*,const void* method);
    struct s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.DisplayInfo get_mainWindowDisplayInfo()
static bool w_s_u8i4i4u4u4i4i4i4i4s_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8i4i4u4u4i4i4i4i4s_");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef struct s_u8i4i4u4u4i4i4i4i4s_ (*FuncToCall)(const void* method);
    struct s_u8i4i4u4u4i4i4i4i4s_ ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Hash128 Compute(Int32)
static bool w_s_u8u8_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8u8_i4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef struct s_u8u8_ (*FuncToCall)(int32_t p0, const void* method);
    struct s_u8u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Hash128 Compute(Single)
static bool w_s_u8u8_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8u8_r4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef struct s_u8u8_ (*FuncToCall)(float p0, const void* method);
    struct s_u8u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Hash128 Parse(System.String)
static bool w_s_u8u8_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8u8_s");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef struct s_u8u8_ (*FuncToCall)(void* p0, const void* method);
    struct s_u8u8_ ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// UnityEngine.Hash128 get_hash()
static bool w_s_u8u8_t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_s_u8u8_t");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef struct s_u8u8_ (*FuncToCall)(void*,const void* method);
    struct s_u8u8_ ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CopyValueType(isolate, context, TIret, &ret, sizeof(ret)));
    return true;
}

// System.String IDToName(Int32)
static bool w_si4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_si4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String UTF8ToString(IntPtr, Int32)
static bool w_spi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_spi4");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void* p0, int32_t p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ConvertNumber(System.String)
static bool w_ss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String EncodeString(System.String, Boolean)
static bool w_ssDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ssDb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void* (*FuncToCall)(void* p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String op_Explicit(UnityEngine.Rendering.ShaderTagId)
static bool w_ss_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ss_i4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4_* pp0 = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p0 = pp0 ? *pp0 : s_i4_ {};

    typedef void* (*FuncToCall)(struct s_i4_ p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ToHtmlStringRGB(UnityEngine.Color)
static bool w_ss_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_ss_r4r4r4r4_");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef void* (*FuncToCall)(struct s_r4r4r4r4_ p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetItemURL(System.String, System.String)
static bool w_sss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String get_shader()
static bool w_st(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_st");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef void* (*FuncToCall)(void*,const void* method);
    void* ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetTagText(Boolean)
static bool w_stb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_stb");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,bool p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetPageName(Int32)
static bool w_sti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sti4");
    
    auto TIret = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void* (*FuncToCall)(void*,int32_t p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String Find(System.Predicate`1[System.String])
static bool w_sto(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sto");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetPageIdByName(System.String)
static bool w_sts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_sts");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void* (*FuncToCall)(void*,void* p0, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ReadFile(System.String, System.String ByRef)
static bool w_stsPs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_stsPs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal Ps
    void* up1 = nullptr; // string ref
    void** p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        v8::String::Utf8Value tp1(isolate, op1->Get(context, 0).ToLocalChecked());
        up1 = CStringToCSharpString(*tp1);
    }
        

    typedef void* (*FuncToCall)(void*,void* p0, void** p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, CSAnyToJsValue(isolate, context, *p1));
    }
    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetTag(System.String, Boolean)
static bool w_stsb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_stsb");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void* (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetTag(System.String, Boolean, System.String)
static bool w_stsbs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_stsbs");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void* (*FuncToCall)(void*,void* p0, bool p1, void* p2, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String ToString(System.String, System.IFormatProvider)
static bool w_stso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_stso");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// System.String GetString(System.String, System.String)
static bool w_stss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_stss");
    
    auto TIret = wrapData->TypeInfos[0];
    auto TIp0 = wrapData->TypeInfos[1];
    auto TIp1 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void* (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    void* ret = ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
    return true;
}

// UnityEngine.Experimental.GlobalIllumination.LightMode Extract(UnityEngine.LightmapBakeType)
static bool w_u1i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u1i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef uint8_t (*FuncToCall)(int32_t p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Byte ReadByte()
static bool w_u1t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u1t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef uint8_t (*FuncToCall)(void*,const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// Byte get_Item(Int32)
static bool w_u1ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u1ti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef uint8_t (*FuncToCall)(void*,int32_t p0, const void* method);
    uint8_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt16 FloatToHalf(Single)
static bool w_u2r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u2r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef uint16_t (*FuncToCall)(float p0, const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt16 ReadUshort()
static bool w_u2t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u2t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef uint16_t (*FuncToCall)(void*,const void* method);
    uint16_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 get_usedHeapSize()
static bool w_u4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef uint32_t (*FuncToCall)(const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 GetColorComponentCount(UnityEngine.Experimental.Rendering.GraphicsFormat)
static bool w_u4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef uint32_t (*FuncToCall)(int32_t p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 ComputeMipmapSize(Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat)
static bool w_u4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef uint32_t (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 ComputeMipmapSize(Int32, Int32, Int32, UnityEngine.Experimental.Rendering.GraphicsFormat)
static bool w_u4i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4i4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef uint32_t (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 getSurfacePos(IntPtr, GCore.FVector3 ByRef, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_u4pPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4pPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef uint32_t (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 entt_create_unit(IntPtr, Int32)
static bool w_u4pi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4pi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef uint32_t (*FuncToCall)(void* p0, int32_t p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 entt_nav_raycast(IntPtr, Int32, GCore.FVector3 ByRef, GCore.FVector3 ByRef, Int64 ByRef)
static bool w_u4pi4Ps_i8i8i8_Ps_i8i8i8_Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4pi4Ps_i8i8i8_Ps_i8i8i8_Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal P primitive
    int64_t up4 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[4]);
    int64_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }

    typedef uint32_t (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, int64_t* p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
            
    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p4));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 entt_get_surfacepos(IntPtr, Int32, GCore.FVector3 ByRef, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_u4pi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4pi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p4 = nullptr; // valuetype ref
    s_i8i8i8_ up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
        auto tp4 = op4->Get(context, 0).ToLocalChecked();
        p4 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp4);
    }
    if (!p4) {
        p4 = &up4;
    }
        

    typedef uint32_t (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, struct s_i8i8i8_* p4, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
            
    if (!op4.IsEmpty() && p4 == &up4)
    {
        auto _unused = op4->Set(context, 0, CopyValueType(isolate, context, TIp4, p4, sizeof(*p4)));
    }
    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 AddLock()
static bool w_u4t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef uint32_t (*FuncToCall)(void*,const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 GetIndexStart(Int32)
static bool w_u4ti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4ti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef uint32_t (*FuncToCall)(void*,int32_t p0, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)(self, p0,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt32 GetLatestTimings(UInt32, UnityEngine.FrameTiming[])
static bool w_u4u4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u4u4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef uint32_t (*FuncToCall)(uint32_t p0, void* p1, const void* method);
    uint32_t ret = ((FuncToCall)methodPointer)( p0, p1,  method);

    
    info.GetReturnValue().Set(ret);
    return true;
}

// UInt64 GetGpuTimerFrequency()
static bool w_u8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef uint64_t (*FuncToCall)(const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(  method);

    
    info.GetReturnValue().Set(v8::BigInt::NewFromUnsigned(isolate, ret));
    return true;
}

// UInt64 entt_num(IntPtr)
static bool w_u8p(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u8p");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);

    typedef uint64_t (*FuncToCall)(void* p0, const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)( p0,  method);

    
    info.GetReturnValue().Set(v8::BigInt::NewFromUnsigned(isolate, ret));
    return true;
}

// UInt64 get_overrideSceneCullingMask()
static bool w_u8t(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_u8t");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef uint64_t (*FuncToCall)(void*,const void* method);
    uint64_t ret = ((FuncToCall)methodPointer)(self,  method);

    
    info.GetReturnValue().Set(v8::BigInt::NewFromUnsigned(isolate, ret));
    return true;
}

// Void CheckMain()
static bool w_v(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_v");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    

    typedef void (*FuncToCall)(const void* method);
    ((FuncToCall)methodPointer)(  method);

    
    return true;
}

// Void Kill(System.Object)
static bool w_vO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void (*FuncToCall)(void* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void Kill(System.Object, Boolean)
static bool w_vOb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vOb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Kill(System.Object, FairyGUI.TweenPropType, Boolean)
static bool w_vOi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vOi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Log(System.Object, UnityEngine.Object)
static bool w_vOo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vOo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void RenderPrimitives(UnityEngine.RenderParams ByRef, UnityEngine.MeshTopology, Int32, Int32)
static bool w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_i4i4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_i4i4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_* p0 = nullptr; // valuetype ref
    s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(struct s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_* p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void RenderPrimitivesIndirect(UnityEngine.RenderParams ByRef, UnityEngine.MeshTopology, UnityEngine.GraphicsBuffer, Int32, Int32)
static bool w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_i4oDi4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_i4oDi4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_* p0 = nullptr; // valuetype ref
    s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef void (*FuncToCall)(struct s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_* p0, int32_t p1, void* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void RenderPrimitivesIndexed(UnityEngine.RenderParams ByRef, UnityEngine.MeshTopology, UnityEngine.GraphicsBuffer, Int32, Int32, Int32)
static bool w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_i4oi4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_i4oi4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!info[0]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (length > 5 && !converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_* p0 = nullptr; // valuetype ref
    s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 5);
                

    typedef void (*FuncToCall)(struct s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_* p0, int32_t p1, void* p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void RenderPrimitivesIndexedIndirect(UnityEngine.RenderParams ByRef, UnityEngine.MeshTopology, UnityEngine.GraphicsBuffer, UnityEngine.GraphicsBuffer, Int32, Int32)
static bool w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_i4ooDi4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_i4ooDi4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!info[0]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (length > 5 && !converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_* p0 = nullptr; // valuetype ref
    s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 5);
                

    typedef void (*FuncToCall)(struct s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_* p0, int32_t p1, void* p2, void* p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void RenderMeshPrimitives(UnityEngine.RenderParams ByRef, UnityEngine.Mesh, Int32, Int32)
static bool w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_oi4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_oi4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_* p0 = nullptr; // valuetype ref
    s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(struct s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_* p0, void* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void RenderMesh(UnityEngine.RenderParams ByRef, UnityEngine.Mesh, Int32, UnityEngine.Matrix4x4, System.Nullable`1[UnityEngine.Matrix4x4])
static bool w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_oi4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ds_br4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_oi4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ds_br4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (length > 4 && (!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_* p0 = nullptr; // valuetype ref
    s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal valuetype  with default
    s_br4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p4 = OptionalParameter<s_br4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>::GetValueType(context, info, method, 4);
                

    typedef void (*FuncToCall)(struct s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_* p0, void* p1, int32_t p2, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3, struct s_br4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void RenderMeshIndirect(UnityEngine.RenderParams ByRef, UnityEngine.Mesh, UnityEngine.GraphicsBuffer, Int32, Int32)
static bool w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_ooDi4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_ooDi4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_* p0 = nullptr; // valuetype ref
    s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef void (*FuncToCall)(struct s_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_* p0, void* p1, void* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void fv_opmulf(GCore.FVector3 ByRef, Int64 ByRef, GCore.FVector3 ByRef)
static bool w_vPs_i8i8i8_Pi8Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8_Pi8Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P primitive
    int64_t up1 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[1]);
    int64_t* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8_* p0, int64_t* p1, struct s_i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p1));
    }
    
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void fv_normalize(GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_vPs_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8_* p0, struct s_i8i8i8_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void fv_rotate(GCore.FVector3 ByRef, GCore.FVector3 ByRef, Int64 ByRef, GCore.FVector3 ByRef)
static bool w_vPs_i8i8i8_Ps_i8i8i8_Pi8Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8_Ps_i8i8i8_Pi8Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[2]);
    int64_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8_* p0, struct s_i8i8i8_* p1, int64_t* p2, struct s_i8i8i8_* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    return true;
}

// Void fv_opadd(GCore.FVector3 ByRef, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_vPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8_* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void fq_seteuler(GCore.FQuaterion ByRef, Int64 ByRef, Int64 ByRef, Int64 ByRef, GCore.FQuaterion ByRef)
static bool w_vPs_i8i8i8i8_Pi8Pi8Pi8Ps_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8i8_Pi8Pi8Pi8Ps_i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P primitive
    int64_t up1 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[1]);
    int64_t* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[2]);
    int64_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p4 = nullptr; // valuetype ref
    s_i8i8i8i8_ up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
        auto tp4 = op4->Get(context, 0).ToLocalChecked();
        p4 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp4);
    }
    if (!p4) {
        p4 = &up4;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8i8_* p0, int64_t* p1, int64_t* p2, int64_t* p3, struct s_i8i8i8i8_* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p1));
    }
    
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    if (!op4.IsEmpty() && p4 == &up4)
    {
        auto _unused = op4->Set(context, 0, CopyValueType(isolate, context, TIp4, p4, sizeof(*p4)));
    }
    
    return true;
}

// Void fq_geteuler(GCore.FQuaterion ByRef, GCore.FVector3 ByRef)
static bool w_vPs_i8i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8i8_* p0, struct s_i8i8i8_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void fq_rotate(GCore.FQuaterion ByRef, GCore.FVector3 ByRef, Int64 ByRef, GCore.FQuaterion ByRef)
static bool w_vPs_i8i8i8i8_Ps_i8i8i8_Pi8Ps_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8i8_Ps_i8i8i8_Pi8Ps_i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[2]);
    int64_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8i8_* p0, struct s_i8i8i8_* p1, int64_t* p2, struct s_i8i8i8i8_* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    return true;
}

// Void fq_quatrot(GCore.FQuaterion ByRef, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_vPs_i8i8i8i8_Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8i8_Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8i8_* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void fq_mulv(GCore.FQuaterion ByRef, GCore.FVector3 ByRef, GCore.FQuaterion ByRef)
static bool w_vPs_i8i8i8i8_Ps_i8i8i8_Ps_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8i8_Ps_i8i8i8_Ps_i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8i8_* p0, struct s_i8i8i8_* p1, struct s_i8i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void fq_inverse(GCore.FQuaterion ByRef, GCore.FQuaterion ByRef)
static bool w_vPs_i8i8i8i8_Ps_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8i8_Ps_i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8i8_* p0, struct s_i8i8i8i8_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void fq_mul(GCore.FQuaterion ByRef, GCore.FQuaterion ByRef, GCore.FQuaterion ByRef)
static bool w_vPs_i8i8i8i8_Ps_i8i8i8i8_Ps_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_i8i8i8i8_Ps_i8i8i8i8_Ps_i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p0 = nullptr; // valuetype ref
    s_i8i8i8i8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct s_i8i8i8i8_* p0, struct s_i8i8i8i8_* p1, struct s_i8i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void OrthoNormalize(UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef)
static bool w_vPs_r4r4r4_Ps_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_r4r4r4_Ps_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct s_r4r4r4_* p0, struct s_r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void OrthoNormalize(UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef, UnityEngine.Vector3 ByRef)
static bool w_vPs_r4r4r4_Ps_r4r4r4_Ps_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_r4r4r4_Ps_r4r4r4_Ps_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct s_r4r4r4_* p0, struct s_r4r4r4_* p1, struct s_r4r4r4_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void QuantisedVectorHash(UnityEngine.Vector3 ByRef, UnityEngine.Hash128 ByRef)
static bool w_vPs_r4r4r4_Ps_u8u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_r4r4r4_Ps_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_u8u8_* p1 = nullptr; // valuetype ref
    s_u8u8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_u8u8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct s_r4r4r4_* p0, struct s_u8u8_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void QuantisedMatrixHash(UnityEngine.Matrix4x4 ByRef, UnityEngine.Hash128 ByRef)
static bool w_vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_u8u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_u8u8_* p1 = nullptr; // valuetype ref
    s_u8u8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_u8u8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0, struct s_u8u8_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void SkewMatrix(UnityEngine.Matrix4x4 ByRef, Single, Single)
static bool w_vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void CalculateProjectionMatrixFromPhysicalProperties(UnityEngine.Matrix4x4 ByRef, Single, UnityEngine.Vector2, UnityEngine.Vector2, Single, Single, GateFitParameters)
static bool w_vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4s_r4r4_s_r4r4_r4r4Ds_i4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4s_r4r4_s_r4r4_r4r4Ds_i4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 6) return false;
        if (!info[0]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
        if (length > 6 && (!info[6]->IsObject() || !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4_>(context, info[2]);
    s_r4r4_ p2 = pp2 ? *pp2 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4_>(context, info[3]);
    s_r4r4_ p3 = pp3 ? *pp3 : s_r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);
    // JSValToCSVal valuetype  with default
    s_i4r4_ p6 = OptionalParameter<s_i4r4_>::GetValueType(context, info, method, 6);
                

    typedef void (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0, float p1, struct s_r4r4_ p2, struct s_r4r4_ p3, float p4, float p5, struct s_i4r4_ p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void EnableKeyword(UnityEngine.Rendering.GlobalKeyword ByRef)
static bool w_vPs_su4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_su4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_su4_* p0 = nullptr; // valuetype ref
    s_su4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_su4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(struct s_su4_* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void SetKeyword(UnityEngine.Rendering.GlobalKeyword ByRef, Boolean)
static bool w_vPs_su4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_su4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal Pstruct
    s_su4_* p0 = nullptr; // valuetype ref
    s_su4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_su4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(struct s_su4_* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void AppendHash(UnityEngine.Hash128 ByRef, UnityEngine.Hash128 ByRef)
static bool w_vPs_u8u8_Ps_u8u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vPs_u8u8_Ps_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal Pstruct
    s_u8u8_* p0 = nullptr; // valuetype ref
    s_u8u8_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_u8u8_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_u8u8_* p1 = nullptr; // valuetype ref
    s_u8u8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_u8u8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(struct s_u8u8_* p0, struct s_u8u8_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void set_touchScreen(Boolean)
static bool w_vb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(bool p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void Assert(Boolean, System.Object)
static bool w_vbO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbO");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(bool p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Assert(Boolean, System.Object, UnityEngine.Object)
static bool w_vbOo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbOo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(bool p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Clear(Boolean, Boolean, UnityEngine.Color)
static bool w_vbbs_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbbs_r4r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(bool p0, bool p1, struct s_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Clear(Boolean, Boolean, UnityEngine.Color, Single)
static bool w_vbbs_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbbs_r4r4r4r4_r4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(bool p0, bool p1, struct s_r4r4r4r4_ p2, float p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void Assert(Boolean, UnityEngine.Object)
static bool w_vbo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbo");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(bool p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void AssertFormat(Boolean, UnityEngine.Object, System.String, System.Object[])
static bool w_vbosVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbosVO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal ref params
    void* p3 = RestArguments<void*>::PackRef(context, info, TIp3, 3);
                

    typedef void (*FuncToCall)(bool p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void Assert(Boolean, System.String)
static bool w_vbs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbs");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(bool p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void AssertFormat(Boolean, System.String, System.Object[])
static bool w_vbsVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbsVO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal ref params
    void* p2 = RestArguments<void*>::PackRef(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(bool p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Assert(Boolean, System.String, UnityEngine.Object)
static bool w_vbso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vbso");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(bool p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void AreEqual(Char, Char)
static bool w_vcc(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vcc");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[0])) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(context, info[0]);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(Il2CppChar p0, Il2CppChar p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void AreEqual(Char, Char, System.String)
static bool w_vccs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vccs");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[0])) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(context, info[0]);
    // JSValToCSVal P any
    Il2CppChar p1 = converter::Converter<Il2CppChar>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(Il2CppChar p0, Il2CppChar p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void AreEqual(SByte, SByte)
static bool w_vi1i1(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi1i1");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int8_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int8_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(int8_t p0, int8_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void AreEqual(SByte, SByte, System.String)
static bool w_vi1i1s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi1i1s");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int8_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int8_t>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    int8_t p0 = converter::Converter<int8_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int8_t p1 = converter::Converter<int8_t>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(int8_t p0, int8_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void AreEqual(Int16, Int16)
static bool w_vi2i2(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi2i2");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int16_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int16_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(int16_t p0, int16_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void AreEqual(Int16, Int16, System.String)
static bool w_vi2i2s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi2i2s");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int16_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int16_t>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(int16_t p0, int16_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void CycleSkipSystems(Int32)
static bool w_vi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(int32_t p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void SetQualityLevel(Int32, Boolean)
static bool w_vi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(int32_t p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetStackTraceLogType(UnityEngine.LogType, UnityEngine.StackTraceLogType)
static bool w_vi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void DrawProceduralNow(UnityEngine.MeshTopology, Int32, Int32)
static bool w_vi4i4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Allocate(Int32, Int32, UnityEngine.Jobs.TransformAccessArray ByRef)
static bool w_vi4i4Ps_ppi4i4o_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4Ps_ppi4i4o_");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_ppi4i4o_* p2 = nullptr; // valuetype ref
    s_ppi4i4o_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_ppi4i4o_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, struct s_ppi4i4o_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void SetResolution(Int32, Int32, Boolean)
static bool w_vi4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetResolution(Int32, Int32, Boolean, Int32)
static bool w_vi4i4bi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4bi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, bool p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void Override(FairyGUI.BlendMode, UnityEngine.Rendering.BlendMode, UnityEngine.Rendering.BlendMode)
static bool w_vi4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetResolution(Int32, Int32, UnityEngine.FullScreenMode, Int32)
static bool w_vi4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void LogFormat(UnityEngine.LogType, UnityEngine.LogOption, UnityEngine.Object, System.String, System.Object[])
static bool w_vi4i4osVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4osVO");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsString() && !info[3]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal s
    v8::String::Utf8Value tp3(isolate, info[3]);
    void* p3 = CStringToCSharpString(*tp3);
    // JSValToCSVal ref params
    void* p4 = RestArguments<void*>::PackRef(context, info, TIp4, 4);
                

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, void* p2, void* p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void AreEqual(Int32, Int32, System.String)
static bool w_vi4i4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4i4s");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(int32_t p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetDefaultValue(ConfigKey, ConfigValue)
static bool w_vi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void DrawProceduralIndirectNow(UnityEngine.MeshTopology, UnityEngine.ComputeBuffer, Int32)
static bool w_vi4oDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4oDi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(int32_t p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetRandomWriteTarget(Int32, UnityEngine.ComputeBuffer, Boolean)
static bool w_vi4ob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4ob");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(int32_t p0, void* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetGlobalTexture(Int32, UnityEngine.RenderTexture, UnityEngine.Rendering.RenderTextureSubElement)
static bool w_vi4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4oi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(int32_t p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void DrawProceduralNow(UnityEngine.MeshTopology, UnityEngine.GraphicsBuffer, Int32, Int32)
static bool w_vi4oi4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4oi4Di4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(int32_t p0, void* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetGlobalConstantBuffer(Int32, UnityEngine.ComputeBuffer, Int32, Int32)
static bool w_vi4oi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4oi4i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(int32_t p0, void* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawProceduralIndirectNow(UnityEngine.MeshTopology, UnityEngine.GraphicsBuffer, UnityEngine.ComputeBuffer, Int32)
static bool w_vi4ooDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4ooDi4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(int32_t p0, void* p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetGlobalFloat(Int32, Single)
static bool w_vi4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(int32_t p0, float p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void MultiTexCoord2(Int32, Single, Single)
static bool w_vi4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(int32_t p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void MultiTexCoord3(Int32, Single, Single, Single)
static bool w_vi4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4r4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(int32_t p0, float p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void WriteCustomEvent(Int32, System.String)
static bool w_vi4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4s");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void MultiTexCoord(Int32, UnityEngine.Vector3)
static bool w_vi4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4s_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(int32_t p0, struct s_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetGlobalVector(Int32, UnityEngine.Vector4)
static bool w_vi4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4s_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(int32_t p0, struct s_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetGlobalMatrix(Int32, UnityEngine.Matrix4x4)
static bool w_vi4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(int32_t p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void LaunchFile(UnityEngine.WSA.Folder, System.String, Boolean)
static bool w_vi4sb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi4sb");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(int32_t p0, void* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void set_maximumAvailableDiskSpace(Int64)
static bool w_vi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(int64_t p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void AreEqual(Int64, Int64)
static bool w_vi8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi8i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(int64_t p0, int64_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void AreEqual(Int64, Int64, System.String)
static bool w_vi8i8s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vi8i8s");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(int64_t p0, int64_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void add_CustomDestroyMethod(System.Action`1[UnityEngine.Texture])
static bool w_vo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vo");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void (*FuncToCall)(void* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void RegisterFont(FairyGUI.BaseFont, System.String)
static bool w_voDs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voDs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal string  with default
    void* p1 = OptionalParameter<void*>::GetString(context, info, method, 1);
                

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void TakeTempSnapshot(System.Action`2[System.String,System.Boolean], UnityEngine.Profiling.Memory.Experimental.CaptureFlags)
static bool w_voDu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voDu4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !converter::Converter<uint32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal primitive with default
    uint32_t p1 = OptionalParameter<uint32_t>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void* p0, uint32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Extract(UnityEngine.Light, UnityEngine.Experimental.GlobalIllumination.DirectionalLight ByRef)
static bool w_voPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Pstruct
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p1 = nullptr; // valuetype ref
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void* p0, struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void Extract(UnityEngine.Light, UnityEngine.Experimental.GlobalIllumination.SpotLight ByRef)
static bool w_voPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Pstruct
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_* p1 = nullptr; // valuetype ref
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void* p0, struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void Extract(UnityEngine.Light, UnityEngine.Experimental.GlobalIllumination.RectangleLight ByRef)
static bool w_voPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Pstruct
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_* p1 = nullptr; // valuetype ref
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void* p0, struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void Extract(UnityEngine.Light, UnityEngine.Experimental.GlobalIllumination.PointLight ByRef)
static bool w_voPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Pstruct
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_* p1 = nullptr; // valuetype ref
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void* p0, struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void Extract(UnityEngine.Light, UnityEngine.Experimental.GlobalIllumination.Cookie ByRef)
static bool w_voPs_i4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voPs_i4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Pstruct
    s_i4r4r4r4_* p1 = nullptr; // valuetype ref
    s_i4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void* p0, struct s_i4r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void RotateUV(UnityEngine.Vector2[], UnityEngine.Rect ByRef)
static bool w_voPs_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voPs_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Pstruct
    s_r4r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void CacheRaycastHit(UnityEngine.Camera, UnityEngine.RaycastHit ByRef)
static bool w_voPs_r4r4r4r4r4r4u4r4r4r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voPs_r4r4r4r4r4r4u4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4u4r4r4r4i4_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void ComputeHash128(Byte[], UnityEngine.Hash128 ByRef)
static bool w_voPs_u8u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voPs_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Pstruct
    s_u8u8_* p1 = nullptr; // valuetype ref
    s_u8u8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_u8u8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void* p0, struct s_u8u8_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void DestroyImmediate(UnityEngine.Object, Boolean)
static bool w_vob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vob");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void StartBroadcasting(BroadcastStatusCallback, Boolean, Boolean)
static bool w_vobb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vobb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Apply(UnityEngine.Material, FairyGUI.BlendMode)
static bool w_voi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void EncodeString(System.Text.StringBuilder, Int32, Boolean)
static bool w_voi4Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4Db");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void* p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.RenderTexture, Int32, UnityEngine.CubemapFace)
static bool w_voi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.RenderTexture, Int32, UnityEngine.CubemapFace, Int32)
static bool w_voi4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void CopyTexture(UnityEngine.Texture, Int32, Int32, Int32, Int32, Int32, Int32, UnityEngine.Texture, Int32, Int32, Int32, Int32)
static bool w_voi4i4i4i4i4i4oi4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4i4i4i4i4i4oi4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp7 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 12) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[9])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[10])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[11])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(context, info[9]);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(context, info[10]);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(context, info[11]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, void* p7, int32_t p8, int32_t p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void CopyTexture(UnityEngine.Texture, Int32, Int32, UnityEngine.Texture, Int32, Int32)
static bool w_voi4i4oi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4i4oi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, void* p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void CopyTexture(UnityEngine.Texture, Int32, UnityEngine.Texture, Int32)
static bool w_voi4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, UnityEngine.Matrix4x4[])
static bool w_voi4oo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, UnityEngine.Matrix4x4[], Int32)
static bool w_voi4ooi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4ooi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, UnityEngine.Matrix4x4[], Int32, UnityEngine.MaterialPropertyBlock)
static bool w_voi4ooi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4ooi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, int32_t p4, void* p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, UnityEngine.Matrix4x4[], Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode)
static bool w_voi4ooi4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4ooi4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, int32_t p4, void* p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, UnityEngine.Matrix4x4[], Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean)
static bool w_voi4ooi4oi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4ooi4oi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, int32_t p4, void* p5, int32_t p6, bool p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, UnityEngine.Matrix4x4[], Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, Int32)
static bool w_voi4ooi4oi4bi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4ooi4oi4bi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, int32_t p4, void* p5, int32_t p6, bool p7, int32_t p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, UnityEngine.Matrix4x4[], Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, Int32, UnityEngine.Camera)
static bool w_voi4ooi4oi4bi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4ooi4oi4bi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp9 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 10) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (!info[9]->IsNullOrUndefined() && (!info[9]->IsObject() || (info[9]->IsFunction() ? !IsDelegate(TIp9) : !IsAssignableFrom(TIp9, GetTypeId(info[9].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);
    // JSValToCSVal o/O
    void* p9 = JsValueToCSRef(context, info[9], TIp9);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, int32_t p4, void* p5, int32_t p6, bool p7, int32_t p8, void* p9, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, UnityEngine.Matrix4x4[], Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, Int32, UnityEngine.Camera, UnityEngine.Rendering.LightProbeUsage)
static bool w_voi4ooi4oi4bi4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4ooi4oi4bi4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp9 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 11) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (!info[9]->IsNullOrUndefined() && (!info[9]->IsObject() || (info[9]->IsFunction() ? !IsDelegate(TIp9) : !IsAssignableFrom(TIp9, GetTypeId(info[9].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[10])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);
    // JSValToCSVal o/O
    void* p9 = JsValueToCSRef(context, info[9], TIp9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(context, info[10]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, int32_t p4, void* p5, int32_t p6, bool p7, int32_t p8, void* p9, int32_t p10, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, UnityEngine.Matrix4x4[], Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, Int32, UnityEngine.Camera, UnityEngine.Rendering.LightProbeUsage, UnityEngine.LightProbeProxyVolume)
static bool w_voi4ooi4oi4bi4oi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4ooi4oi4bi4oi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp9 = wrapData->TypeInfos[4];
    auto TIp11 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 12) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (!info[9]->IsNullOrUndefined() && (!info[9]->IsObject() || (info[9]->IsFunction() ? !IsDelegate(TIp9) : !IsAssignableFrom(TIp9, GetTypeId(info[9].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[10])) return false;
        if (!info[11]->IsNullOrUndefined() && (!info[11]->IsObject() || (info[11]->IsFunction() ? !IsDelegate(TIp11) : !IsAssignableFrom(TIp11, GetTypeId(info[11].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);
    // JSValToCSVal o/O
    void* p9 = JsValueToCSRef(context, info[9], TIp9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(context, info[10]);
    // JSValToCSVal o/O
    void* p11 = JsValueToCSRef(context, info[11], TIp11);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, int32_t p4, void* p5, int32_t p6, bool p7, int32_t p8, void* p9, int32_t p10, void* p11, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, System.Collections.Generic.List`1[UnityEngine.Matrix4x4], UnityEngine.MaterialPropertyBlock)
static bool w_voi4ooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4ooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, System.Collections.Generic.List`1[UnityEngine.Matrix4x4], UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode)
static bool w_voi4oooi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4oooi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, void* p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, System.Collections.Generic.List`1[UnityEngine.Matrix4x4], UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean)
static bool w_voi4oooi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4oooi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<bool>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(context, info[6]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, void* p4, int32_t p5, bool p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, System.Collections.Generic.List`1[UnityEngine.Matrix4x4], UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, Int32)
static bool w_voi4oooi4bi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4oooi4bi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<bool>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, void* p4, int32_t p5, bool p6, int32_t p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, System.Collections.Generic.List`1[UnityEngine.Matrix4x4], UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, Int32, UnityEngine.Camera)
static bool w_voi4oooi4bi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4oooi4bi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp8 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<bool>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!info[8]->IsNullOrUndefined() && (!info[8]->IsObject() || (info[8]->IsFunction() ? !IsDelegate(TIp8) : !IsAssignableFrom(TIp8, GetTypeId(info[8].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal o/O
    void* p8 = JsValueToCSRef(context, info[8], TIp8);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, void* p4, int32_t p5, bool p6, int32_t p7, void* p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, System.Collections.Generic.List`1[UnityEngine.Matrix4x4], UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, Int32, UnityEngine.Camera, UnityEngine.Rendering.LightProbeUsage)
static bool w_voi4oooi4bi4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4oooi4bi4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp8 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 10) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<bool>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!info[8]->IsNullOrUndefined() && (!info[8]->IsObject() || (info[8]->IsFunction() ? !IsDelegate(TIp8) : !IsAssignableFrom(TIp8, GetTypeId(info[8].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[9])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal o/O
    void* p8 = JsValueToCSRef(context, info[8], TIp8);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(context, info[9]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, void* p4, int32_t p5, bool p6, int32_t p7, void* p8, int32_t p9, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, System.Collections.Generic.List`1[UnityEngine.Matrix4x4], UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, Int32, UnityEngine.Camera, UnityEngine.Rendering.LightProbeUsage, UnityEngine.LightProbeProxyVolume)
static bool w_voi4oooi4bi4oi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4oooi4bi4oi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp8 = wrapData->TypeInfos[4];
    auto TIp10 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 11) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<bool>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!info[8]->IsNullOrUndefined() && (!info[8]->IsObject() || (info[8]->IsFunction() ? !IsDelegate(TIp8) : !IsAssignableFrom(TIp8, GetTypeId(info[8].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[9])) return false;
        if (!info[10]->IsNullOrUndefined() && (!info[10]->IsObject() || (info[10]->IsFunction() ? !IsDelegate(TIp10) : !IsAssignableFrom(TIp10, GetTypeId(info[10].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal o/O
    void* p8 = JsValueToCSRef(context, info[8], TIp8);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(context, info[9]);
    // JSValToCSVal o/O
    void* p10 = JsValueToCSRef(context, info[10], TIp10);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, void* p4, int32_t p5, bool p6, int32_t p7, void* p8, int32_t p9, void* p10, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);

    
    return true;
}

// Void DrawMeshInstancedProcedural(UnityEngine.Mesh, Int32, UnityEngine.Material, UnityEngine.Bounds, Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, Int32, UnityEngine.Camera, UnityEngine.Rendering.LightProbeUsage, UnityEngine.LightProbeProxyVolume)
static bool w_voi4os_r4r4r4r4r4r4_i4DoDi4DbDi4DoDi4Do(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4os_r4r4r4r4r4r4_i4DoDi4DbDi4DoDi4Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp9 = wrapData->TypeInfos[4];
    auto TIp11 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (length > 5 && !info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (length > 6 && !converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (length > 7 && !converter::Converter<bool>::accept(context, info[7])) return false;
        if (length > 8 && !converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (length > 9 && !info[9]->IsNullOrUndefined() && (!info[9]->IsObject() || (info[9]->IsFunction() ? !IsDelegate(TIp9) : !IsAssignableFrom(TIp9, GetTypeId(info[9].As<v8::Object>()))))) return false;
        if (length > 10 && !converter::Converter<int32_t>::accept(context, info[10])) return false;
        if (length > 11 && !info[11]->IsNullOrUndefined() && (!info[11]->IsObject() || (info[11]->IsFunction() ? !IsDelegate(TIp11) : !IsAssignableFrom(TIp11, GetTypeId(info[11].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal ref  with default
    void* p5 = OptionalParameter<void*>::GetRefType(context, info, method, 5, TIp5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 6);
                
    // JSValToCSVal primitive with default
    bool p7 = OptionalParameter<bool>::GetPrimitive(context, info, method, 7);
                
    // JSValToCSVal primitive with default
    int32_t p8 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 8);
                
    // JSValToCSVal ref  with default
    void* p9 = OptionalParameter<void*>::GetRefType(context, info, method, 9, TIp9);
                
    // JSValToCSVal primitive with default
    int32_t p10 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 10);
                
    // JSValToCSVal ref  with default
    void* p11 = OptionalParameter<void*>::GetRefType(context, info, method, 11, TIp11);
                

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, struct s_r4r4r4r4r4r4_ p3, int32_t p4, void* p5, int32_t p6, bool p7, int32_t p8, void* p9, int32_t p10, void* p11, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void DrawMeshInstancedIndirect(UnityEngine.Mesh, Int32, UnityEngine.Material, UnityEngine.Bounds, UnityEngine.ComputeBuffer, Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, Int32, UnityEngine.Camera, UnityEngine.Rendering.LightProbeUsage)
static bool w_voi4os_r4r4r4r4r4r4_oDi4DoDi4DbDi4DoDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4os_r4r4r4r4r4r4_oDi4DoDi4DbDi4DoDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp10 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (length > 5 && !converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (length > 6 && !info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (length > 7 && !converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (length > 8 && !converter::Converter<bool>::accept(context, info[8])) return false;
        if (length > 9 && !converter::Converter<int32_t>::accept(context, info[9])) return false;
        if (length > 10 && !info[10]->IsNullOrUndefined() && (!info[10]->IsObject() || (info[10]->IsFunction() ? !IsDelegate(TIp10) : !IsAssignableFrom(TIp10, GetTypeId(info[10].As<v8::Object>()))))) return false;
        if (length > 11 && !converter::Converter<int32_t>::accept(context, info[11])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 5);
                
    // JSValToCSVal ref  with default
    void* p6 = OptionalParameter<void*>::GetRefType(context, info, method, 6, TIp6);
                
    // JSValToCSVal primitive with default
    int32_t p7 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 7);
                
    // JSValToCSVal primitive with default
    bool p8 = OptionalParameter<bool>::GetPrimitive(context, info, method, 8);
                
    // JSValToCSVal primitive with default
    int32_t p9 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 9);
                
    // JSValToCSVal ref  with default
    void* p10 = OptionalParameter<void*>::GetRefType(context, info, method, 10, TIp10);
                
    // JSValToCSVal primitive with default
    int32_t p11 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 11);
                

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, struct s_r4r4r4r4r4r4_ p3, void* p4, int32_t p5, void* p6, int32_t p7, bool p8, int32_t p9, void* p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void DrawMeshInstancedIndirect(UnityEngine.Mesh, Int32, UnityEngine.Material, UnityEngine.Bounds, UnityEngine.ComputeBuffer, Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, Int32, UnityEngine.Camera, UnityEngine.Rendering.LightProbeUsage, UnityEngine.LightProbeProxyVolume)
static bool w_voi4os_r4r4r4r4r4r4_oi4oi4bi4oi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4os_r4r4r4r4r4r4_oi4oi4bi4oi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp10 = wrapData->TypeInfos[5];
    auto TIp12 = wrapData->TypeInfos[6];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 13) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[9])) return false;
        if (!info[10]->IsNullOrUndefined() && (!info[10]->IsObject() || (info[10]->IsFunction() ? !IsDelegate(TIp10) : !IsAssignableFrom(TIp10, GetTypeId(info[10].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[11])) return false;
        if (!info[12]->IsNullOrUndefined() && (!info[12]->IsObject() || (info[12]->IsFunction() ? !IsDelegate(TIp12) : !IsAssignableFrom(TIp12, GetTypeId(info[12].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(context, info[9]);
    // JSValToCSVal o/O
    void* p10 = JsValueToCSRef(context, info[10], TIp10);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(context, info[11]);
    // JSValToCSVal o/O
    void* p12 = JsValueToCSRef(context, info[12], TIp12);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, struct s_r4r4r4r4r4r4_ p3, void* p4, int32_t p5, void* p6, int32_t p7, bool p8, int32_t p9, void* p10, int32_t p11, void* p12, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, Int32, UnityEngine.Vector3)
static bool w_voi4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void* p0, int32_t p1, struct s_r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, Int32, UnityEngine.Vector3, UnityEngine.Quaternion)
static bool w_voi4s_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4s_r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void* p0, int32_t p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, Int32, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3)
static bool w_voi4s_r4r4r4_s_r4r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voi4s_r4r4r4_s_r4r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if ((!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp4 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[4]);
    s_r4r4r4_ p4 = pp4 ? *pp4 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void* p0, int32_t p1, struct s_r4r4r4_ p2, struct s_r4r4r4r4_ p3, struct s_r4r4r4_ p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void CreateObject(FairyGUI.PackageItem, CreateObjectCallback)
static bool w_voo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Blit(UnityEngine.Texture, UnityEngine.Material, Int32)
static bool w_vooi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vooi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Blit(UnityEngine.Texture, UnityEngine.RenderTexture, Int32, Int32)
static bool w_vooi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vooi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void* p0, void* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void Blit(UnityEngine.Texture, UnityEngine.RenderTexture, UnityEngine.Material)
static bool w_vooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void BlitMultiTap(UnityEngine.Texture, UnityEngine.RenderTexture, UnityEngine.Material, UnityEngine.Vector2[])
static bool w_voooVs_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voooVs_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal valuetype params
    void* p3 = RestArguments<s_r4r4_>::PackValueType(context, info, TIp3, 3);
                

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void Blit(UnityEngine.Texture, UnityEngine.RenderTexture, UnityEngine.Material, Int32)
static bool w_voooi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voooi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void BlitMultiTap(UnityEngine.Texture, UnityEngine.RenderTexture, UnityEngine.Material, Int32, UnityEngine.Vector2[])
static bool w_voooi4Vs_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voooi4Vs_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal valuetype params
    void* p4 = RestArguments<s_r4r4_>::PackValueType(context, info, TIp4, 4);
                

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, int32_t p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Blit(UnityEngine.Texture, UnityEngine.RenderTexture, UnityEngine.Material, Int32, Int32)
static bool w_voooi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voooi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Capture(FairyGUI.DisplayObject, UnityEngine.RenderTexture, Single, UnityEngine.Vector2)
static bool w_voor4s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voor4s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4_>(context, info[3]);
    s_r4r4_ p3 = pp3 ? *pp3 : s_r4r4_ {};

    typedef void (*FuncToCall)(void* p0, void* p1, float p2, struct s_r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void AreEqual(UnityEngine.Object, UnityEngine.Object, System.String)
static bool w_voos(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voos");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void WarmupShaderFromCollection(UnityEngine.ShaderVariantCollection, UnityEngine.Shader, UnityEngine.Experimental.Rendering.ShaderWarmupSetup)
static bool w_voos_o_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voos_o_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal struct
    s_o_* pp2 = DataTransfer::GetPointer<s_o_>(context, info[2]);
    s_o_ p2 = pp2 ? *pp2 : s_o_ {};

    typedef void (*FuncToCall)(void* p0, void* p1, struct s_o_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void Blit(UnityEngine.Texture, UnityEngine.RenderTexture, UnityEngine.Vector2, UnityEngine.Vector2)
static bool w_voos_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voos_r4r4_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal struct
    s_r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4_>(context, info[2]);
    s_r4r4_ p2 = pp2 ? *pp2 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4_>(context, info[3]);
    s_r4r4_ p3 = pp3 ? *pp3 : s_r4r4_ {};

    typedef void (*FuncToCall)(void* p0, void* p1, struct s_r4r4_ p2, struct s_r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void Blit(UnityEngine.Texture, UnityEngine.RenderTexture, UnityEngine.Vector2, UnityEngine.Vector2, Int32, Int32)
static bool w_voos_r4r4_s_r4r4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_voos_r4r4_s_r4r4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal struct
    s_r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4_>(context, info[2]);
    s_r4r4_ p2 = pp2 ? *pp2 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4_>(context, info[3]);
    s_r4r4_ p3 = pp3 ? *pp3 : s_r4r4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void* p0, void* p1, struct s_r4r4_ p2, struct s_r4r4_ p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void Destroy(UnityEngine.Object, Single)
static bool w_vor4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vor4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, float p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Simplify(System.Collections.Generic.List`1[UnityEngine.Vector3], Single, System.Collections.Generic.List`1[System.Int32])
static bool w_vor4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vor4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void* p0, float p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void IsNull(UnityEngine.Object, System.String)
static bool w_vos(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void LogFormat(UnityEngine.Object, System.String, System.Object[])
static bool w_vosVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vosVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal ref params
    void* p2 = RestArguments<void*>::PackRef(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void MoveGameObjectToScene(UnityEngine.GameObject, UnityEngine.SceneManagement.Scene)
static bool w_vos_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_i4_* pp1 = DataTransfer::GetPointer<s_i4_>(context, info[1]);
    s_i4_ p1 = pp1 ? *pp1 : s_i4_ {};

    typedef void (*FuncToCall)(void* p0, struct s_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.RenderBuffer[], UnityEngine.RenderBuffer)
static bool w_vos_i4p_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_i4p_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_i4p_* pp1 = DataTransfer::GetPointer<s_i4p_>(context, info[1]);
    s_i4p_ p1 = pp1 ? *pp1 : s_i4p_ {};

    typedef void (*FuncToCall)(void* p0, struct s_i4p_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void WarmupShader(UnityEngine.Shader, UnityEngine.Experimental.Rendering.ShaderWarmupSetup)
static bool w_vos_o_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_o_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_o_* pp1 = DataTransfer::GetPointer<s_o_>(context, info[1]);
    s_o_ p1 = pp1 ? *pp1 : s_o_ {};

    typedef void (*FuncToCall)(void* p0, struct s_o_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetCursor(UnityEngine.Texture2D, UnityEngine.Vector2, UnityEngine.CursorMode)
static bool w_vos_r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Vector3)
static bool w_vos_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Vector3, UnityEngine.Quaternion)
static bool w_vos_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void DrawMeshNow(UnityEngine.Mesh, UnityEngine.Vector3, UnityEngine.Quaternion, Int32)
static bool w_vos_r4r4r4_s_r4r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4_s_r4r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Material, Int32)
static bool w_vos_r4r4r4_s_r4r4r4r4_oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4_s_r4r4r4r4_oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, void* p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Material, Int32, UnityEngine.Camera)
static bool w_vos_r4r4r4_s_r4r4r4r4_oi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4_s_r4r4r4r4_oi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, void* p3, int32_t p4, void* p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Material, Int32, UnityEngine.Camera, Int32)
static bool w_vos_r4r4r4_s_r4r4r4r4_oi4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4_s_r4r4r4r4_oi4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, void* p3, int32_t p4, void* p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock)
static bool w_vos_r4r4r4_s_r4r4r4r4_oi4oi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4_s_r4r4r4r4_oi4oi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, void* p3, int32_t p4, void* p5, int32_t p6, void* p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock, Boolean)
static bool w_vos_r4r4r4_s_r4r4r4r4_oi4oi4ob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4_s_r4r4r4r4_oi4oi4ob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, void* p3, int32_t p4, void* p5, int32_t p6, void* p7, bool p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock, Boolean, Boolean)
static bool w_vos_r4r4r4_s_r4r4r4r4_oi4oi4obb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4_s_r4r4r4r4_oi4oi4obb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 10) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
        if (!converter::Converter<bool>::accept(context, info[9])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(context, info[9]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, void* p3, int32_t p4, void* p5, int32_t p6, void* p7, bool p8, bool p9, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock, Boolean, Boolean, Boolean)
static bool w_vos_r4r4r4_s_r4r4r4r4_oi4oi4obbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4_s_r4r4r4r4_oi4oi4obbb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 11) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
        if (!converter::Converter<bool>::accept(context, info[9])) return false;
        if (!converter::Converter<bool>::accept(context, info[10])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(context, info[9]);
    // JSValToCSVal P any
    bool p10 = converter::Converter<bool>::toCpp(context, info[10]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, void* p3, int32_t p4, void* p5, int32_t p6, void* p7, bool p8, bool p9, bool p10, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode)
static bool w_vos_r4r4r4_s_r4r4r4r4_oi4oi4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4_s_r4r4r4r4_oi4oi4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, void* p3, int32_t p4, void* p5, int32_t p6, void* p7, int32_t p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean)
static bool w_vos_r4r4r4_s_r4r4r4r4_oi4oi4oi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4_s_r4r4r4r4_oi4oi4oi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 10) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (!converter::Converter<bool>::accept(context, info[9])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(context, info[9]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, void* p3, int32_t p4, void* p5, int32_t p6, void* p7, int32_t p8, bool p9, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, UnityEngine.Transform)
static bool w_vos_r4r4r4_s_r4r4r4r4_oi4oi4oi4bo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4_s_r4r4r4r4_oi4oi4oi4bo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];
    auto TIp10 = wrapData->TypeInfos[6];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 11) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (!converter::Converter<bool>::accept(context, info[9])) return false;
        if (!info[10]->IsNullOrUndefined() && (!info[10]->IsObject() || (info[10]->IsFunction() ? !IsDelegate(TIp10) : !IsAssignableFrom(TIp10, GetTypeId(info[10].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(context, info[9]);
    // JSValToCSVal o/O
    void* p10 = JsValueToCSRef(context, info[10], TIp10);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, void* p3, int32_t p4, void* p5, int32_t p6, void* p7, int32_t p8, bool p9, void* p10, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, UnityEngine.Transform, Boolean)
static bool w_vos_r4r4r4_s_r4r4r4r4_oi4oi4oi4bob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4_s_r4r4r4r4_oi4oi4oi4bob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];
    auto TIp10 = wrapData->TypeInfos[6];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 12) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (!converter::Converter<bool>::accept(context, info[9])) return false;
        if (!info[10]->IsNullOrUndefined() && (!info[10]->IsObject() || (info[10]->IsFunction() ? !IsDelegate(TIp10) : !IsAssignableFrom(TIp10, GetTypeId(info[10].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[11])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(context, info[9]);
    // JSValToCSVal o/O
    void* p10 = JsValueToCSRef(context, info[10], TIp10);
    // JSValToCSVal P any
    bool p11 = converter::Converter<bool>::toCpp(context, info[11]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, void* p3, int32_t p4, void* p5, int32_t p6, void* p7, int32_t p8, bool p9, void* p10, bool p11, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3)
static bool w_vos_r4r4r4_s_r4r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4_s_r4r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[3]);
    s_r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, struct s_r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetEmissive(UnityEngine.Renderer, UnityEngine.Color)
static bool w_vos_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void DrawProcedural(UnityEngine.Material, UnityEngine.Bounds, UnityEngine.MeshTopology, Int32, Int32, UnityEngine.Camera, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, Int32)
static bool w_vos_r4r4r4r4r4r4_i4i4Di4DoDoDi4DbDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4_i4i4Di4DoDoDi4DbDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (length > 5 && !info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (length > 6 && !info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (length > 7 && !converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (length > 8 && !converter::Converter<bool>::accept(context, info[8])) return false;
        if (length > 9 && !converter::Converter<int32_t>::accept(context, info[9])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                
    // JSValToCSVal ref  with default
    void* p5 = OptionalParameter<void*>::GetRefType(context, info, method, 5, TIp5);
                
    // JSValToCSVal ref  with default
    void* p6 = OptionalParameter<void*>::GetRefType(context, info, method, 6, TIp6);
                
    // JSValToCSVal primitive with default
    int32_t p7 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 7);
                
    // JSValToCSVal primitive with default
    bool p8 = OptionalParameter<bool>::GetPrimitive(context, info, method, 8);
                
    // JSValToCSVal primitive with default
    int32_t p9 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 9);
                

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4_ p1, int32_t p2, int32_t p3, int32_t p4, void* p5, void* p6, int32_t p7, bool p8, int32_t p9, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void DrawProceduralIndirect(UnityEngine.Material, UnityEngine.Bounds, UnityEngine.MeshTopology, UnityEngine.ComputeBuffer, Int32, UnityEngine.Camera, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, Int32)
static bool w_vos_r4r4r4r4r4r4_i4oDi4DoDoDi4DbDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4_i4oDi4DoDoDi4DbDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (length > 5 && !info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (length > 6 && !info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (length > 7 && !converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (length > 8 && !converter::Converter<bool>::accept(context, info[8])) return false;
        if (length > 9 && !converter::Converter<int32_t>::accept(context, info[9])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                
    // JSValToCSVal ref  with default
    void* p5 = OptionalParameter<void*>::GetRefType(context, info, method, 5, TIp5);
                
    // JSValToCSVal ref  with default
    void* p6 = OptionalParameter<void*>::GetRefType(context, info, method, 6, TIp6);
                
    // JSValToCSVal primitive with default
    int32_t p7 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 7);
                
    // JSValToCSVal primitive with default
    bool p8 = OptionalParameter<bool>::GetPrimitive(context, info, method, 8);
                
    // JSValToCSVal primitive with default
    int32_t p9 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 9);
                

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4_ p1, int32_t p2, void* p3, int32_t p4, void* p5, void* p6, int32_t p7, bool p8, int32_t p9, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void DrawProcedural(UnityEngine.Material, UnityEngine.Bounds, UnityEngine.MeshTopology, UnityEngine.GraphicsBuffer, Int32, Int32, UnityEngine.Camera, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, Int32)
static bool w_vos_r4r4r4r4r4r4_i4oi4Di4DoDoDi4DbDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4_i4oi4Di4DoDoDi4DbDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];
    auto TIp7 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (length > 5 && !converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (length > 6 && !info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (length > 7 && !info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
        if (length > 8 && !converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (length > 9 && !converter::Converter<bool>::accept(context, info[9])) return false;
        if (length > 10 && !converter::Converter<int32_t>::accept(context, info[10])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 5);
                
    // JSValToCSVal ref  with default
    void* p6 = OptionalParameter<void*>::GetRefType(context, info, method, 6, TIp6);
                
    // JSValToCSVal ref  with default
    void* p7 = OptionalParameter<void*>::GetRefType(context, info, method, 7, TIp7);
                
    // JSValToCSVal primitive with default
    int32_t p8 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 8);
                
    // JSValToCSVal primitive with default
    bool p9 = OptionalParameter<bool>::GetPrimitive(context, info, method, 9);
                
    // JSValToCSVal primitive with default
    int32_t p10 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 10);
                

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4_ p1, int32_t p2, void* p3, int32_t p4, int32_t p5, void* p6, void* p7, int32_t p8, bool p9, int32_t p10, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);

    
    return true;
}

// Void DrawProceduralIndirect(UnityEngine.Material, UnityEngine.Bounds, UnityEngine.MeshTopology, UnityEngine.GraphicsBuffer, UnityEngine.ComputeBuffer, Int32, UnityEngine.Camera, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, Int32)
static bool w_vos_r4r4r4r4r4r4_i4ooDi4DoDoDi4DbDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4_i4ooDi4DoDoDi4DbDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp7 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (length > 5 && !converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (length > 6 && !info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (length > 7 && !info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
        if (length > 8 && !converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (length > 9 && !converter::Converter<bool>::accept(context, info[9])) return false;
        if (length > 10 && !converter::Converter<int32_t>::accept(context, info[10])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 5);
                
    // JSValToCSVal ref  with default
    void* p6 = OptionalParameter<void*>::GetRefType(context, info, method, 6, TIp6);
                
    // JSValToCSVal ref  with default
    void* p7 = OptionalParameter<void*>::GetRefType(context, info, method, 7, TIp7);
                
    // JSValToCSVal primitive with default
    int32_t p8 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 8);
                
    // JSValToCSVal primitive with default
    bool p9 = OptionalParameter<bool>::GetPrimitive(context, info, method, 9);
                
    // JSValToCSVal primitive with default
    int32_t p10 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 10);
                

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4_ p1, int32_t p2, void* p3, void* p4, int32_t p5, void* p6, void* p7, int32_t p8, bool p9, int32_t p10, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);

    
    return true;
}

// Void DrawMeshNow(UnityEngine.Mesh, UnityEngine.Matrix4x4)
static bool w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void DrawMeshNow(UnityEngine.Mesh, UnityEngine.Matrix4x4, Int32)
static bool w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Matrix4x4, UnityEngine.Material, Int32)
static bool w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.Camera)
static bool w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.Camera, Int32)
static bool w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, void* p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock)
static bool w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, void* p4, int32_t p5, void* p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock, Boolean)
static bool w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4ob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4ob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, void* p4, int32_t p5, void* p6, bool p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock, Boolean, Boolean)
static bool w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4obb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4obb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, void* p4, int32_t p5, void* p6, bool p7, bool p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock, Boolean, Boolean, Boolean)
static bool w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4obbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4obbb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 10) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
        if (!converter::Converter<bool>::accept(context, info[9])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(context, info[9]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, void* p4, int32_t p5, void* p6, bool p7, bool p8, bool p9, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode)
static bool w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, void* p4, int32_t p5, void* p6, int32_t p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean)
static bool w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, void* p4, int32_t p5, void* p6, int32_t p7, bool p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, UnityEngine.Transform)
static bool w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4bo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4bo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp9 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 10) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
        if (!info[9]->IsNullOrUndefined() && (!info[9]->IsObject() || (info[9]->IsFunction() ? !IsDelegate(TIp9) : !IsAssignableFrom(TIp9, GetTypeId(info[9].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);
    // JSValToCSVal o/O
    void* p9 = JsValueToCSRef(context, info[9], TIp9);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, void* p4, int32_t p5, void* p6, int32_t p7, bool p8, void* p9, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, UnityEngine.Transform, Boolean)
static bool w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4bob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4bob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp9 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 11) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
        if (!info[9]->IsNullOrUndefined() && (!info[9]->IsObject() || (info[9]->IsFunction() ? !IsDelegate(TIp9) : !IsAssignableFrom(TIp9, GetTypeId(info[9].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[10])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);
    // JSValToCSVal o/O
    void* p9 = JsValueToCSRef(context, info[9], TIp9);
    // JSValToCSVal P any
    bool p10 = converter::Converter<bool>::toCpp(context, info[10]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, void* p4, int32_t p5, void* p6, int32_t p7, bool p8, void* p9, bool p10, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, UnityEngine.Transform, UnityEngine.Rendering.LightProbeUsage)
static bool w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4boi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4boi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp9 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 11) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
        if (!info[9]->IsNullOrUndefined() && (!info[9]->IsObject() || (info[9]->IsFunction() ? !IsDelegate(TIp9) : !IsAssignableFrom(TIp9, GetTypeId(info[9].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[10])) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);
    // JSValToCSVal o/O
    void* p9 = JsValueToCSRef(context, info[9], TIp9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(context, info[10]);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, void* p4, int32_t p5, void* p6, int32_t p7, bool p8, void* p9, int32_t p10, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.Camera, Int32, UnityEngine.MaterialPropertyBlock, UnityEngine.Rendering.ShadowCastingMode, Boolean, UnityEngine.Transform, UnityEngine.Rendering.LightProbeUsage, UnityEngine.LightProbeProxyVolume)
static bool w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4boi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4boi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];
    auto TIp6 = wrapData->TypeInfos[4];
    auto TIp9 = wrapData->TypeInfos[5];
    auto TIp11 = wrapData->TypeInfos[6];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 12) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
        if (!info[9]->IsNullOrUndefined() && (!info[9]->IsObject() || (info[9]->IsFunction() ? !IsDelegate(TIp9) : !IsAssignableFrom(TIp9, GetTypeId(info[9].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[10])) return false;
        if (!info[11]->IsNullOrUndefined() && (!info[11]->IsObject() || (info[11]->IsFunction() ? !IsDelegate(TIp11) : !IsAssignableFrom(TIp11, GetTypeId(info[11].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);
    // JSValToCSVal o/O
    void* p9 = JsValueToCSRef(context, info[9], TIp9);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(context, info[10]);
    // JSValToCSVal o/O
    void* p11 = JsValueToCSRef(context, info[11], TIp11);

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, void* p4, int32_t p5, void* p6, int32_t p7, bool p8, void* p9, int32_t p10, void* p11, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void SQLRollback(IntPtr)
static bool w_vp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vp");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);

    typedef void (*FuncToCall)(void* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void entt_set_phystep(IntPtr, GCore.F64 ByRef)
static bool w_vpPs_i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpPs_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8_* p1 = nullptr; // valuetype ref
    s_i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void* p0, struct s_i8_* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void getBounds(IntPtr, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_vpPs_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpPs_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void getNearestPos(IntPtr, GCore.FVector3 ByRef, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_vpPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef void (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    return true;
}

// Void entt_collect_sortdist(IntPtr, GCore.FVector3 ByRef, Int32[], Int32[], Int32, IntPtr, GCore.GameSystemCallback, IntPtr)
static bool w_vpPs_i8i8i8_ooi4pop(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpPs_i8i8i8_ooi4pop");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];
    auto TIp7 = wrapData->TypeInfos[6];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsArrayBuffer()) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!info[7]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p1 = nullptr; // valuetype ref
    s_i8i8i8_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    void* p5 = DataTransfer::GetPointer<void>(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal P any
    void* p7 = DataTransfer::GetPointer<void>(context, info[7]);

    typedef void (*FuncToCall)(void* p0, struct s_i8i8i8_* p1, void* p2, void* p3, int32_t p4, void* p5, void* p6, void* p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void IssuePluginEvent(IntPtr, Int32)
static bool w_vpi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void grid_idx2cr(IntPtr, Int32, Int32 ByRef, Int32 ByRef, Int32, Int32)
static bool w_vpi4Pi4Pi4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4Pi4Pi4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (length > 5 && !converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(context, info[2]);
    int32_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int32_t up3 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(context, info[3]);
    int32_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 5);
                

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t* p2, int32_t* p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int32_t>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int32_t>::toScript(context, *p3));
    }
    
    return true;
}

// Void MapIdx2Pos(IntPtr, Int32, GCore.FVector3 ByRef)
static bool w_vpi4Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void grid_idx2pos(IntPtr, Int32, GCore.FVector3 ByRef, Int32, Int32)
static bool w_vpi4Ps_i8i8i8_Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4Ps_i8i8i8_Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef void (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void entt_get_bounds(IntPtr, Int32, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_vpi4Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef void (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    return true;
}

// Void entt_get_nearest_pos(IntPtr, Int32, GCore.FVector3 ByRef, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_vpi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p4 = nullptr; // valuetype ref
    s_i8i8i8_ up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
        auto tp4 = op4->Get(context, 0).ToLocalChecked();
        p4 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp4);
    }
    if (!p4) {
        p4 = &up4;
    }
        

    typedef void (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, struct s_i8i8i8_* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
            
    if (!op4.IsEmpty() && p4 == &up4)
    {
        auto _unused = op4->Set(context, 0, CopyValueType(isolate, context, TIp4, p4, sizeof(*p4)));
    }
    
    return true;
}

// Void entt_phy_raycast(IntPtr, Int32, GCore.FVector3 ByRef, GCore.FVector3 ByRef, GCore.PhyHitInfo ByRef, Int64 ByRef)
static bool w_vpi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8i8i8i8i8_Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8i8i8i8i8_Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
        if (!info[5]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8i8i8i8i8_* p4 = nullptr; // valuetype ref
    s_i8i8i8i8i8i8i8_ up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
        auto tp4 = op4->Get(context, 0).ToLocalChecked();
        p4 = DataTransfer::GetPointer<s_i8i8i8i8i8i8i8_>(context, tp4);
    }
    if (!p4) {
        p4 = &up4;
    }
        
    // JSValToCSVal P primitive
    int64_t up5 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[5]);
    int64_t* p5 = &up5;
    v8::Local<v8::Object> op5;
    if (!info[5].IsEmpty() && info[5]->IsObject()) {
        op5 = info[5]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(void* p0, int32_t p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, struct s_i8i8i8i8i8i8i8_* p4, int64_t* p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
            
    if (!op4.IsEmpty() && p4 == &up4)
    {
        auto _unused = op4->Set(context, 0, CopyValueType(isolate, context, TIp4, p4, sizeof(*p4)));
    }
            
    if (!op5.IsEmpty())
    {
        auto _unused = op5->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p5));
    }
    
    return true;
}

// Void grid_setmovemask(IntPtr, Int32, Int32)
static bool w_vpi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void grid_cr2pos(IntPtr, Int32, Int32, GCore.FVector3 ByRef)
static bool w_vpi4i4Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4i4Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, struct s_i8i8i8_* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    return true;
}

// Void entt_ignore_collideevt(IntPtr, Int32, Int32, Int32)
static bool w_vpi4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetMapCityColor(IntPtr, Int32, Int32, Int32, Int32)
static bool w_vpi4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void grid_findpath(IntPtr, Int32, Int32, Int32, Int32, Int32, Int32[])
static bool w_vpi4i4i4i4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4i4i4i4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp6 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, void* p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void grid_getoccupys(IntPtr, Int32, Int32, Int32, Int32[])
static bool w_vpi4i4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4i4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);

    typedef void (*FuncToCall)(void* p0, int32_t p1, int32_t p2, int32_t p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void MapFaceNeis(IntPtr, Int32, Int32[])
static bool w_vpi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void entt_phy_debug(IntPtr, Int32, IntPtr, GCore.OnDebugLineCallback)
static bool w_vpi4po(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4po");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsArrayBuffer()) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void OnUpdate(IntPtr, Int32, IntPtr, IntPtr, Int64)
static bool w_vpi4ppi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi4ppi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsArrayBuffer()) return false;
        if (!info[3]->IsArrayBuffer()) return false;
        if (!converter::Converter<int64_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(context, info[2]);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(context, info[3]);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, void* p2, void* p3, int64_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void RemoveRVOAgent(IntPtr, Int64)
static bool w_vpi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, int64_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetRVOAgentMaxSpd(IntPtr, Int64, GCore.F64 ByRef)
static bool w_vpi8Ps_i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi8Ps_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8_* p2 = nullptr; // valuetype ref
    s_i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(void* p0, int64_t p1, struct s_i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void SetRVOAgentPosition(IntPtr, Int64, GCore.FVector3 ByRef)
static bool w_vpi8Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpi8Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(void* p0, int64_t p1, struct s_i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void SQLQuery(IntPtr, Byte[], Int32)
static bool w_vpoi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpoi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void grid_getpolyoccupys(IntPtr, GCore.FVector3[], Int32, Int32[])
static bool w_vpoi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpoi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void* p0, void* p1, int32_t p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void entt_add_system(IntPtr, Int32[], Int32[], IntPtr, GCore.GameSystemCallback, IntPtr)
static bool w_vpoopop(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpoopop");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsArrayBuffer()) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!info[5]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    void* p5 = DataTransfer::GetPointer<void>(context, info[5]);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void SQLUpdateHook(IntPtr, GCore.SqliteUpdateHook, IntPtr)
static bool w_vpop(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpop");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void RemoveRVOObstacle(IntPtr, IntPtr)
static bool w_vpp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void entt_get_poses(IntPtr, IntPtr, IntPtr)
static bool w_vppp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vppp");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!info[2]->IsArrayBuffer()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void ForwardRawInput(IntPtr, IntPtr, UInt32, IntPtr, UInt32)
static bool w_vppu4pu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vppu4pu4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    void* p3 = DataTransfer::GetPointer<void>(context, info[3]);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void* p0, void* p1, uint32_t p2, void* p3, uint32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void PGQuery(IntPtr, System.String)
static bool w_vps(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vps");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void entt_phy_debugunit(IntPtr, UInt32)
static bool w_vpu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void entt_add_capsulephy(IntPtr, UInt32, Int64 ByRef, Int64 ByRef, Int32, Int32, Int64 ByRef, Int32, Int64 ByRef, Int32)
static bool w_vpu4Pi8Pi8i4i4Pi8i4Pi8i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Pi8Pi8i4i4Pi8i4Pi8i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 10) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!info[8]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[9])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[2]);
    int64_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P primitive
    int64_t up6 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[6]);
    int64_t* p6 = &up6;
    v8::Local<v8::Object> op6;
    if (!info[6].IsEmpty() && info[6]->IsObject()) {
        op6 = info[6]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P primitive
    int64_t up8 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[8]);
    int64_t* p8 = &up8;
    v8::Local<v8::Object> op8;
    if (!info[8].IsEmpty() && info[8]->IsObject()) {
        op8 = info[8]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(context, info[9]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int64_t* p2, int64_t* p3, int32_t p4, int32_t p5, int64_t* p6, int32_t p7, int64_t* p8, int32_t p9, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    if (!op6.IsEmpty())
    {
        auto _unused = op6->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p6));
    }
    
    if (!op8.IsEmpty())
    {
        auto _unused = op8->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p8));
    }
    
    return true;
}

// Void entt_add_spherephy(IntPtr, UInt32, Int64 ByRef, Int32, Int32, Int64 ByRef, Int32, Int64 ByRef, Int32)
static bool w_vpu4Pi8i4i4Pi8i4Pi8i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Pi8i4i4Pi8i4Pi8i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P primitive
    int64_t up2 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[2]);
    int64_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P primitive
    int64_t up5 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[5]);
    int64_t* p5 = &up5;
    v8::Local<v8::Object> op5;
    if (!info[5].IsEmpty() && info[5]->IsObject()) {
        op5 = info[5]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P primitive
    int64_t up7 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[7]);
    int64_t* p7 = &up7;
    v8::Local<v8::Object> op7;
    if (!info[7].IsEmpty() && info[7]->IsObject()) {
        op7 = info[7]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int64_t* p2, int32_t p3, int32_t p4, int64_t* p5, int32_t p6, int64_t* p7, int32_t p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p2));
    }
    
    if (!op5.IsEmpty())
    {
        auto _unused = op5->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p5));
    }
    
    if (!op7.IsEmpty())
    {
        auto _unused = op7->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p7));
    }
    
    return true;
}

// Void entt_local2world(IntPtr, UInt32, GCore.FVector3 ByRef)
static bool w_vpu4Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(void* p0, uint32_t p1, struct s_i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void entt_add_obstacle(IntPtr, UInt32, GCore.FVector3 ByRef, Int64 ByRef, Int64 ByRef)
static bool w_vpu4Ps_i8i8i8_Pi8Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Ps_i8i8i8_Pi8Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up4 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[4]);
    int64_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(void* p0, uint32_t p1, struct s_i8i8i8_* p2, int64_t* p3, int64_t* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p4));
    }
    
    return true;
}

// Void entt_add_pointforce(IntPtr, UInt32, GCore.FVector3 ByRef, GCore.FVector3 ByRef)
static bool w_vpu4Ps_i8i8i8_Ps_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Ps_i8i8i8_Ps_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_i8i8i8_* p3 = nullptr; // valuetype ref
    s_i8i8i8_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef void (*FuncToCall)(void* p0, uint32_t p1, struct s_i8i8i8_* p2, struct s_i8i8i8_* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    return true;
}

// Void entt_set_rvoagvel(IntPtr, UInt32, GCore.FVector3 ByRef, Int32)
static bool w_vpu4Ps_i8i8i8_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Ps_i8i8i8_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, struct s_i8i8i8_* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void entt_movewithrad(IntPtr, UInt32, GCore.FVector3 ByRef, Int32, Int64 ByRef, Int64 ByRef, Int64 ByRef)
static bool w_vpu4Ps_i8i8i8_i4Pi8Pi8Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Ps_i8i8i8_i4Pi8Pi8Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsObject()) return false;
        if (!info[5]->IsObject()) return false;
        if (!info[6]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P primitive
    int64_t up4 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[4]);
    int64_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up5 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[5]);
    int64_t* p5 = &up5;
    v8::Local<v8::Object> op5;
    if (!info[5].IsEmpty() && info[5]->IsObject()) {
        op5 = info[5]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up6 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[6]);
    int64_t* p6 = &up6;
    v8::Local<v8::Object> op6;
    if (!info[6].IsEmpty() && info[6]->IsObject()) {
        op6 = info[6]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(void* p0, uint32_t p1, struct s_i8i8i8_* p2, int32_t p3, int64_t* p4, int64_t* p5, int64_t* p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p4));
    }
    
    if (!op5.IsEmpty())
    {
        auto _unused = op5->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p5));
    }
    
    if (!op6.IsEmpty())
    {
        auto _unused = op6->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p6));
    }
    
    return true;
}

// Void entt_moveto(IntPtr, UInt32, GCore.FVector3 ByRef, Int32, Int64 ByRef, Int32)
static bool w_vpu4Ps_i8i8i8_i4Pi8i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Ps_i8i8i8_i4Pi8i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P primitive
    int64_t up4 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[4]);
    int64_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, struct s_i8i8i8_* p2, int32_t p3, int64_t* p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p4));
    }
    
    return true;
}

// Void entt_add_boxphy(IntPtr, UInt32, GCore.FVector3 ByRef, Int32, Int32, Int64 ByRef, Int32, Int64 ByRef, Int32)
static bool w_vpu4Ps_i8i8i8_i4i4Pi8i4Pi8i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Ps_i8i8i8_i4i4Pi8i4Pi8i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P primitive
    int64_t up5 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[5]);
    int64_t* p5 = &up5;
    v8::Local<v8::Object> op5;
    if (!info[5].IsEmpty() && info[5]->IsObject()) {
        op5 = info[5]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P primitive
    int64_t up7 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[7]);
    int64_t* p7 = &up7;
    v8::Local<v8::Object> op7;
    if (!info[7].IsEmpty() && info[7]->IsObject()) {
        op7 = info[7]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, struct s_i8i8i8_* p2, int32_t p3, int32_t p4, int64_t* p5, int32_t p6, int64_t* p7, int32_t p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op5.IsEmpty())
    {
        auto _unused = op5->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p5));
    }
    
    if (!op7.IsEmpty())
    {
        auto _unused = op7->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p7));
    }
    
    return true;
}

// Void entt_set_rotation(IntPtr, UInt32, GCore.FQuaterion ByRef)
static bool w_vpu4Ps_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4Ps_i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal Pstruct
    s_i8i8i8i8_* p2 = nullptr; // valuetype ref
    s_i8i8i8i8_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(void* p0, uint32_t p1, struct s_i8i8i8i8_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void entt_phy_active(IntPtr, UInt32, Int32)
static bool w_vpu4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void entt_set_colideroffset(IntPtr, UInt32, Int32, Int64 ByRef)
static bool w_vpu4i4Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i4Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int32_t p2, int64_t* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    return true;
}

// Void entt_add_rvoobst(IntPtr, UInt32, Int32, Int64 ByRef, Int64 ByRef)
static bool w_vpu4i4Pi8Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i4Pi8Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up4 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[4]);
    int64_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int32_t p2, int64_t* p3, int64_t* p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p4));
    }
    
    return true;
}

// Void entt_add_crowd(IntPtr, UInt32, Int32, Int64 ByRef, Int64 ByRef, Int64 ByRef, Int64 ByRef, Int32)
static bool w_vpu4i4Pi8Pi8Pi8Pi8i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i4Pi8Pi8Pi8Pi8i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
        if (!info[5]->IsObject()) return false;
        if (!info[6]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up4 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[4]);
    int64_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up5 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[5]);
    int64_t* p5 = &up5;
    v8::Local<v8::Object> op5;
    if (!info[5].IsEmpty() && info[5]->IsObject()) {
        op5 = info[5]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up6 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[6]);
    int64_t* p6 = &up6;
    v8::Local<v8::Object> op6;
    if (!info[6].IsEmpty() && info[6]->IsObject()) {
        op6 = info[6]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int32_t p2, int64_t* p3, int64_t* p4, int64_t* p5, int64_t* p6, int32_t p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p4));
    }
    
    if (!op5.IsEmpty())
    {
        auto _unused = op5->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p5));
    }
    
    if (!op6.IsEmpty())
    {
        auto _unused = op6->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p6));
    }
    
    return true;
}

// Void entt_add_rvoag(IntPtr, UInt32, Int32, Int64 ByRef, Int64 ByRef, Int32, Int64 ByRef)
static bool w_vpu4i4Pi8Pi8i4Pi8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i4Pi8Pi8i4Pi8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsObject()) return false;
        if (!info[4]->IsObject()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsObject()) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P primitive
    int64_t up3 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[3]);
    int64_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int64_t up4 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[4]);
    int64_t* p4 = &up4;
    v8::Local<v8::Object> op4;
    if (!info[4].IsEmpty() && info[4]->IsObject()) {
        op4 = info[4]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P primitive
    int64_t up6 = converter::Converter<std::reference_wrapper<int64_t>>::toCpp(context, info[6]);
    int64_t* p6 = &up6;
    v8::Local<v8::Object> op6;
    if (!info[6].IsEmpty() && info[6]->IsObject()) {
        op6 = info[6]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int32_t p2, int64_t* p3, int64_t* p4, int32_t p5, int64_t* p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p3));
    }
    
    if (!op4.IsEmpty())
    {
        auto _unused = op4->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p4));
    }
    
    if (!op6.IsEmpty())
    {
        auto _unused = op6->Set(context, 0, converter::Converter<int64_t>::toScript(context, *p6));
    }
    
    return true;
}

// Void entt_setblacklst(IntPtr, UInt32, Int32, Int32)
static bool w_vpu4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void entt_freeze_bodypos(IntPtr, UInt32, Int32, Int32, Int32)
static bool w_vpu4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void entt_set_worldstate(IntPtr, UInt32, Int64)
static bool w_vpu4i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void entt_setgoal(IntPtr, UInt32, Int64, Int32, Int32)
static bool w_vpu4i8i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4i8i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, int64_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void entt_ignore_collision(IntPtr, UInt32, UInt32, Int32)
static bool w_vpu4u4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4u4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, uint32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void entt_addaction(IntPtr, UInt32, UInt32, Int64, Int64, Int32, Int32)
static bool w_vpu4u4i8i8i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vpu4u4i8i8i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef void (*FuncToCall)(void* p0, uint32_t p1, uint32_t p2, int64_t p3, int64_t p4, int32_t p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void set_devicePixelRatio(Single)
static bool w_vr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(float p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void SetLODSettings(Single, Int32, Boolean)
static bool w_vr4i4Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vr4i4Db");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(float p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void TexCoord2(Single, Single)
static bool w_vr4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vr4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(float p0, float p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Vertex3(Single, Single, Single)
static bool w_vr4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vr4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(float p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void LoadPixelMatrix(Single, Single, Single, Single)
static bool w_vr4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vr4r4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(float p0, float p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void AreApproximatelyEqual(Single, Single, Single, System.String)
static bool w_vr4r4r4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vr4r4r4s");
    
    auto TIp3 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!info[3]->IsString() && !info[3]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal s
    v8::String::Utf8Value tp3(isolate, info[3]);
    void* p3 = CStringToCSharpString(*tp3);

    typedef void (*FuncToCall)(float p0, float p1, float p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void AreApproximatelyEqual(Single, Single, System.String)
static bool w_vr4r4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vr4r4s");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(float p0, float p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void set_branch(System.String)
static bool w_vs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void (*FuncToCall)(void* p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void Begin(System.String, Boolean)
static bool w_vsDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void GetAllRenderPipelineAssetsForPlatform(System.String, System.Collections.Generic.List`1[UnityEngine.Rendering.RenderPipelineAsset] ByRef)
static bool w_vsPo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsPo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsObject()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal Po/PO
    void* up1 = nullptr; // object ref
    void** p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        up1 = JsValueToCSRef(context, tp1, TIp1);
    }
        

    typedef void (*FuncToCall)(void* p0, void** p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, CSRefToJsValue(isolate, context, *p1));
    }
    
    return true;
}

// Void LogFormat(System.String, System.Object[])
static bool w_vsVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal ref params
    void* p1 = RestArguments<void*>::PackRef(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void ApplyAndDisposeWritableMeshData(MeshDataArray, UnityEngine.Mesh, UnityEngine.Rendering.MeshUpdateFlags)
static bool w_vs_Ppi4i4i4pi4i4o_oDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_Ppi4i4i4pi4i4o_oDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_Ppi4i4i4pi4i4o_* pp0 = DataTransfer::GetPointer<s_Ppi4i4i4pi4i4o_>(context, info[0]);
    s_Ppi4i4i4pi4i4o_ p0 = pp0 ? *pp0 : s_Ppi4i4i4pi4i4o_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(struct s_Ppi4i4i4pi4i4o_ p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void GetAllCategories(Unity.Collections.NativeArray`1[Unity.Profiling.ProfilerCategory])
static bool w_vs_Pvi4i4i4pi4i4oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_Pvi4i4i4pi4i4oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};

    typedef void (*FuncToCall)(struct s_Pvi4i4i4pi4i4oi4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void InstanceIDToObjectList(Unity.Collections.NativeArray`1[System.Int32], System.Collections.Generic.List`1[UnityEngine.Object])
static bool w_vs_Pvi4i4i4pi4i4oi4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_Pvi4i4i4pi4i4oi4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(struct s_Pvi4i4i4pi4i4oi4_ p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SampleLightInfo(UnityEngine.LayerMask)
static bool w_vs_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4_* pp0 = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p0 = pp0 ? *pp0 : s_i4_ {};

    typedef void (*FuncToCall)(struct s_i4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void MoveCacheBefore(UnityEngine.Cache, UnityEngine.Cache)
static bool w_vs_i4_s_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_i4_s_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4_* pp0 = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p0 = pp0 ? *pp0 : s_i4_ {};
    // JSValToCSVal struct
    s_i4_* pp1 = DataTransfer::GetPointer<s_i4_>(context, info[1]);
    s_i4_ p1 = pp1 ? *pp1 : s_i4_ {};

    typedef void (*FuncToCall)(struct s_i4_ p0, struct s_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void EmitFrameMetaData(System.Guid, Int32, System.Array)
static bool w_vs_i4i2i2u1u1u1u1u1u1u1u1_i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_i4i2i2u1u1u1u1u1u1u1u1_i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<s_i4i2i2u1u1u1u1u1u1u1u1_>(context, info[0]);
    s_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : s_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(struct s_i4i2i2u1u1u1u1u1u1u1u1_ p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void set_state(State)
static bool w_vs_i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4i4_>(context, info[0]);
    s_i4i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4i4_ {};

    typedef void (*FuncToCall)(struct s_i4i4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer)
static bool w_vs_i4p_s_i4p_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_i4p_s_i4p_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_i4p_* pp0 = DataTransfer::GetPointer<s_i4p_>(context, info[0]);
    s_i4p_ p0 = pp0 ? *pp0 : s_i4p_ {};
    // JSValToCSVal struct
    s_i4p_* pp1 = DataTransfer::GetPointer<s_i4p_>(context, info[1]);
    s_i4p_ p1 = pp1 ? *pp1 : s_i4p_ {};

    typedef void (*FuncToCall)(struct s_i4p_ p0, struct s_i4p_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer, Int32)
static bool w_vs_i4p_s_i4p_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_i4p_s_i4p_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_i4p_* pp0 = DataTransfer::GetPointer<s_i4p_>(context, info[0]);
    s_i4p_ p0 = pp0 ? *pp0 : s_i4p_ {};
    // JSValToCSVal struct
    s_i4p_* pp1 = DataTransfer::GetPointer<s_i4p_>(context, info[1]);
    s_i4p_ p1 = pp1 ? *pp1 : s_i4p_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(struct s_i4p_ p0, struct s_i4p_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer, Int32, UnityEngine.CubemapFace)
static bool w_vs_i4p_s_i4p_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_i4p_s_i4p_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_i4p_* pp0 = DataTransfer::GetPointer<s_i4p_>(context, info[0]);
    s_i4p_ p0 = pp0 ? *pp0 : s_i4p_ {};
    // JSValToCSVal struct
    s_i4p_* pp1 = DataTransfer::GetPointer<s_i4p_>(context, info[1]);
    s_i4p_ p1 = pp1 ? *pp1 : s_i4p_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(struct s_i4p_ p0, struct s_i4p_ p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer, Int32, UnityEngine.CubemapFace, Int32)
static bool w_vs_i4p_s_i4p_i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_i4p_s_i4p_i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_i4p_* pp0 = DataTransfer::GetPointer<s_i4p_>(context, info[0]);
    s_i4p_ p0 = pp0 ? *pp0 : s_i4p_ {};
    // JSValToCSVal struct
    s_i4p_* pp1 = DataTransfer::GetPointer<s_i4p_>(context, info[1]);
    s_i4p_ p1 = pp1 ? *pp1 : s_i4p_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(struct s_i4p_ p0, struct s_i4p_ p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.RenderTargetSetup)
static bool w_vs_oi4pi4i4i4ooi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_oi4pi4i4i4ooi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_oi4pi4i4i4ooi4i4_* pp0 = DataTransfer::GetPointer<s_oi4pi4i4i4ooi4i4_>(context, info[0]);
    s_oi4pi4i4i4ooi4i4_ p0 = pp0 ? *pp0 : s_oi4pi4i4i4ooi4i4_ {};

    typedef void (*FuncToCall)(struct s_oi4pi4i4i4ooi4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void SetPlayerLoop(UnityEngine.LowLevel.PlayerLoopSystem)
static bool w_vs_ooopp_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_ooopp_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_ooopp_* pp0 = DataTransfer::GetPointer<s_ooopp_>(context, info[0]);
    s_ooopp_ p0 = pp0 ? *pp0 : s_ooopp_ {};

    typedef void (*FuncToCall)(struct s_ooopp_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void WaitOnAsyncGraphicsFence(UnityEngine.Rendering.GraphicsFence)
static bool w_vs_pi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_pi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_pi4i4_* pp0 = DataTransfer::GetPointer<s_pi4i4_>(context, info[0]);
    s_pi4i4_ p0 = pp0 ? *pp0 : s_pi4i4_ {};

    typedef void (*FuncToCall)(struct s_pi4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void WaitOnAsyncGraphicsFence(UnityEngine.Rendering.GraphicsFence, UnityEngine.Rendering.SynchronisationStage)
static bool w_vs_pi4i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_pi4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_pi4i4_* pp0 = DataTransfer::GetPointer<s_pi4i4_>(context, info[0]);
    s_pi4i4_ p0 = pp0 ? *pp0 : s_pi4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(struct s_pi4i4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void Vertex(UnityEngine.Vector3)
static bool w_vs_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void GetInterpolatedProbe(UnityEngine.Vector3, UnityEngine.Renderer, UnityEngine.Rendering.SphericalHarmonicsL2 ByRef)
static bool w_vs_r4r4r4_oPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_oPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsObject()) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p2 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, void* p1, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void DrawWireSphere(UnityEngine.Vector3, Single)
static bool w_vs_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void DrawFrustum(UnityEngine.Vector3, Single, Single, Single, Single)
static bool w_vs_r4r4r4_r4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_r4r4r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, float p1, float p2, float p3, float p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawIcon(UnityEngine.Vector3, System.String)
static bool w_vs_r4r4r4_s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_s");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_vs_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Color)
static bool w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Color, Single)
static bool w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, float p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawLine(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Color, Single, Boolean)
static bool w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, float p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawIcon(UnityEngine.Vector3, System.String, Boolean)
static bool w_vs_r4r4r4_sb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_sb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, void* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void DrawIcon(UnityEngine.Vector3, System.String, Boolean, UnityEngine.Color)
static bool w_vs_r4r4r4_sbs_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4_sbs_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4r4_ p0, void* p1, bool p2, struct s_r4r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void set_color(UnityEngine.Color)
static bool w_vs_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void RGBToHSV(UnityEngine.Color, Single ByRef, Single ByRef, Single ByRef)
static bool w_vs_r4r4r4r4_Pr4Pr4Pr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4_Pr4Pr4Pr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[1]);
    float* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    float up2 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[2]);
    float* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    float up3 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[3]);
    float* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(struct s_r4r4r4r4_ p0, float* p1, float* p2, float* p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<float>::toScript(context, *p1));
    }
    
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<float>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<float>::toScript(context, *p3));
    }
    
    return true;
}

// Void DrawGUITexture(UnityEngine.Rect, UnityEngine.Texture)
static bool w_vs_r4r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(struct s_r4r4r4r4_ p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void DrawGUITexture(UnityEngine.Rect, UnityEngine.Texture, Int32, Int32, Int32, Int32)
static bool w_vs_r4r4r4r4_oi4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4_oi4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(struct s_r4r4r4r4_ p0, void* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void DrawGUITexture(UnityEngine.Rect, UnityEngine.Texture, Int32, Int32, Int32, Int32, UnityEngine.Material)
static bool w_vs_r4r4r4r4_oi4i4i4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4_oi4i4i4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);

    typedef void (*FuncToCall)(struct s_r4r4r4r4_ p0, void* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, void* p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, Int32, Int32, Int32, Int32, UnityEngine.Material, Int32)
static bool w_vs_r4r4r4r4_oi4i4i4i4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4_oi4i4i4i4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(struct s_r4r4r4r4_ p0, void* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, void* p6, int32_t p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void DrawGUITexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Material)
static bool w_vs_r4r4r4r4_oo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4_oo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(struct s_r4r4r4r4_ p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Material, Int32)
static bool w_vs_r4r4r4r4_ooi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4_ooi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(struct s_r4r4r4r4_ p0, void* p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Rect, Int32, Int32, Int32, Int32)
static bool w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef void (*FuncToCall)(struct s_r4r4r4r4_ p0, void* p1, struct s_r4r4r4r4_ p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Rect, Int32, Int32, Int32, Int32, UnityEngine.Material)
static bool w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);

    typedef void (*FuncToCall)(struct s_r4r4r4r4_ p0, void* p1, struct s_r4r4r4r4_ p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, void* p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Rect, Int32, Int32, Int32, Int32, UnityEngine.Material, Int32)
static bool w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);

    typedef void (*FuncToCall)(struct s_r4r4r4r4_ p0, void* p1, struct s_r4r4r4r4_ p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, void* p7, int32_t p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Rect, Int32, Int32, Int32, Int32, UnityEngine.Color)
static bool w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if ((!info[7]->IsObject() || !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp7 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[7]);
    s_r4r4r4r4_ p7 = pp7 ? *pp7 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4r4r4_ p0, void* p1, struct s_r4r4r4r4_ p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, struct s_r4r4r4r4_ p7, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Rect, Int32, Int32, Int32, Int32, UnityEngine.Color, UnityEngine.Material)
static bool w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4s_r4r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4s_r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];
    auto TIp8 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if ((!info[7]->IsObject() || !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>())))) return false;
        if (!info[8]->IsNullOrUndefined() && (!info[8]->IsObject() || (info[8]->IsFunction() ? !IsDelegate(TIp8) : !IsAssignableFrom(TIp8, GetTypeId(info[8].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp7 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[7]);
    s_r4r4r4r4_ p7 = pp7 ? *pp7 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p8 = JsValueToCSRef(context, info[8], TIp8);

    typedef void (*FuncToCall)(struct s_r4r4r4r4_ p0, void* p1, struct s_r4r4r4r4_ p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, struct s_r4r4r4r4_ p7, void* p8, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void DrawTexture(UnityEngine.Rect, UnityEngine.Texture, UnityEngine.Rect, Int32, Int32, Int32, Int32, UnityEngine.Color, UnityEngine.Material, Int32)
static bool w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4s_r4r4r4r4_oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4s_r4r4r4r4_oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];
    auto TIp8 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 10) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if ((!info[7]->IsObject() || !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>())))) return false;
        if (!info[8]->IsNullOrUndefined() && (!info[8]->IsObject() || (info[8]->IsFunction() ? !IsDelegate(TIp8) : !IsAssignableFrom(TIp8, GetTypeId(info[8].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[9])) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp7 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[7]);
    s_r4r4r4r4_ p7 = pp7 ? *pp7 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p8 = JsValueToCSRef(context, info[8], TIp8);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(context, info[9]);

    typedef void (*FuncToCall)(struct s_r4r4r4r4_ p0, void* p1, struct s_r4r4r4r4_ p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, struct s_r4r4r4r4_ p7, void* p8, int32_t p9, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void DrawRay(UnityEngine.Ray)
static bool w_vs_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void set_matrix(UnityEngine.Matrix4x4)
static bool w_vs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void CalculateFrustumPlanes(UnityEngine.Matrix4x4, UnityEngine.Plane[])
static bool w_vs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void set_ambientProbe(UnityEngine.Rendering.SphericalHarmonicsL2)
static bool w_vs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void SetNoBackupFlag(UnityEngine.CachedAssetBundle)
static bool w_vs_su8u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_su8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal struct
    s_su8u8_* pp0 = DataTransfer::GetPointer<s_su8u8_>(context, info[0]);
    s_su8u8_ p0 = pp0 ? *pp0 : s_su8u8_ {};

    typedef void (*FuncToCall)(struct s_su8u8_ p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void SetCategoryEnabled(Unity.Profiling.ProfilerCategory, Boolean)
static bool w_vs_u2_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vs_u2_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal struct
    s_u2_* pp0 = DataTransfer::GetPointer<s_u2_>(context, info[0]);
    s_u2_ p0 = pp0 ? *pp0 : s_u2_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(struct s_u2_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void LaunchUri(System.String, Boolean)
static bool w_vsb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetGlobalInt(System.String, Int32)
static bool w_vsi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetPackageItemExtension(System.String, System.Type)
static bool w_vso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void TakeSnapshot(System.String, System.Action`2[System.String,System.Boolean], UnityEngine.Profiling.Memory.Experimental.CaptureFlags)
static bool w_vsoDu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsoDu4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (length > 2 && !converter::Converter<uint32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal primitive with default
    uint32_t p2 = OptionalParameter<uint32_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void* p0, void* p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetGlobalTexture(System.String, UnityEngine.RenderTexture, UnityEngine.Rendering.RenderTextureSubElement)
static bool w_vsoi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsoi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetGlobalConstantBuffer(System.String, UnityEngine.ComputeBuffer, Int32, Int32)
static bool w_vsoi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsoi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void* p0, void* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void TakeSnapshot(System.String, System.Action`2[System.String,System.Boolean], System.Action`3[System.String,System.Boolean,UnityEngine.Profiling.Experimental.DebugScreenCapture], UnityEngine.Profiling.Memory.Experimental.CaptureFlags)
static bool w_vsooDu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsooDu4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (length > 3 && !converter::Converter<uint32_t>::accept(context, info[3])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal primitive with default
    uint32_t p3 = OptionalParameter<uint32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, uint32_t p3, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetGlobalFloat(System.String, Single)
static bool w_vsr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void* p0, float p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetVar(System.String, System.String)
static bool w_vss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void DeleteSecondary(System.String, UnityEngine.Vector2)
static bool w_vss_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vss_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef void (*FuncToCall)(void* p0, struct s_r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetGlobalVector(System.String, UnityEngine.Vector4)
static bool w_vss_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vss_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetGlobalMatrix(System.String, UnityEngine.Matrix4x4)
static bool w_vss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void SetNoBackupFlag(System.String, UnityEngine.Hash128)
static bool w_vss_u8u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vss_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_u8u8_* pp1 = DataTransfer::GetPointer<s_u8u8_>(context, info[1]);
    s_u8u8_ p1 = pp1 ? *pp1 : s_u8u8_ {};

    typedef void (*FuncToCall)(void* p0, struct s_u8u8_ p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void CreateObjectAsync(System.String, System.String, CreateObjectCallback)
static bool w_vsso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vsso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void RemoveChildren()
static bool w_vt(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vt");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    

    typedef void (*FuncToCall)(void*,const void* method);
    ((FuncToCall)methodPointer)(self,  method);

    
    return true;
}

// Void Kill(Boolean)
static bool w_vtDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<bool>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(context, info, method, 0);
                

    typedef void (*FuncToCall)(void*,bool p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Boolean, Boolean)
static bool w_vtDbDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDbDb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<bool>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,bool p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Boolean, UnityEngine.Rendering.CompareFunction)
static bool w_vtDbDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDbDi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<bool>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,bool p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Boolean, Byte, Byte, UnityEngine.Rendering.CompareFunction, UnityEngine.Rendering.StencilOp, UnityEngine.Rendering.StencilOp, UnityEngine.Rendering.StencilOp)
static bool w_vtDbDu1Du1Di4Di4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDbDu1Du1Di4Di4Di4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<bool>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<uint8_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<uint8_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (length > 5 && !converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (length > 6 && !converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    bool p0 = OptionalParameter<bool>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    uint8_t p1 = OptionalParameter<uint8_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    uint8_t p2 = OptionalParameter<uint8_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 6);
                

    typedef void (*FuncToCall)(void*,bool p0, uint8_t p1, uint8_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void AddTriangles(Int32)
static bool w_vtDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 0);
                

    typedef void (*FuncToCall)(void*,int32_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void RemoveChildren(Int32, Int32)
static bool w_vtDi4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDi4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32)
static bool w_vtDi4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDi4Di4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.VertexAttribute, UnityEngine.Rendering.VertexAttributeFormat, Int32, Int32)
static bool w_vtDi4Di4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDi4Di4Di4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.ColorWriteMask, UnityEngine.Rendering.BlendMode, UnityEngine.Rendering.BlendMode, UnityEngine.Rendering.BlendMode, UnityEngine.Rendering.BlendMode, UnityEngine.Rendering.BlendOp, UnityEngine.Rendering.BlendOp)
static bool w_vtDi4Di4Di4Di4Di4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDi4Di4Di4Di4Di4Di4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (length > 5 && !converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (length > 6 && !converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 6);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.CullMode, Int32, Single, Boolean)
static bool w_vtDi4Di4Dr4Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDi4Di4Dr4Db");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<float>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, float p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void clearMem(Int32, System.Collections.Generic.List`1[System.Int32])
static bool w_vtDi4Do(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDi4Do");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    int32_t p0 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal ref  with default
    void* p1 = OptionalParameter<void*>::GetRefType(context, info, method, 1, TIp1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Int64, Int64, Int64)
static bool w_vtDi8Di8Di8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDi8Di8Di8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int64_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    int64_t p0 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int64_t p1 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int64_t p2 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,int64_t p0, int64_t p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int64, Int64, Int64, Int64)
static bool w_vtDi8Di8Di8Di8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDi8Di8Di8Di8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    int64_t p0 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int64_t p1 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int64_t p2 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int64_t p3 = OptionalParameter<int64_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,int64_t p0, int64_t p1, int64_t p2, int64_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void RecalculateUVDistributionMetrics(Single)
static bool w_vtDr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    float p0 = OptionalParameter<float>::GetPrimitive(context, info, method, 0);
                

    typedef void (*FuncToCall)(void*,float p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Single, Single, Single)
static bool w_vtDr4Dr4Dr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDr4Dr4Dr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<float>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<float>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    float p0 = OptionalParameter<float>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Single, Single, Single, Single)
static bool w_vtDr4Dr4Dr4Dr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDr4Dr4Dr4Dr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && !converter::Converter<float>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<float>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<float>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive with default
    float p0 = OptionalParameter<float>::GetPrimitive(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    float p3 = OptionalParameter<float>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(System.Nullable`1[UnityEngine.Rendering.RenderQueueRange], Int32, UInt32, Int32)
static bool w_vtDs_bi4i4_Di4Du4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtDs_bi4i4_Di4Du4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 0) return false;
        if (length > 0 && (!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<uint32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal valuetype  with default
    s_bi4i4_ p0 = OptionalParameter<s_bi4i4_>::GetValueType(context, info, method, 0);
                
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    uint32_t p2 = OptionalParameter<uint32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,struct s_bi4i4_ p0, int32_t p1, uint32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Log(System.Object)
static bool w_vtO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void GetSnappingPosition(Single ByRef, Single ByRef)
static bool w_vtPr4Pr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPr4Pr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P primitive
    float up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[0]);
    float* p0 = &up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[1]);
    float* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(void*,float* p0, float* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty())
    {
        auto _unused = op0->Set(context, 0, converter::Converter<float>::toScript(context, *p0));
    }
    
    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<float>::toScript(context, *p1));
    }
    
    return true;
}

// Void GetSnappingPositionWithDir(Single ByRef, Single ByRef, Single, Single)
static bool w_vtPr4Pr4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPr4Pr4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P primitive
    float up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[0]);
    float* p0 = &up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    float up1 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[1]);
    float* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,float* p0, float* p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    if (!op0.IsEmpty())
    {
        auto _unused = op0->Set(context, 0, converter::Converter<float>::toScript(context, *p0));
    }
    
    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<float>::toScript(context, *p1));
    }
    
    return true;
}

// Void ToAngleAxis(Single ByRef, UnityEngine.Vector3 ByRef)
static bool w_vtPr4Ps_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPr4Ps_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P primitive
    float up0 = converter::Converter<std::reference_wrapper<float>>::toCpp(context, info[0]);
    float* p0 = &up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal Pstruct
    s_r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,float* p0, struct s_r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty())
    {
        auto _unused = op0->Set(context, 0, converter::Converter<float>::toScript(context, *p0));
    }
    
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void Init(UnityEngine.Experimental.GlobalIllumination.SpotLightBoxShape ByRef)
static bool w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = nullptr; // valuetype ref
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(void*,struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void Init(UnityEngine.Experimental.GlobalIllumination.SpotLightBoxShape ByRef, UnityEngine.Experimental.GlobalIllumination.Cookie ByRef)
static bool w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = nullptr; // valuetype ref
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i4r4r4r4_* p1 = nullptr; // valuetype ref
    s_i4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0, struct s_i4r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void Init(UnityEngine.Experimental.GlobalIllumination.DirectionalLight ByRef)
static bool w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = nullptr; // valuetype ref
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(void*,struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void Init(UnityEngine.Experimental.GlobalIllumination.DirectionalLight ByRef, UnityEngine.Experimental.GlobalIllumination.Cookie ByRef)
static bool w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0 = nullptr; // valuetype ref
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i4r4r4r4_* p1 = nullptr; // valuetype ref
    s_i4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* p0, struct s_i4r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void Init(UnityEngine.Experimental.GlobalIllumination.SpotLight ByRef)
static bool w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_* p0 = nullptr; // valuetype ref
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(void*,struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void Init(UnityEngine.Experimental.GlobalIllumination.SpotLight ByRef, UnityEngine.Experimental.GlobalIllumination.Cookie ByRef)
static bool w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_Ps_i4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_Ps_i4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_* p0 = nullptr; // valuetype ref
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i4r4r4r4_* p1 = nullptr; // valuetype ref
    s_i4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_* p0, struct s_i4r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void Init(UnityEngine.Experimental.GlobalIllumination.RectangleLight ByRef)
static bool w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_* p0 = nullptr; // valuetype ref
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(void*,struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void Init(UnityEngine.Experimental.GlobalIllumination.RectangleLight ByRef, UnityEngine.Experimental.GlobalIllumination.Cookie ByRef)
static bool w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_Ps_i4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_Ps_i4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_* p0 = nullptr; // valuetype ref
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i4r4r4r4_* p1 = nullptr; // valuetype ref
    s_i4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_* p0, struct s_i4r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void Init(UnityEngine.Experimental.GlobalIllumination.PointLight ByRef)
static bool w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_* p0 = nullptr; // valuetype ref
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(void*,struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void Init(UnityEngine.Experimental.GlobalIllumination.PointLight ByRef, UnityEngine.Experimental.GlobalIllumination.Cookie ByRef)
static bool w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_Ps_i4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_Ps_i4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_* p0 = nullptr; // valuetype ref
    s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_i4r4r4r4_* p1 = nullptr; // valuetype ref
    s_i4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_i4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,struct s_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_* p0, struct s_i4r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void DrawShadows(UnityEngine.Rendering.ShadowDrawingSettings ByRef)
static bool w_vtPs_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_* p0 = nullptr; // valuetype ref
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(void*,struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void EnableKeyword(UnityEngine.Rendering.LocalKeyword ByRef)
static bool w_vtPs_psu4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_psu4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_psu4_* p0 = nullptr; // valuetype ref
    s_psu4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_psu4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(void*,struct s_psu4_* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void SetKeyword(UnityEngine.Rendering.LocalKeyword ByRef, Boolean)
static bool w_vtPs_psu4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_psu4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_psu4_* p0 = nullptr; // valuetype ref
    s_psu4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_psu4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_psu4_* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void GetPositionAndRotation(UnityEngine.Vector3 ByRef, UnityEngine.Quaternion ByRef)
static bool w_vtPs_r4r4r4_Ps_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_r4r4r4_Ps_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_r4r4r4_* p0 = nullptr; // valuetype ref
    s_r4r4r4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal Pstruct
    s_r4r4r4r4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_* p0, struct s_r4r4r4r4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
            
    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void SetCustomInput(UnityEngine.RaycastHit ByRef, Boolean)
static bool w_vtPs_r4r4r4r4r4r4u4r4r4r4i4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_r4r4r4r4r4r4u4r4r4r4i4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p0 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4u4r4r4r4i4_* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void SetCustomInput(UnityEngine.RaycastHit ByRef, Boolean, Boolean)
static bool w_vtPs_r4r4r4r4r4r4u4r4r4r4i4_bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_r4r4r4r4r4r4u4r4r4r4i4_bb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsObject()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4u4r4r4r4i4_* p0 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4u4r4r4r4i4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4u4r4r4r4i4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4u4r4r4r4i4_* p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void EnableKeyword(UnityEngine.Rendering.GlobalKeyword ByRef)
static bool w_vtPs_su4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_su4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_su4_* p0 = nullptr; // valuetype ref
    s_su4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_su4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        

    typedef void (*FuncToCall)(void*,struct s_su4_* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void SetKeyword(UnityEngine.Rendering.GlobalKeyword ByRef, Boolean)
static bool w_vtPs_su4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtPs_su4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsObject()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal Pstruct
    s_su4_* p0 = nullptr; // valuetype ref
    s_su4_ up0;
    v8::Local<v8::Object> op0;
    if (!info[0].IsEmpty() && info[0]->IsObject()) {
        op0 = info[0]->ToObject(context).ToLocalChecked();
        auto tp0 = op0->Get(context, 0).ToLocalChecked();
        p0 = DataTransfer::GetPointer<s_su4_>(context, tp0);
    }
    if (!p0) {
        p0 = &up0;
    }
        
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_su4_* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op0.IsEmpty() && p0 == &up0)
    {
        auto _unused = op0->Set(context, 0, CopyValueType(isolate, context, TIp0, p0, sizeof(*p0)));
    }
    
    return true;
}

// Void initialize(System.Object[])
static bool w_vtVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtVO");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal ref params
    void* p0 = RestArguments<void*>::PackRef(context, info, TIp0, 0);
                

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void ConcatValues(Single[])
static bool w_vtVr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtVr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
        if (!info[0]->IsNullOrUndefined() && !converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal primitive params
    void* p0 = RestArguments<float>::PackPrimitive(context, info, TIp0, 0);
                

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Keyframe[])
static bool w_vtVs_r4r4r4r4i4i4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtVs_r4r4r4r4i4i4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 0) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal valuetype params
    void* p0 = RestArguments<s_r4r4r4r4i4i4r4r4_>::PackValueType(context, info, TIp0, 0);
                

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_fairyBatching(Boolean)
static bool w_vtb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,bool p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void FireClick(Boolean, Boolean)
static bool w_vtbDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbDb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,bool p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Set2DGBLight(Boolean, System.String)
static bool w_vtbDs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbDs");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (length > 1 && !info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal string  with default
    void* p1 = OptionalParameter<void*>::GetString(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,bool p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Boolean, System.String, System.String, System.String)
static bool w_vtbDsDsDs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbDsDsDs");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (length > 1 && !info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (length > 2 && !info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (length > 3 && !info[3]->IsString() && !info[3]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal string  with default
    void* p1 = OptionalParameter<void*>::GetString(context, info, method, 1);
                
    // JSValToCSVal string  with default
    void* p2 = OptionalParameter<void*>::GetString(context, info, method, 2);
                
    // JSValToCSVal string  with default
    void* p3 = OptionalParameter<void*>::GetString(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,bool p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Stop(Boolean, Boolean)
static bool w_vtbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void ClearRenderTarget(Boolean, Boolean, UnityEngine.Color)
static bool w_vtbbs_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbbs_r4r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,bool p0, bool p1, struct s_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ClearRenderTarget(Boolean, Boolean, UnityEngine.Color, Single)
static bool w_vtbbs_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbbs_r4r4r4r4_r4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,bool p0, bool p1, struct s_r4r4r4r4_ p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Boolean, UnityEngine.ColorSpace)
static bool w_vtbi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,bool p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetAutoPlay(Boolean, Int32, Single)
static bool w_vtbi4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbi4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,bool p0, int32_t p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void CheckError(Boolean, System.String)
static bool w_vtbs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbs");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void*,bool p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Boolean, Byte, Byte, UnityEngine.Rendering.CompareFunction, UnityEngine.Rendering.StencilOp, UnityEngine.Rendering.StencilOp, UnityEngine.Rendering.StencilOp, UnityEngine.Rendering.CompareFunction, UnityEngine.Rendering.StencilOp, UnityEngine.Rendering.StencilOp, UnityEngine.Rendering.StencilOp)
static bool w_vtbu1u1i4i4i4i4i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtbu1u1i4i4i4i4i4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 11) return false;
        if (!converter::Converter<bool>::accept(context, info[0])) return false;
        if (!converter::Converter<uint8_t>::accept(context, info[1])) return false;
        if (!converter::Converter<uint8_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[9])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[10])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    bool p0 = converter::Converter<bool>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(context, info[9]);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(context, info[10]);

    typedef void (*FuncToCall)(void*,bool p0, uint8_t p1, uint8_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, int32_t p9, int32_t p10, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);

    
    return true;
}

// Void AddChar(Char, BMGlyph)
static bool w_vtco(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtco");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<Il2CppChar>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    Il2CppChar p0 = converter::Converter<Il2CppChar>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,Il2CppChar p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_lowerBound(Int16)
static bool w_vti2(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti2");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int16_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,int16_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Int16, Int16)
static bool w_vti2i2(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti2i2");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int16_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int16_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int16_t p0 = converter::Converter<int16_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int16_t p1 = converter::Converter<int16_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,int16_t p0, int16_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetChildrenLayer(Int32)
static bool w_vti4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,int32_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Int32, Int32)
static bool w_vti4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.BuiltinRenderTextureType, Int32, UnityEngine.CubemapFace, Int32)
static bool w_vti4Di4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Di4Di4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void PlayOrReSpeed(Client.ActionRefTriggerType, Int32, Single)
static bool w_vti4Di4Dr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Di4Dr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    float p2 = OptionalParameter<float>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void clearUnused(Int32, System.Collections.Generic.List`1[System.Int32])
static bool w_vti4Do(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Do");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal ref  with default
    void* p1 = OptionalParameter<void*>::GetRefType(context, info, method, 1, TIp1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void play(Int32, Single)
static bool w_vti4Dr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Dr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (length > 1 && !converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Log(UnityEngine.LogType, System.Object)
static bool w_vti4O(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4O");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Log(UnityEngine.LogType, System.Object, UnityEngine.Object)
static bool w_vti4Oo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Oo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Idx2CR(Int32, Int32 ByRef, Int32 ByRef, Int32, Int32)
static bool w_vti4Pi4Pi4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Pi4Pi4Di4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P primitive
    int32_t up1 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(context, info[1]);
    int32_t* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    int32_t up2 = converter::Converter<std::reference_wrapper<int32_t>>::toCpp(context, info[2]);
    int32_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t* p1, int32_t* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<int32_t>::toScript(context, *p1));
    }
    
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<int32_t>::toScript(context, *p2));
    }
    
    return true;
}

// Void GetKernelThreadGroupSizes(Int32, UInt32 ByRef, UInt32 ByRef, UInt32 ByRef)
static bool w_vti4Pu4Pu4Pu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Pu4Pu4Pu4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P primitive
    uint32_t up1 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(context, info[1]);
    uint32_t* p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    uint32_t up2 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(context, info[2]);
    uint32_t* p2 = &up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
    }
    // JSValToCSVal P primitive
    uint32_t up3 = converter::Converter<std::reference_wrapper<uint32_t>>::toCpp(context, info[3]);
    uint32_t* p3 = &up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
    }

    typedef void (*FuncToCall)(void*,int32_t p0, uint32_t* p1, uint32_t* p2, uint32_t* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, converter::Converter<uint32_t>::toScript(context, *p1));
    }
    
    if (!op2.IsEmpty())
    {
        auto _unused = op2->Set(context, 0, converter::Converter<uint32_t>::toScript(context, *p2));
    }
    
    if (!op3.IsEmpty())
    {
        auto _unused = op3->Set(context, 0, converter::Converter<uint32_t>::toScript(context, *p3));
    }
    
    return true;
}

// Void SetInts(Int32, Int32[])
static bool w_vti4Vi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Vi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && !converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal primitive params
    void* p1 = RestArguments<int32_t>::PackPrimitive(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetFloats(Int32, Single[])
static bool w_vti4Vr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Vr4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && !converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal primitive params
    void* p1 = RestArguments<float>::PackPrimitive(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetVertexBufferParams(Int32, UnityEngine.Rendering.VertexAttributeDescriptor[])
static bool w_vti4Vs_i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4Vs_i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal valuetype params
    void* p1 = RestArguments<s_i4i4i4i4_>::PackValueType(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void ShowHtmlObject(Int32, Boolean)
static bool w_vti4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,int32_t p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void StopSlots(Client.ActionRefTriggerType, Boolean, Int32)
static bool w_vti4bDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4bDi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, bool p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ScrollToView(Int32, Boolean, Boolean)
static bool w_vti4bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4bb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SwapChildrenAt(Int32, Int32)
static bool w_vti4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.BlendMode, UnityEngine.Rendering.BlendMode, Boolean)
static bool w_vti4i4Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4Db");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, UnityEngine.MeshTopology)
static bool w_vti4i4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetSkin(Int32, Int32, System.String)
static bool w_vti4i4Ds(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4Ds");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal string  with default
    void* p2 = OptionalParameter<void*>::GetString(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void RemoveChildren(Int32, Int32, Boolean)
static bool w_vti4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void AddTriangle(Int32, Int32, Int32)
static bool w_vti4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, UnityEngine.TextureFormat, Boolean)
static bool w_vti4i4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, UnityEngine.TextureFormat, Boolean, Boolean)
static bool w_vti4i4i4bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4bb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetPlaySettings(Int32, Int32, Int32, Int32)
static bool w_vti4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, UnityEngine.TextureFormat, Int32, Boolean)
static bool w_vti4i4i4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, UnityEngine.TextureFormat, Boolean, Boolean)
static bool w_vti4i4i4i4bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4bb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!converter::Converter<bool>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, bool p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, UnityEngine.TextureFormat, Boolean, IntPtr)
static bool w_vti4i4i4i4bp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4bp");
    
    auto TIp5 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!info[5]->IsArrayBuffer()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal P any
    void* p5 = DataTransfer::GetPointer<void>(context, info[5]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, bool p4, void* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode)
static bool w_vti4i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, UnityEngine.TextureFormat, Int32, Boolean)
static bool w_vti4i4i4i4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<bool>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, bool p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat)
static bool w_vti4i4i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32)
static bool w_vti4i4i4i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, Boolean)
static bool w_vti4i4i4i4i4i4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4i4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, bool p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, Boolean, UnityEngine.RenderTextureMemoryless)
static bool w_vti4i4i4i4i4i4i4bi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4i4bi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, bool p7, int32_t p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, Boolean, UnityEngine.RenderTextureMemoryless, Boolean)
static bool w_vti4i4i4i4i4i4i4bi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4i4bi4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 10) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (!converter::Converter<bool>::accept(context, info[9])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(context, info[9]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, bool p7, int32_t p8, bool p9, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32)
static bool w_vti4i4i4i4i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, Boolean)
static bool w_vti4i4i4i4i4i4i4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4i4i4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, bool p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void GetTemporaryRTArray(Int32, Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.Experimental.Rendering.GraphicsFormat, Int32, Boolean, Boolean)
static bool w_vti4i4i4i4i4i4i4i4bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4i4i4bb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 10) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
        if (!converter::Converter<bool>::accept(context, info[9])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(context, info[9]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, bool p8, bool p9, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, Boolean, UnityEngine.RenderTextureMemoryless)
static bool w_vti4i4i4i4i4i4i4i4bi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4i4i4bi4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 10) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[9])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(context, info[9]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, bool p8, int32_t p9, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, Boolean, UnityEngine.RenderTextureMemoryless, Boolean)
static bool w_vti4i4i4i4i4i4i4i4bi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4i4i4bi4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 11) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[9])) return false;
        if (!converter::Converter<bool>::accept(context, info[10])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(context, info[9]);
    // JSValToCSVal P any
    bool p10 = converter::Converter<bool>::toCpp(context, info[10]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, bool p8, int32_t p9, bool p10, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10,  method);

    
    return true;
}

// Void GetTemporaryRTArray(Int32, Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32)
static bool w_vti4i4i4i4i4i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void GetTemporaryRTArray(Int32, Int32, Int32, Int32, Int32, UnityEngine.FilterMode, UnityEngine.RenderTextureFormat, UnityEngine.RenderTextureReadWrite, Int32, Boolean)
static bool w_vti4i4i4i4i4i4i4i4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4i4i4i4i4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 10) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (!converter::Converter<bool>::accept(context, info[9])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);
    // JSValToCSVal P any
    bool p9 = converter::Converter<bool>::toCpp(context, info[9]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, bool p9, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, UnityEngine.TextureFormat, Int32, IntPtr)
static bool w_vti4i4i4i4i4p(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4i4p");
    
    auto TIp5 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsArrayBuffer()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    void* p5 = DataTransfer::GetPointer<void>(context, info[5]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, void* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void SetPixels(Int32, Int32, Int32, Int32, UnityEngine.Color[])
static bool w_vti4i4i4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4o");
    
    auto TIp4 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetPixels(Int32, Int32, Int32, Int32, UnityEngine.Color[], Int32)
static bool w_vti4i4i4i4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i4oi4");
    
    auto TIp4 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int32_t p3, void* p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(Int32, Int32, Int32, Int64)
static bool w_vti4i4i4i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, int64_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void UpdateTile(Int32, Int32, Int32, UnityEngine.Color32[])
static bool w_vti4i4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4o");
    
    auto TIp3 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void BeginRenderPass(Int32, Int32, Int32, Unity.Collections.NativeArray`1[UnityEngine.Rendering.AttachmentDescriptor], Int32)
static bool w_vti4i4i4s_Pvi4i4i4pi4i4oi4_Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4s_Pvi4i4i4pi4i4oi4_Di4");
    
    auto TIp3 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp3 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[3]);
    s_Pvi4i4i4pi4i4oi4_ p3 = pp3 ? *pp3 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, struct s_Pvi4i4i4pi4i4oi4_ p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetPixel(UnityEngine.CubemapFace, Int32, Int32, UnityEngine.Color)
static bool w_vti4i4i4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4s_r4r4r4r4_");
    
    auto TIp3 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, struct s_r4r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetPixel(UnityEngine.CubemapFace, Int32, Int32, UnityEngine.Color, Int32)
static bool w_vti4i4i4s_r4r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4i4s_r4r4r4r4_i4");
    
    auto TIp3 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, int32_t p2, struct s_r4r4r4r4_ p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetBuffer(Int32, Int32, UnityEngine.ComputeBuffer)
static bool w_vti4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4o");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetTexture(Int32, Int32, UnityEngine.Texture, Int32)
static bool w_vti4i4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4oi4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetTexture(Int32, Int32, UnityEngine.RenderTexture, Int32, UnityEngine.Rendering.RenderTextureSubElement)
static bool w_vti4i4oi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4oi4i4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, void* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void GetBlendShapeFrameVertices(Int32, Int32, UnityEngine.Vector3[], UnityEngine.Vector3[], UnityEngine.Vector3[])
static bool w_vti4i4ooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4ooo");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, void* p2, void* p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void set_Item(Int32, Int32, Single)
static bool w_vti4i4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetLimited(Int32, Int32, GCore.FVector3)
static bool w_vti4i4s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4s_i8i8i8_");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, struct s_i8i8i8_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetPixel(Int32, Int32, UnityEngine.Color)
static bool w_vti4i4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4s_r4r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, struct s_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetPixel(Int32, Int32, UnityEngine.Color, Int32)
static bool w_vti4i4s_r4r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4i4s_r4r4r4r4_i4");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, int32_t p1, struct s_r4r4r4r4_ p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void AddTouchMonitor(Int32, FairyGUI.EventDispatcher)
static bool w_vti4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetRandomWriteTarget(Int32, UnityEngine.ComputeBuffer, Boolean)
static bool w_vti4ob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4ob");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void UpdateInstanceTransform(Int32, Client.InstTrans, Boolean, Boolean)
static bool w_vti4obb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4obb");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void AddCommandBufferAsync(UnityEngine.Rendering.CameraEvent, UnityEngine.Rendering.CommandBuffer, UnityEngine.Rendering.ComputeQueueType)
static bool w_vti4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4oi4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetUVs(Int32, System.Collections.Generic.List`1[UnityEngine.Vector2], Int32, Int32)
static bool w_vti4oi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4oi4i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetUVs(Int32, System.Collections.Generic.List`1[UnityEngine.Vector2], Int32, Int32, UnityEngine.Rendering.MeshUpdateFlags)
static bool w_vti4oi4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4oi4i4i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void LogFormat(UnityEngine.LogType, UnityEngine.Object, System.String, System.Object[])
static bool w_vti4osVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4osVO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal ref params
    void* p3 = RestArguments<void*>::PackRef(context, info, TIp3, 3);
                

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void DispatchIndirect(Int32, UnityEngine.ComputeBuffer, UInt32)
static bool w_vti4ou4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4ou4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void set_Item(Int32, Single)
static bool w_vti4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetArea(Int32, Single, Int32, Single)
static bool w_vti4r4i4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4i4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, int32_t p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void GetLinesShape(Int32, Single, Int32, Single, Boolean, System.Collections.Generic.List`1[UnityEngine.Rect])
static bool w_vti4r4i4r4bo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4i4r4bo");
    
    auto TIp5 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, int32_t p2, float p3, bool p4, void* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void Play(Int32, Single, FairyGUI.PlayCompleteCallback)
static bool w_vti4r4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4o");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetInsetAndSizeFromParentEdge(Edge, Single, Single)
static bool w_vti4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void GetPointsInSegment(Int32, Single, Single, System.Collections.Generic.List`1[UnityEngine.Vector3], System.Collections.Generic.List`1[System.Single], Single)
static bool w_vti4r4r4oDoDr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4r4oDoDr4");
    
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (length > 4 && !info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (length > 5 && !converter::Converter<float>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal ref  with default
    void* p4 = OptionalParameter<void*>::GetRefType(context, info, method, 4, TIp4);
                
    // JSValToCSVal primitive with default
    float p5 = OptionalParameter<float>::GetPrimitive(context, info, method, 5);
                

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, float p2, void* p3, void* p4, float p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void Play(Int32, Single, Single, Single, FairyGUI.PlayCompleteCallback)
static bool w_vti4r4r4r4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4r4r4o");
    
    auto TIp4 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, float p2, float p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void updateParas(Int32, Single, Single, System.String, System.String, System.String, System.String)
static bool w_vti4r4r4ssss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4r4ssss");
    
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!info[3]->IsString() && !info[3]->IsNullOrUndefined()) return false;
        if (!info[4]->IsString() && !info[4]->IsNullOrUndefined()) return false;
        if (!info[5]->IsString() && !info[5]->IsNullOrUndefined()) return false;
        if (!info[6]->IsString() && !info[6]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal s
    v8::String::Utf8Value tp3(isolate, info[3]);
    void* p3 = CStringToCSharpString(*tp3);
    // JSValToCSVal s
    v8::String::Utf8Value tp4(isolate, info[4]);
    void* p4 = CStringToCSharpString(*tp4);
    // JSValToCSVal s
    v8::String::Utf8Value tp5(isolate, info[5]);
    void* p5 = CStringToCSharpString(*tp5);
    // JSValToCSVal s
    v8::String::Utf8Value tp6(isolate, info[6]);
    void* p6 = CStringToCSharpString(*tp6);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, float p2, void* p3, void* p4, void* p5, void* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void DrawRegularPolygon(Int32, Single, UnityEngine.Color, UnityEngine.Color, UnityEngine.Color, Single, Single[])
static bool w_vti4r4s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4r4s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4o");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if ((!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp4 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[4]);
    s_r4r4r4r4_ p4 = pp4 ? *pp4 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);

    typedef void (*FuncToCall)(void*,int32_t p0, float p1, struct s_r4r4r4r4_ p2, struct s_r4r4r4r4_ p3, struct s_r4r4r4r4_ p4, float p5, void* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void set_Item(Int32, System.String)
static bool w_vti4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Log(UnityEngine.LogType, System.String, System.Object)
static bool w_vti4sO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4sO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Log(UnityEngine.LogType, System.String, System.Object, UnityEngine.Object)
static bool w_vti4sOo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4sOo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void LogFormat(UnityEngine.LogType, System.String, System.Object[])
static bool w_vti4sVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4sVO");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal ref params
    void* p2 = RestArguments<void*>::PackRef(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetVertexBufferParams(Int32, Unity.Collections.NativeArray`1[UnityEngine.Rendering.VertexAttributeDescriptor])
static bool w_vti4s_Pvi4i4i4pi4i4oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_Pvi4i4i4pi4i4oi4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp1 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[1]);
    s_Pvi4i4i4pi4i4oi4_ p1 = pp1 ? *pp1 : s_Pvi4i4i4pi4i4oi4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_Pvi4i4i4pi4i4oi4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetBatchPropertyMetadata(Int32, Unity.Collections.NativeArray`1[System.Int32], Unity.Collections.NativeArray`1[System.Int32])
static bool w_vti4s_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp1 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[1]);
    s_Pvi4i4i4pi4i4oi4_ p1 = pp1 ? *pp1 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp2 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[2]);
    s_Pvi4i4i4pi4i4oi4_ p2 = pp2 ? *pp2 : s_Pvi4i4i4pi4i4oi4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_Pvi4i4i4pi4i4oi4_ p1, struct s_Pvi4i4i4pi4i4oi4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void EnterPaintingMode(Int32, System.Nullable`1[FairyGUI.Margin])
static bool w_vti4s_bi4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_bi4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_bi4i4i4i4_* pp1 = DataTransfer::GetPointer<s_bi4i4i4i4_>(context, info[1]);
    s_bi4i4i4i4_ p1 = pp1 ? *pp1 : s_bi4i4i4i4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_bi4i4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void EnterPaintingMode(Int32, System.Nullable`1[FairyGUI.Margin], Single)
static bool w_vti4s_bi4i4i4i4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_bi4i4i4i4_r4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_bi4i4i4i4_* pp1 = DataTransfer::GetPointer<s_bi4i4i4i4_>(context, info[1]);
    s_bi4i4i4i4_ p1 = pp1 ? *pp1 : s_bi4i4i4i4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_bi4i4i4i4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetShaderPassName(Int32, UnityEngine.Rendering.ShaderTagId)
static bool w_vti4s_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i4_* pp1 = DataTransfer::GetPointer<s_i4_>(context, info[1]);
    s_i4_ p1 = pp1 ? *pp1 : s_i4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, UnityEngine.RenderTextureDescriptor)
static bool w_vti4s_i4i4i4i4i4i4i4i4i4i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(context, info[1]);
    s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void GetTemporaryRT(Int32, UnityEngine.RenderTextureDescriptor, UnityEngine.FilterMode)
static bool w_vti4s_i4i4i4i4i4i4i4i4i4i4i4i4i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_i4i4i4i4i4i4i4i4i4i4i4i4i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(context, info[1]);
    s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetRandomWriteTarget(Int32, UnityEngine.Rendering.RenderTargetIdentifier)
static bool w_vti4s_i4i4i4pi4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_i4i4i4pi4i4i4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_i4i4i4pi4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.RenderTextureFormat, UnityEngine.Rendering.RenderTargetIdentifier, Boolean, Boolean, Boolean)
static bool w_vti4s_i4i4i4pi4i4i4_DbDbDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_i4i4i4pi4i4i4_DbDbDb");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<bool>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<bool>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(context, info, method, 4);
                

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_i4i4i4pi4i4i4_ p1, bool p2, bool p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetGlobalTexture(Int32, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTextureSubElement)
static bool w_vti4s_i4i4i4pi4i4i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_i4i4i4pi4i4i4_i4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_i4i4i4pi4i4i4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetTextureOffset(Int32, UnityEngine.Vector2)
static bool w_vti4s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetPosition(Int32, UnityEngine.Vector3)
static bool w_vti4s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetVector(Int32, UnityEngine.Vector4)
static bool w_vti4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void ClearRenderTarget(UnityEngine.Rendering.RTClearFlags, UnityEngine.Color, Single, UInt32)
static bool w_vti4s_r4r4r4r4_r4u4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_r4r4r4r4_r4u4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_r4r4r4r4_ p1, float p2, uint32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetBatchBounds(Int32, UnityEngine.Bounds)
static bool w_vti4s_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetSubMesh(Int32, UnityEngine.Rendering.SubMeshDescriptor, UnityEngine.Rendering.MeshUpdateFlags)
static bool w_vti4s_r4r4r4r4r4r4i4i4i4i4i4i4_Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_r4r4r4r4r4r4i4i4i4i4i4i4_Di4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4i4i4i4i4i4i4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4i4i4i4i4i4i4_>(context, info[1]);
    s_r4r4r4r4r4r4i4i4i4i4i4i4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4i4i4i4i4i4i4_ {};
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_r4r4r4r4r4r4i4i4i4i4i4i4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetStereoProjectionMatrix(StereoscopicEye, UnityEngine.Matrix4x4)
static bool w_vti4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,int32_t p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetTexture(Int32, System.String, UnityEngine.Texture)
static bool w_vti4so(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4so");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetTexture(Int32, System.String, UnityEngine.Texture, Int32)
static bool w_vti4soi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4soi4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetTexture(Int32, System.String, UnityEngine.RenderTexture, Int32, UnityEngine.Rendering.RenderTextureSubElement)
static bool w_vti4soi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4soi4i4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, void* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void addPool(Int32, System.String, UnityEngine.GameObject, System.Type)
static bool w_vti4soo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4soo");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetTextureFromGlobal(Int32, System.String, System.String)
static bool w_vti4ss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4ss");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(void*,int32_t p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void set_Item(Int32, Byte)
static bool w_vti4u1(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4u1");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint8_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,int32_t p0, uint8_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetBatchFlags(Int32, UInt64)
static bool w_vti4u8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti4u8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint64_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int32_t p0 = converter::Converter<int32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,int32_t p0, uint64_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void checkRecords(Int64)
static bool w_vti8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,int64_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Init(Int64, Int64, Int32, Int32, Int32)
static bool w_vti8i8Di4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti8i8Di4Di4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef void (*FuncToCall)(void*,int64_t p0, int64_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetAgentVelocity(Int64, Int64, Int64)
static bool w_vti8i8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti8i8i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,int64_t p0, int64_t p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void CollectSortDist(Int64, Int64, Int64, Int32)
static bool w_vti8i8i8i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti8i8i8i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,int64_t p0, int64_t p1, int64_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void deleteRecords(Int64, System.String)
static bool w_vti8s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vti8s");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<int64_t>::accept(context, info[0])) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    int64_t p0 = converter::Converter<int64_t>::toCpp(context, info[0]);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void*,int64_t p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void add_onUpdate(System.Action)
static bool w_vto(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vto");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetFocus(FairyGUI.DisplayObject, Boolean)
static bool w_vtoDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddTriangles(Int32[], Int32)
static bool w_vtoDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(Byte[], Int32, Int32)
static bool w_vtoDi4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoDi4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Texture, Int32, UnityEngine.CubemapFace, Int32)
static bool w_vtoDi4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoDi4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void ResolveAntiAliasedSurface(UnityEngine.RenderTexture, UnityEngine.RenderTexture)
static bool w_vtoDo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoDo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal ref  with default
    void* p1 = OptionalParameter<void*>::GetRefType(context, info, method, 1, TIp1);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddInstance(UnityEngine.Renderer, Boolean[], Boolean[], Boolean, Boolean, UInt32, UInt32)
static bool w_vtoDoDoDbDbDu4Du4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoDoDoDbDbDu4Du4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (length > 2 && !info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (length > 3 && !converter::Converter<bool>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<bool>::accept(context, info[4])) return false;
        if (length > 5 && !converter::Converter<uint32_t>::accept(context, info[5])) return false;
        if (length > 6 && !converter::Converter<uint32_t>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal ref  with default
    void* p1 = OptionalParameter<void*>::GetRefType(context, info, method, 1, TIp1);
                
    // JSValToCSVal ref  with default
    void* p2 = OptionalParameter<void*>::GetRefType(context, info, method, 2, TIp2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(context, info, method, 4);
                
    // JSValToCSVal primitive with default
    uint32_t p5 = OptionalParameter<uint32_t>::GetPrimitive(context, info, method, 5);
                
    // JSValToCSVal primitive with default
    uint32_t p6 = OptionalParameter<uint32_t>::GetPrimitive(context, info, method, 6);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, bool p3, bool p4, uint32_t p5, uint32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void GetAllPoints(System.Collections.Generic.List`1[UnityEngine.Vector3], Single)
static bool w_vtoDr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoDr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (length > 1 && !converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void CallLater(FairyGUI.TimerCallback, System.Object)
static bool w_vtoO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetItemAsset(FairyGUI.PackageItem, System.Object, FairyGUI.DestroyMethod)
static bool w_vtoOi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoOi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void EnableKeyword(UnityEngine.Material, UnityEngine.Rendering.LocalKeyword ByRef)
static bool w_vtoPs_psu4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoPs_psu4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Pstruct
    s_psu4_* p1 = nullptr; // valuetype ref
    s_psu4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_psu4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        

    typedef void (*FuncToCall)(void*,void* p0, struct s_psu4_* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void SetKeyword(UnityEngine.Material, UnityEngine.Rendering.LocalKeyword ByRef, Boolean)
static bool w_vtoPs_psu4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoPs_psu4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsObject()) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal Pstruct
    s_psu4_* p1 = nullptr; // valuetype ref
    s_psu4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_psu4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, struct s_psu4_* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
    
    return true;
}

// Void SetWrapTarget(UnityEngine.GameObject, Boolean)
static bool w_vtob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtob");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetParent(UnityEngine.GameObject, Boolean, Boolean, Boolean)
static bool w_vtobDbDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtobDbDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,void* p0, bool p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void ScrollToView(FairyGUI.GObject, Boolean, Boolean)
static bool w_vtobb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtobb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void CombineMeshes(UnityEngine.CombineInstance[], Boolean, Boolean, Boolean)
static bool w_vtobbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtobbb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetupCameraProperties(UnityEngine.Camera, Boolean, Int32)
static bool w_vtobi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtobi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetWrapTarget(UnityEngine.GameObject, Boolean, Int32, Int32)
static bool w_vtobi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtobi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetChildIndex(FairyGUI.DisplayObject, Int32)
static bool w_vtoi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void GetTriangles(System.Collections.Generic.List`1[System.UInt16], Int32, Boolean)
static bool w_vtoi4Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4Db");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetTriangles(UInt16[], Int32, Boolean, Int32)
static bool w_vtoi4DbDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4DbDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, bool p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetComputeIntParams(UnityEngine.ComputeShader, Int32, Int32[])
static bool w_vtoi4Vi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4Vi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive params
    void* p2 = RestArguments<int32_t>::PackPrimitive(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetComputeFloatParams(UnityEngine.ComputeShader, Int32, Single[])
static bool w_vtoi4Vr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4Vr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && !converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive params
    void* p2 = RestArguments<float>::PackPrimitive(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Shader, UnityEngine.Rendering.PassType, System.String[])
static bool w_vtoi4Vs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4Vs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && !info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal string params
    void* p2 = RestArguments<void*>::PackString(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetRayTracingVectorArrayParam(UnityEngine.Experimental.Rendering.RayTracingShader, Int32, UnityEngine.Vector4[])
static bool w_vtoi4Vs_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4Vs_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal valuetype params
    void* p2 = RestArguments<s_r4r4r4r4_>::PackValueType(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetRayTracingMatrixArrayParam(UnityEngine.Experimental.Rendering.RayTracingShader, Int32, UnityEngine.Matrix4x4[])
static bool w_vtoi4Vs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4Vs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal valuetype params
    void* p2 = RestArguments<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>::PackValueType(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void AddRelation(FairyGUI.GObject, FairyGUI.RelationType, Boolean)
static bool w_vtoi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetTriangles(Int32[], Int32, Boolean, Int32)
static bool w_vtoi4bi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4bi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, bool p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void RepeatColors(UnityEngine.Color32[], Int32, Int32)
static bool w_vtoi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetIndices(UInt16[], UnityEngine.MeshTopology, Int32, Boolean, Int32)
static bool w_vtoi4i4DbDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4DbDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<bool>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, bool p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetSubMeshes(UnityEngine.Rendering.SubMeshDescriptor[], Int32, Int32, UnityEngine.Rendering.MeshUpdateFlags)
static bool w_vtoi4i4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetIndices(Int32[], UnityEngine.MeshTopology, Int32, Boolean)
static bool w_vtoi4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetIndices(Int32[], UnityEngine.MeshTopology, Int32, Boolean, Int32)
static bool w_vtoi4i4bi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4bi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, bool p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetVertices(System.Collections.Generic.List`1[UnityEngine.Vector3], Int32, Int32, UnityEngine.Rendering.MeshUpdateFlags)
static bool w_vtoi4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetTriangles(Int32[], Int32, Int32, Int32, Boolean, Int32)
static bool w_vtoi4i4i4DbDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4i4DbDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<bool>::accept(context, info[4])) return false;
        if (length > 5 && !converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(context, info, method, 4);
                
    // JSValToCSVal primitive with default
    int32_t p5 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 5);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, int32_t p3, bool p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void DispatchCompute(UnityEngine.ComputeShader, Int32, Int32, Int32, Int32)
static bool w_vtoi4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetIndices(Int32[], Int32, Int32, UnityEngine.MeshTopology, Int32, Boolean, Int32)
static bool w_vtoi4i4i4i4DbDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4i4i4DbDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (length > 5 && !converter::Converter<bool>::accept(context, info[5])) return false;
        if (length > 6 && !converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal primitive with default
    bool p5 = OptionalParameter<bool>::GetPrimitive(context, info, method, 5);
                
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 6);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, bool p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void RequestAsyncReadback(UnityEngine.Texture, Int32, Int32, Int32, Int32, Int32, Int32, Int32, UnityEngine.TextureFormat, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest])
static bool w_vtoi4i4i4i4i4i4i4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4i4i4i4i4i4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp9 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 10) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (!info[9]->IsNullOrUndefined() && (!info[9]->IsObject() || (info[9]->IsFunction() ? !IsDelegate(TIp9) : !IsAssignableFrom(TIp9, GetTypeId(info[9].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);
    // JSValToCSVal o/O
    void* p9 = JsValueToCSRef(context, info[9], TIp9);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, int32_t p8, void* p9, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void RequestAsyncReadback(UnityEngine.Texture, Int32, Int32, Int32, Int32, Int32, Int32, Int32, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest])
static bool w_vtoi4i4i4i4i4i4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4i4i4i4i4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp8 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!info[8]->IsNullOrUndefined() && (!info[8]->IsObject() || (info[8]->IsFunction() ? !IsDelegate(TIp8) : !IsAssignableFrom(TIp8, GetTypeId(info[8].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal o/O
    void* p8 = JsValueToCSRef(context, info[8], TIp8);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, void* p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void RequestAsyncReadback(UnityEngine.ComputeBuffer, Int32, Int32, System.Action`1[UnityEngine.Rendering.AsyncGPUReadbackRequest])
static bool w_vtoi4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(FairyGUI.PixelHitTestData, Int32, Int32, Single, Single)
static bool w_vtoi4i4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4r4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, float p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetComputeTextureParam(UnityEngine.ComputeShader, Int32, Int32, UnityEngine.Rendering.RenderTargetIdentifier)
static bool w_vtoi4i4s_i4i4i4pi4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4s_i4i4i4pi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp3 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[3]);
    s_i4i4i4pi4i4i4_ p3 = pp3 ? *pp3 : s_i4i4i4pi4i4i4_ {};

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, struct s_i4i4i4pi4i4i4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetComputeTextureParam(UnityEngine.ComputeShader, Int32, Int32, UnityEngine.Rendering.RenderTargetIdentifier, Int32)
static bool w_vtoi4i4s_i4i4i4pi4i4i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4s_i4i4i4pi4i4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp3 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[3]);
    s_i4i4i4pi4i4i4_ p3 = pp3 ? *pp3 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, struct s_i4i4i4pi4i4i4_ p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetComputeTextureParam(UnityEngine.ComputeShader, Int32, Int32, UnityEngine.Rendering.RenderTargetIdentifier, Int32, UnityEngine.Rendering.RenderTextureSubElement)
static bool w_vtoi4i4s_i4i4i4pi4i4i4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4i4s_i4i4i4pi4i4i4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp3 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[3]);
    s_i4i4i4pi4i4i4_ p3 = pp3 ? *pp3 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, struct s_i4i4i4pi4i4i4_ p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void Show(FairyGUI.GObject, FairyGUI.PopupDirection, FairyGUI.PopupMenu)
static bool w_vtoi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetComputeConstantBufferParam(UnityEngine.ComputeShader, Int32, UnityEngine.ComputeBuffer, Int32, Int32)
static bool w_vtoi4oi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4oi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawMeshInstancedProcedural(UnityEngine.Mesh, Int32, UnityEngine.Material, Int32, Int32, UnityEngine.MaterialPropertyBlock)
static bool w_vtoi4oi4i4Do(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4oi4i4Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (length > 5 && !info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal ref  with default
    void* p5 = OptionalParameter<void*>::GetRefType(context, info, method, 5, TIp5);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, int32_t p3, int32_t p4, void* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, Int32, UnityEngine.Matrix4x4[])
static bool w_vtoi4oi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4oi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, int32_t p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, Int32, UnityEngine.Matrix4x4[], Int32)
static bool w_vtoi4oi4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4oi4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, int32_t p3, void* p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void DrawMeshInstanced(UnityEngine.Mesh, Int32, UnityEngine.Material, Int32, UnityEngine.Matrix4x4[], Int32, UnityEngine.MaterialPropertyBlock)
static bool w_vtoi4oi4oi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4oi4oi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, int32_t p3, void* p4, int32_t p5, void* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void DispatchCompute(UnityEngine.ComputeShader, Int32, UnityEngine.ComputeBuffer, UInt32)
static bool w_vtoi4ou4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4ou4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, uint32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetComputeFloatParam(UnityEngine.ComputeShader, Int32, Single)
static bool w_vtoi4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetRayTracingTextureParam(UnityEngine.Experimental.Rendering.RayTracingShader, Int32, UnityEngine.Rendering.RenderTargetIdentifier)
static bool w_vtoi4s_i4i4i4pi4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4s_i4i4i4pi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp2 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[2]);
    s_i4i4i4pi4i4i4_ p2 = pp2 ? *pp2 : s_i4i4i4pi4i4i4_ {};

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, struct s_i4i4i4pi4i4i4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetComputeVectorParam(UnityEngine.ComputeShader, Int32, UnityEngine.Vector4)
static bool w_vtoi4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, struct s_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetComputeMatrixParam(UnityEngine.ComputeShader, Int32, UnityEngine.Matrix4x4)
static bool w_vtoi4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetComputeBufferParam(UnityEngine.ComputeShader, Int32, System.String, UnityEngine.ComputeBuffer)
static bool w_vtoi4so(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4so");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetComputeTextureParam(UnityEngine.ComputeShader, Int32, System.String, UnityEngine.Rendering.RenderTargetIdentifier)
static bool w_vtoi4ss_i4i4i4pi4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4ss_i4i4i4pi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp3 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[3]);
    s_i4i4i4pi4i4i4_ p3 = pp3 ? *pp3 : s_i4i4i4pi4i4i4_ {};

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, struct s_i4i4i4pi4i4i4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetComputeTextureParam(UnityEngine.ComputeShader, Int32, System.String, UnityEngine.Rendering.RenderTargetIdentifier, Int32)
static bool w_vtoi4ss_i4i4i4pi4i4i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4ss_i4i4i4pi4i4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp3 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[3]);
    s_i4i4i4pi4i4i4_ p3 = pp3 ? *pp3 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, struct s_i4i4i4pi4i4i4_ p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetComputeTextureParam(UnityEngine.ComputeShader, Int32, System.String, UnityEngine.Rendering.RenderTargetIdentifier, Int32, UnityEngine.Rendering.RenderTextureSubElement)
static bool w_vtoi4ss_i4i4i4pi4i4i4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoi4ss_i4i4i4pi4i4i4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp3 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[3]);
    s_i4i4i4pi4i4i4_ p3 = pp3 ? *pp3 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, struct s_i4i4i4pi4i4i4_ p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void SwapChildren(FairyGUI.DisplayObject, FairyGUI.DisplayObject)
static bool w_vtoo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void BakeMesh(UnityEngine.Mesh, UnityEngine.Camera, Boolean)
static bool w_vtooDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtooDb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void AddInstance(UnityEngine.Renderer, UnityEngine.Experimental.Rendering.RayTracingSubMeshFlags[], Boolean, Boolean, UInt32, UInt32)
static bool w_vtooDbDbDu4Du4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtooDbDbDu4Du4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<bool>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<uint32_t>::accept(context, info[4])) return false;
        if (length > 5 && !converter::Converter<uint32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    bool p3 = OptionalParameter<bool>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    uint32_t p4 = OptionalParameter<uint32_t>::GetPrimitive(context, info, method, 4);
                
    // JSValToCSVal primitive with default
    uint32_t p5 = OptionalParameter<uint32_t>::GetPrimitive(context, info, method, 5);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, bool p2, bool p3, uint32_t p4, uint32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void ShowPopup(FairyGUI.GObject, FairyGUI.GObject, FairyGUI.PopupDirection)
static bool w_vtooi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtooi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ShowPopup(FairyGUI.GObject, FairyGUI.GObject, FairyGUI.PopupDirection, Boolean)
static bool w_vtooi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtooi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawRenderer(UnityEngine.Renderer, UnityEngine.Material, Int32, Int32)
static bool w_vtooi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtooi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetBufferData(UnityEngine.ComputeBuffer, System.Array, Int32, Int32, Int32)
static bool w_vtooi4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtooi4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(System.Type, System.Type, System.Type)
static bool w_vtooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.RenderTargetIdentifier[], UnityEngine.Rendering.RenderBufferLoadAction[], UnityEngine.Rendering.RenderBufferStoreAction[], UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderBufferLoadAction, UnityEngine.Rendering.RenderBufferStoreAction)
static bool w_vtooos_i4i4i4pi4i4i4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtooos_i4i4i4pi4i4i4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp3 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[3]);
    s_i4i4i4pi4i4i4_ p3 = pp3 ? *pp3 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, struct s_i4i4i4pi4i4i4_ p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void Lerp(UnityEngine.Material, UnityEngine.Material, Single)
static bool w_vtoor4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoor4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Texture, UnityEngine.Texture, Single, Single)
static bool w_vtoor4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoor4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void CopyCounterValue(UnityEngine.ComputeBuffer, UnityEngine.ComputeBuffer, UInt32)
static bool w_vtoou4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoou4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void PlayOneShotSound(UnityEngine.AudioClip, Single)
static bool w_vtor4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtor4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Update(FairyGUI.UpdateContext, Single, Boolean)
static bool w_vtor4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtor4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, float p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetGORawTex(UnityEngine.GameObject, System.String)
static bool w_vtos(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void StartDrag(FairyGUI.GObject, System.String, System.Object, Int32)
static bool w_vtosODi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtosODi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetComputeIntParams(UnityEngine.ComputeShader, System.String, Int32[])
static bool w_vtosVi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtosVi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal primitive params
    void* p2 = RestArguments<int32_t>::PackPrimitive(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetComputeFloatParams(UnityEngine.ComputeShader, System.String, Single[])
static bool w_vtosVr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtosVr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && !converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal primitive params
    void* p2 = RestArguments<float>::PackPrimitive(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetRayTracingVectorArrayParam(UnityEngine.Experimental.Rendering.RayTracingShader, System.String, UnityEngine.Vector4[])
static bool w_vtosVs_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtosVs_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal valuetype params
    void* p2 = RestArguments<s_r4r4r4r4_>::PackValueType(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetRayTracingMatrixArrayParam(UnityEngine.Experimental.Rendering.RayTracingShader, System.String, UnityEngine.Matrix4x4[])
static bool w_vtosVs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtosVs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal valuetype params
    void* p2 = RestArguments<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>::PackValueType(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void GetObjectData(System.Runtime.Serialization.SerializationInfo, System.Runtime.Serialization.StreamingContext)
static bool w_vtos_Oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_Oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_Oi4_* pp1 = DataTransfer::GetPointer<s_Oi4_>(context, info[1]);
    s_Oi4_ p1 = pp1 ? *pp1 : s_Oi4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_Oi4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier[], UnityEngine.Rendering.RenderTargetIdentifier)
static bool w_vtos_i4i4i4pi4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_i4i4i4pi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_i4i4i4pi4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier[], UnityEngine.Rendering.RenderTargetIdentifier, Int32, UnityEngine.CubemapFace, Int32)
static bool w_vtos_i4i4i4pi4i4i4_i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_i4i4i4pi4i4i4_i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,void* p0, struct s_i4i4i4pi4i4i4_ p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Blit(UnityEngine.Texture, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Material)
static bool w_vtos_i4i4i4pi4i4i4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_i4i4i4pi4i4i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,void* p0, struct s_i4i4i4pi4i4i4_ p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Blit(UnityEngine.Texture, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Material, Int32)
static bool w_vtos_i4i4i4pi4i4i4_oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_i4i4i4pi4i4i4_oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, struct s_i4i4i4pi4i4i4_ p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Blit(UnityEngine.Texture, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Vector2, UnityEngine.Vector2)
static bool w_vtos_i4i4i4pi4i4i4_s_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_i4i4i4pi4i4i4_s_r4r4_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4_>(context, info[2]);
    s_r4r4_ p2 = pp2 ? *pp2 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4_>(context, info[3]);
    s_r4r4_ p3 = pp3 ? *pp3 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_i4i4i4pi4i4i4_ p1, struct s_r4r4_ p2, struct s_r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetTargetBuffers(UnityEngine.RenderBuffer[], UnityEngine.RenderBuffer)
static bool w_vtos_i4p_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_i4p_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_i4p_* pp1 = DataTransfer::GetPointer<s_i4p_>(context, info[1]);
    s_i4p_ p1 = pp1 ? *pp1 : s_i4p_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_i4p_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.RenderBuffer[], UnityEngine.RenderBuffer, Int32)
static bool w_vtos_i4p_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_i4p_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_i4p_* pp1 = DataTransfer::GetPointer<s_i4p_>(context, info[1]);
    s_i4p_ p1 = pp1 ? *pp1 : s_i4p_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, struct s_i4p_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.RenderBuffer[], UnityEngine.RenderBuffer, Int32, UnityEngine.CubemapFace)
static bool w_vtos_i4p_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_i4p_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_i4p_* pp1 = DataTransfer::GetPointer<s_i4p_>(context, info[1]);
    s_i4p_ p1 = pp1 ? *pp1 : s_i4p_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, struct s_i4p_ p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(UnityEngine.RenderBuffer[], UnityEngine.RenderBuffer, Int32, UnityEngine.CubemapFace, UnityEngine.Rendering.RenderBufferLoadAction[], UnityEngine.Rendering.RenderBufferStoreAction[], UnityEngine.Rendering.RenderBufferLoadAction, UnityEngine.Rendering.RenderBufferStoreAction)
static bool w_vtos_i4p_i4i4ooi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_i4p_i4i4ooi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_i4p_* pp1 = DataTransfer::GetPointer<s_i4p_>(context, info[1]);
    s_i4p_ p1 = pp1 ? *pp1 : s_i4p_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void*,void* p0, struct s_i4p_ p1, int32_t p2, int32_t p3, void* p4, void* p5, int32_t p6, int32_t p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.ShaderTagId[], UnityEngine.Rendering.CullingResults, UnityEngine.Camera)
static bool w_vtos_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_* pp1 = DataTransfer::GetPointer<s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_>(context, info[1]);
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p1 = pp1 ? *pp1 : s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,void* p0, struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void LookAt(UnityEngine.Transform, UnityEngine.Vector3)
static bool w_vtos_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void DrawPolygon(System.Collections.Generic.IList`1[UnityEngine.Vector2], UnityEngine.Color)
static bool w_vtos_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(FairyGUI.NTexture, UnityEngine.Rect, Boolean)
static bool w_vtos_r4r4r4r4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4r4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(FairyGUI.NTexture, UnityEngine.Rect, Boolean, UnityEngine.Vector2, UnityEngine.Vector2)
static bool w_vtos_r4r4r4r4_bs_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4r4_bs_r4r4_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if ((!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4_>(context, info[3]);
    s_r4r4_ p3 = pp3 ? *pp3 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp4 = DataTransfer::GetPointer<s_r4r4_>(context, info[4]);
    s_r4r4_ p4 = pp4 ? *pp4 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4_ p1, bool p2, struct s_r4r4_ p3, struct s_r4r4_ p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawPolygon(System.Collections.Generic.IList`1[UnityEngine.Vector2], UnityEngine.Color, Single, UnityEngine.Color)
static bool w_vtos_r4r4r4r4_r4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4r4_r4s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4_ p1, float p2, struct s_r4r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Matrix4x4, UnityEngine.Material)
static bool w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Matrix4x4, UnityEngine.Material, Int32)
static bool w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, Int32)
static bool w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawProcedural(UnityEngine.GraphicsBuffer, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, Int32)
static bool w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void DrawProcedural(UnityEngine.GraphicsBuffer, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, Int32, Int32)
static bool w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void DrawProcedural(UnityEngine.GraphicsBuffer, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, Int32, Int32, UnityEngine.MaterialPropertyBlock)
static bool w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp7 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, void* p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void DrawMesh(UnityEngine.Mesh, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, Int32, UnityEngine.MaterialPropertyBlock)
static bool w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, int32_t p4, void* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void DrawProceduralIndirect(UnityEngine.GraphicsBuffer, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, UnityEngine.ComputeBuffer, Int32)
static bool w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, int32_t p4, void* p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void DrawProceduralIndirect(UnityEngine.GraphicsBuffer, UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, UnityEngine.ComputeBuffer, Int32, UnityEngine.MaterialPropertyBlock)
static bool w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp5 = wrapData->TypeInfos[3];
    auto TIp7 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!info[7]->IsNullOrUndefined() && (!info[7]->IsObject() || (info[7]->IsFunction() ? !IsDelegate(TIp7) : !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal o/O
    void* p7 = JsValueToCSRef(context, info[7], TIp7);

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* p2, int32_t p3, int32_t p4, void* p5, int32_t p6, void* p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void SetComputeIntParam(UnityEngine.ComputeShader, System.String, Int32)
static bool w_vtosi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtosi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetGlobalConstantBuffer(UnityEngine.ComputeBuffer, System.String, Int32, Int32)
static bool w_vtosi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtosi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetComputeVectorArrayParam(UnityEngine.ComputeShader, System.String, UnityEngine.Vector4[])
static bool w_vtoso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetComputeConstantBufferParam(UnityEngine.ComputeShader, System.String, UnityEngine.ComputeBuffer, Int32, Int32)
static bool w_vtosoi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtosoi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void SetComputeFloatParam(UnityEngine.ComputeShader, System.String, Single)
static bool w_vtosr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtosr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Run(FairyGUI.Controller, System.String, System.String)
static bool w_vtoss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetRayTracingTextureParam(UnityEngine.Experimental.Rendering.RayTracingShader, System.String, UnityEngine.Rendering.RenderTargetIdentifier)
static bool w_vtoss_i4i4i4pi4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoss_i4i4i4pi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp2 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[2]);
    s_i4i4i4pi4i4i4_ p2 = pp2 ? *pp2 : s_i4i4i4pi4i4i4_ {};

    typedef void (*FuncToCall)(void*,void* p0, void* p1, struct s_i4i4i4pi4i4i4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetComputeVectorParam(UnityEngine.ComputeShader, System.String, UnityEngine.Vector4)
static bool w_vtoss_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoss_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, void* p1, struct s_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetComputeMatrixParam(UnityEngine.ComputeShader, System.String, UnityEngine.Matrix4x4)
static bool w_vtoss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtoss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, void* p1, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void DispatchRays(UnityEngine.Experimental.Rendering.RayTracingShader, System.String, UInt32, UInt32, UInt32, UnityEngine.Camera)
static bool w_vtosu4u4u4Do(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtosu4u4u4Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[4])) return false;
        if (length > 5 && !info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(context, info[4]);
    // JSValToCSVal ref  with default
    void* p5 = OptionalParameter<void*>::GetRefType(context, info, method, 5, TIp5);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, uint32_t p2, uint32_t p3, uint32_t p4, void* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void SetBufferCounterValue(UnityEngine.ComputeBuffer, UInt32)
static bool w_vtou4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtou4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, uint32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddInstance(UnityEngine.GraphicsBuffer, UInt32, UnityEngine.Material, Boolean, Boolean, Boolean, UInt32, Boolean, UInt32)
static bool w_vtou4obDbDbDu4DbDu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtou4obDbDbDu4DbDu4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<bool>::accept(context, info[4])) return false;
        if (length > 5 && !converter::Converter<bool>::accept(context, info[5])) return false;
        if (length > 6 && !converter::Converter<uint32_t>::accept(context, info[6])) return false;
        if (length > 7 && !converter::Converter<bool>::accept(context, info[7])) return false;
        if (length > 8 && !converter::Converter<uint32_t>::accept(context, info[8])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(context, info, method, 4);
                
    // JSValToCSVal primitive with default
    bool p5 = OptionalParameter<bool>::GetPrimitive(context, info, method, 5);
                
    // JSValToCSVal primitive with default
    uint32_t p6 = OptionalParameter<uint32_t>::GetPrimitive(context, info, method, 6);
                
    // JSValToCSVal primitive with default
    bool p7 = OptionalParameter<bool>::GetPrimitive(context, info, method, 7);
                
    // JSValToCSVal primitive with default
    uint32_t p8 = OptionalParameter<uint32_t>::GetPrimitive(context, info, method, 8);
                

    typedef void (*FuncToCall)(void*,void* p0, uint32_t p1, void* p2, bool p3, bool p4, bool p5, uint32_t p6, bool p7, uint32_t p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void AddInstance(UnityEngine.GraphicsBuffer, UInt32, UnityEngine.Material, UnityEngine.Matrix4x4, Boolean, Boolean, Boolean, UInt32, Boolean, UInt32)
static bool w_vtou4os_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_bDbDbDu4DbDu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtou4os_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_bDbDbDu4DbDu4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 5) return false;
        if (!info[0]->IsNullOrUndefined() && (!info[0]->IsObject() || (info[0]->IsFunction() ? !IsDelegate(TIp0) : !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>()))))) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (length > 5 && !converter::Converter<bool>::accept(context, info[5])) return false;
        if (length > 6 && !converter::Converter<bool>::accept(context, info[6])) return false;
        if (length > 7 && !converter::Converter<uint32_t>::accept(context, info[7])) return false;
        if (length > 8 && !converter::Converter<bool>::accept(context, info[8])) return false;
        if (length > 9 && !converter::Converter<uint32_t>::accept(context, info[9])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal o/O
    void* p0 = JsValueToCSRef(context, info[0], TIp0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal primitive with default
    bool p5 = OptionalParameter<bool>::GetPrimitive(context, info, method, 5);
                
    // JSValToCSVal primitive with default
    bool p6 = OptionalParameter<bool>::GetPrimitive(context, info, method, 6);
                
    // JSValToCSVal primitive with default
    uint32_t p7 = OptionalParameter<uint32_t>::GetPrimitive(context, info, method, 7);
                
    // JSValToCSVal primitive with default
    bool p8 = OptionalParameter<bool>::GetPrimitive(context, info, method, 8);
                
    // JSValToCSVal primitive with default
    uint32_t p9 = OptionalParameter<uint32_t>::GetPrimitive(context, info, method, 9);
                

    typedef void (*FuncToCall)(void*,void* p0, uint32_t p1, void* p2, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p3, bool p4, bool p5, bool p6, uint32_t p7, bool p8, uint32_t p9, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9,  method);

    
    return true;
}

// Void UpdateExternalTexture(IntPtr)
static bool w_vtp(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtp");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsArrayBuffer()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(IntPtr, Boolean)
static bool w_vtpDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtpDb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void LoadRawTextureData(IntPtr, Int32)
static bool w_vtpi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtpi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void IssuePluginEventAndData(IntPtr, Int32, IntPtr)
static bool w_vtpi4p(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtpi4p");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsArrayBuffer()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    void* p2 = DataTransfer::GetPointer<void>(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void IssuePluginCustomTextureUpdateV2(IntPtr, UnityEngine.Texture, UInt32)
static bool w_vtpou4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtpou4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void IssuePluginCustomBlit(IntPtr, UInt32, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, UInt32, UInt32)
static bool w_vtpu4s_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_u4u4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtpu4s_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_u4u4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!info[0]->IsArrayBuffer()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    void* p0 = DataTransfer::GetPointer<void>(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp2 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[2]);
    s_i4i4i4pi4i4i4_ p2 = pp2 ? *pp2 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp3 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[3]);
    s_i4i4i4pi4i4i4_ p3 = pp3 ? *pp3 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    uint32_t p4 = converter::Converter<uint32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    uint32_t p5 = converter::Converter<uint32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,void* p0, uint32_t p1, struct s_i4i4i4pi4i4i4_ p2, struct s_i4i4i4pi4i4i4_ p3, uint32_t p4, uint32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void set_alpha(Single)
static bool w_vtr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,float p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetPercX(Single, Boolean)
static bool w_vtr4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,float p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetSpeed(Single, Int32)
static bool w_vtr4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,float p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Add(Single, Int32, FairyGUI.TimerCallback)
static bool w_vtr4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4i4o");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,float p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Add(Single, Int32, FairyGUI.TimerCallback, System.Object)
static bool w_vtr4i4oO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4i4oO");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,float p0, int32_t p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawRect(Single, UnityEngine.Color32[])
static bool w_vtr4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4o");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,float p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetXY(Single, Single)
static bool w_vtr4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,float p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetXY(Single, Single, Boolean)
static bool w_vtr4r4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,float p0, float p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void DrawRect(Single, Single, Int32, UnityEngine.Color, UnityEngine.Color)
static bool w_vtr4r4i4s_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4i4s_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIp3 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if ((!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp4 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[4]);
    s_r4r4r4r4_ p4 = pp4 ? *pp4 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,float p0, float p1, int32_t p2, struct s_r4r4r4r4_ p3, struct s_r4r4r4r4_ p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawPolygon(Single, Single, System.Collections.Generic.IList`1[UnityEngine.Vector2], UnityEngine.Color)
static bool w_vtr4r4os_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4os_r4r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,float p0, float p1, void* p2, struct s_r4r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void DrawPolygon(Single, Single, System.Collections.Generic.IList`1[UnityEngine.Vector2], UnityEngine.Color, Single, UnityEngine.Color)
static bool w_vtr4r4os_r4r4r4r4_r4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4os_r4r4r4r4_r4s_r4r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];
    auto TIp5 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if ((!info[5]->IsObject() || !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp5 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[5]);
    s_r4r4r4r4_ p5 = pp5 ? *pp5 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,float p0, float p1, void* p2, struct s_r4r4r4r4_ p3, float p4, struct s_r4r4r4r4_ p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void SetPosition(Single, Single, Single)
static bool w_vtr4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void AddFilled(Single, Single, Single, Int32, Int32)
static bool w_vtr4r4r4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4Di4Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                
    // JSValToCSVal primitive with default
    int32_t p4 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 4);
                

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Translate(Single, Single, Single, UnityEngine.Space)
static bool w_vtr4r4r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Translate(Single, Single, Single, UnityEngine.Transform)
static bool w_vtr4r4r4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4o");
    
    auto TIp3 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetRotation(Single, Single, Single, Single)
static bool w_vtr4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, float p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetLimit(Single, Single, Single, Single, Boolean)
static bool w_vtr4r4r4r4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4r4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, float p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void LerpRotation(Single, Single, Single, Single, Single)
static bool w_vtr4r4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, float p3, float p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(Single, Single, Single, Single, Single, Single)
static bool w_vtr4r4r4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4r4r4r4r4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,float p0, float p1, float p2, float p3, float p4, float p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void SetValue(Single, Single, System.String)
static bool w_vtr4r4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4s");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(void*,float p0, float p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void DrawEllipse(Single, Single, UnityEngine.Color)
static bool w_vtr4r4s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4s_r4r4r4r4_");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,float p0, float p1, struct s_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void DrawRoundRect(Single, Single, UnityEngine.Color, Single[])
static bool w_vtr4r4s_r4r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4r4s_r4r4r4r4_o");
    
    auto TIp2 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,float p0, float p1, struct s_r4r4r4r4_ p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(Single, UnityEngine.Color, Boolean)
static bool w_vtr4s_r4r4r4r4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4s_r4r4r4r4_b");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,float p0, struct s_r4r4r4r4_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void DrawRect(Single, UnityEngine.Color, UnityEngine.Color)
static bool w_vtr4s_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4s_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,float p0, struct s_r4r4r4r4_ p1, struct s_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void DrawRoundRect(Single, UnityEngine.Color, UnityEngine.Color, Single, Single, Single, Single)
static bool w_vtr4s_r4r4r4r4_s_r4r4r4r4_r4r4r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4s_r4r4r4r4_s_r4r4r4r4_r4r4r4r4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[3])) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
        if (!converter::Converter<float>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p3 = converter::Converter<float>::toCpp(context, info[3]);
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);
    // JSValToCSVal P any
    float p6 = converter::Converter<float>::toCpp(context, info[6]);

    typedef void (*FuncToCall)(void*,float p0, struct s_r4r4r4r4_ p1, struct s_r4r4r4r4_ p2, float p3, float p4, float p5, float p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void DrawEllipse(Single, UnityEngine.Color, UnityEngine.Color, UnityEngine.Color, Single, Single)
static bool w_vtr4s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr4s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4r4");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<float>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[4])) return false;
        if (!converter::Converter<float>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    float p0 = converter::Converter<float>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p4 = converter::Converter<float>::toCpp(context, info[4]);
    // JSValToCSVal P any
    float p5 = converter::Converter<float>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,float p0, struct s_r4r4r4r4_ p1, struct s_r4r4r4r4_ p2, struct s_r4r4r4r4_ p3, float p4, float p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void set_min(Double)
static bool w_vtr8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtr8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<double>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    double p0 = converter::Converter<double>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,double p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_shader(System.String)
static bool w_vts(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);

    typedef void (*FuncToCall)(void*,void* p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(System.String, Int32, UnityEngine.CubemapFace, Int32)
static bool w_vtsDi4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsDi4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void showDialog(System.String, System.Action, System.Action, System.String, System.String, System.String)
static bool w_vtsDoDoDsDsDs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsDoDoDsDsDs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (length > 2 && !info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (length > 3 && !info[3]->IsString() && !info[3]->IsNullOrUndefined()) return false;
        if (length > 4 && !info[4]->IsString() && !info[4]->IsNullOrUndefined()) return false;
        if (length > 5 && !info[5]->IsString() && !info[5]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal ref  with default
    void* p1 = OptionalParameter<void*>::GetRefType(context, info, method, 1, TIp1);
                
    // JSValToCSVal ref  with default
    void* p2 = OptionalParameter<void*>::GetRefType(context, info, method, 2, TIp2);
                
    // JSValToCSVal string  with default
    void* p3 = OptionalParameter<void*>::GetString(context, info, method, 3);
                
    // JSValToCSVal string  with default
    void* p4 = OptionalParameter<void*>::GetString(context, info, method, 4);
                
    // JSValToCSVal string  with default
    void* p5 = OptionalParameter<void*>::GetString(context, info, method, 5);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(System.String, Single, Int32)
static bool w_vtsDr4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsDr4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !converter::Converter<float>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, float p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Connect(System.String, System.String, System.String)
static bool w_vtsDsDs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsDsDs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (length > 1 && !info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (length > 2 && !info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal string  with default
    void* p1 = OptionalParameter<void*>::GetString(context, info, method, 1);
                
    // JSValToCSVal string  with default
    void* p2 = OptionalParameter<void*>::GetString(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Set(System.String, System.Object)
static bool w_vtsO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SendMessageUpwards(System.String, System.Object, UnityEngine.SendMessageOptions)
static bool w_vtsOi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsOi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Log(System.String, System.Object, UnityEngine.Object)
static bool w_vtsOo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsOo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void readString(System.String, System.String ByRef)
static bool w_vtsPs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsPs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal Ps
    void* up1 = nullptr; // string ref
    void** p1 = &up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        v8::String::Utf8Value tp1(isolate, op1->Get(context, 0).ToLocalChecked());
        up1 = CStringToCSharpString(*tp1);
    }
        

    typedef void (*FuncToCall)(void*,void* p0, void** p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    if (!op1.IsEmpty())
    {
        auto _unused = op1->Set(context, 0, CSAnyToJsValue(isolate, context, *p1));
    }
    
    return true;
}

// Void SetValue(System.String, System.Object[])
static bool w_vtsVO(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsVO");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal ref params
    void* p1 = RestArguments<void*>::PackRef(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetInts(System.String, Int32[])
static bool w_vtsVi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsVi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && !converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal primitive params
    void* p1 = RestArguments<int32_t>::PackPrimitive(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.String, System.Type[])
static bool w_vtsVo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && !info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal ref params
    void* p1 = RestArguments<void*>::PackRef(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetFloats(System.String, Single[])
static bool w_vtsVr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsVr4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 1) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && !converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal primitive params
    void* p1 = RestArguments<float>::PackPrimitive(context, info, TIp1, 1);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetPositions(Unity.Collections.NativeSlice`1[UnityEngine.Vector3])
static bool w_vts_Pu1i4i4i4i4pi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pu1i4i4i4i4pi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pu1i4i4i4i4pi4i4_* pp0 = DataTransfer::GetPointer<s_Pu1i4i4i4i4pi4i4_>(context, info[0]);
    s_Pu1i4i4i4i4pi4i4_ p0 = pp0 ? *pp0 : s_Pu1i4i4i4i4pi4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_Pu1i4i4i4i4pi4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void GetVertices(Unity.Collections.NativeArray`1[UnityEngine.Vector3])
static bool w_vts_Pvi4i4i4pi4i4oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pvi4i4i4pi4i4oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};

    typedef void (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void BeginSubPass(Unity.Collections.NativeArray`1[System.Int32], Boolean)
static bool w_vts_Pvi4i4i4pi4i4oi4_Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pvi4i4i4pi4i4oi4_Db");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void BeginSubPass(Unity.Collections.NativeArray`1[System.Int32], Boolean, Boolean)
static bool w_vts_Pvi4i4i4pi4i4oi4_bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pvi4i4i4pi4i4oi4_bb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void GetIndices(Unity.Collections.NativeArray`1[System.UInt16], Int32, Boolean)
static bool w_vts_Pvi4i4i4pi4i4oi4_i4Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pvi4i4i4pi4i4oi4_i4Db");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetBoneWeights(Unity.Collections.NativeArray`1[System.Byte], Unity.Collections.NativeArray`1[UnityEngine.BoneWeight1])
static bool w_vts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp1 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[1]);
    s_Pvi4i4i4pi4i4oi4_ p1 = pp1 ? *pp1 : s_Pvi4i4i4pi4i4oi4_ {};

    typedef void (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, struct s_Pvi4i4i4pi4i4oi4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void BeginSubPass(Unity.Collections.NativeArray`1[System.Int32], Unity.Collections.NativeArray`1[System.Int32], Boolean)
static bool w_vts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_Db");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp1 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[1]);
    s_Pvi4i4i4pi4i4oi4_ p1 = pp1 ? *pp1 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, struct s_Pvi4i4i4pi4i4oi4_ p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void BeginSubPass(Unity.Collections.NativeArray`1[System.Int32], Unity.Collections.NativeArray`1[System.Int32], Boolean, Boolean)
static bool w_vts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_bb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp0 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p0 = pp0 ? *pp0 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp1 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[1]);
    s_Pvi4i4i4pi4i4oi4_ p1 = pp1 ? *pp1 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,struct s_Pvi4i4i4pi4i4oi4_ p0, struct s_Pvi4i4i4pi4i4oi4_ p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void set_clipRect(System.Nullable`1[UnityEngine.Rect])
static bool w_vts_br4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_br4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_br4r4r4r4_* pp0 = DataTransfer::GetPointer<s_br4r4r4r4_>(context, info[0]);
    s_br4r4r4r4_ p0 = pp0 ? *pp0 : s_br4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_br4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_sortingLayerRange(UnityEngine.Rendering.SortingLayerRange)
static bool w_vts_i2i2_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i2i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i2i2_* pp0 = DataTransfer::GetPointer<s_i2i2_>(context, info[0]);
    s_i2i2_ p0 = pp0 ? *pp0 : s_i2i2_ {};

    typedef void (*FuncToCall)(void*,struct s_i2i2_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_scene(UnityEngine.SceneManagement.Scene)
static bool w_vts_i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4_* pp0 = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p0 = pp0 ? *pp0 : s_i4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.ShaderTagId, UnityEngine.Rendering.CullingResults, UnityEngine.Camera)
static bool w_vts_i4_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4_* pp0 = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p0 = pp0 ? *pp0 : s_i4_ {};
    // JSValToCSVal struct
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_* pp1 = DataTransfer::GetPointer<s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_>(context, info[1]);
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p1 = pp1 ? *pp1 : s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,struct s_i4_ p0, struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.ShaderTagId, UnityEngine.Rendering.SortingSettings)
static bool w_vts_i4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4_* pp0 = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p0 = pp0 ? *pp0 : s_i4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Register(System.Guid, UnityEngine.Events.UnityAction`1[UnityEngine.Networking.PlayerConnection.MessageEventArgs])
static bool w_vts_i4i2i2u1u1u1u1u1u1u1u1_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i2i2u1u1u1u1u1u1u1u1_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i2i2u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<s_i4i2i2u1u1u1u1u1u1u1u1_>(context, info[0]);
    s_i4i2i2u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : s_i4i2i2u1u1u1u1u1u1u1u1_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,struct s_i4i2i2u1u1u1u1u1u1u1u1_ p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_min(UnityEngine.Vector2Int)
static bool w_vts_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4_>(context, info[0]);
    s_i4i4_ p0 = pp0 ? *pp0 : s_i4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetMinMax(UnityEngine.Vector2Int, UnityEngine.Vector2Int)
static bool w_vts_i4i4_s_i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4_s_i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4_>(context, info[0]);
    s_i4i4_ p0 = pp0 ? *pp0 : s_i4i4_ {};
    // JSValToCSVal struct
    s_i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4_>(context, info[1]);
    s_i4i4_ p1 = pp1 ? *pp1 : s_i4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4i4_ p0, struct s_i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_min(UnityEngine.Vector3Int)
static bool w_vts_i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4_>(context, info[0]);
    s_i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetMinMax(UnityEngine.Vector3Int, UnityEngine.Vector3Int)
static bool w_vts_i4i4i4_s_i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4_s_i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4_>(context, info[0]);
    s_i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4_ {};
    // JSValToCSVal struct
    s_i4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4_>(context, info[1]);
    s_i4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4i4i4_ p0, struct s_i4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_margin(FairyGUI.Margin)
static bool w_vts_i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4i4_>(context, info[0]);
    s_i4i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4i4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_bakingOutput(UnityEngine.LightBakingOutput)
static bool w_vts_i4i4i4i4b_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4i4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4i4b_* pp0 = DataTransfer::GetPointer<s_i4i4i4i4b_>(context, info[0]);
    s_i4i4i4i4b_ p0 = pp0 ? *pp0 : s_i4i4i4i4b_ {};

    typedef void (*FuncToCall)(void*,struct s_i4i4i4i4b_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void ClampToBounds(UnityEngine.BoundsInt)
static bool w_vts_i4i4i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4i4i4i4_>(context, info[0]);
    s_i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4i4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4i4i4i4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_descriptor(UnityEngine.RenderTextureDescriptor)
static bool w_vts_i4i4i4i4i4i4i4i4i4i4i4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4i4i4i4i4i4i4i4i4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4i4i4i4i4i4i4i4i4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4i4i4i4i4i4i4i4i4i4i4_>(context, info[0]);
    s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4i4i4i4i4i4i4i4i4i4i4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_depthRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier)
static bool w_vts_i4i4i4pi4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SwitchOutOfFastMemory(UnityEngine.Rendering.CommandBuffer, UnityEngine.Rendering.RenderTargetIdentifier, Boolean)
static bool w_vts_i4i4i4pi4i4i4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void ConfigureTarget(UnityEngine.Rendering.RenderTargetIdentifier, Boolean, Boolean)
static bool w_vts_i4i4i4pi4i4i4_bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_bb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, Int32)
static bool w_vts_i4i4i4pi4i4i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Rendering.RenderTargetIdentifier, Int32, UnityEngine.CubemapFace, Int32)
static bool w_vts_i4i4i4pi4i4i4_i4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_i4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderBufferLoadAction, UnityEngine.Rendering.RenderBufferStoreAction)
static bool w_vts_i4i4i4pi4i4i4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, Int32, UnityEngine.CubemapFace, Int32)
static bool w_vts_i4i4i4pi4i4i4_i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderBufferLoadAction, UnityEngine.Rendering.RenderBufferStoreAction, UnityEngine.Rendering.RenderBufferLoadAction, UnityEngine.Rendering.RenderBufferStoreAction)
static bool w_vts_i4i4i4pi4i4i4_i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_i4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void CopyTexture(UnityEngine.Rendering.RenderTargetIdentifier, Int32, Int32, Int32, Int32, Int32, Int32, UnityEngine.Rendering.RenderTargetIdentifier, Int32, Int32, Int32, Int32)
static bool w_vts_i4i4i4pi4i4i4_i4i4i4i4i4i4s_i4i4i4pi4i4i4_i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_i4i4i4i4i4i4s_i4i4i4pi4i4i4_i4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp7 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 12) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if ((!info[7]->IsObject() || !IsAssignableFrom(TIp7, GetTypeId(info[7].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[8])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[9])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[10])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[11])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp7 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[7]);
    s_i4i4i4pi4i4i4_ p7 = pp7 ? *pp7 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p8 = converter::Converter<int32_t>::toCpp(context, info[8]);
    // JSValToCSVal P any
    int32_t p9 = converter::Converter<int32_t>::toCpp(context, info[9]);
    // JSValToCSVal P any
    int32_t p10 = converter::Converter<int32_t>::toCpp(context, info[10]);
    // JSValToCSVal P any
    int32_t p11 = converter::Converter<int32_t>::toCpp(context, info[11]);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, int32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, struct s_i4i4i4pi4i4i4_ p7, int32_t p8, int32_t p9, int32_t p10, int32_t p11, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderBufferLoadAction, UnityEngine.Rendering.RenderBufferStoreAction, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderBufferLoadAction, UnityEngine.Rendering.RenderBufferStoreAction)
static bool w_vts_i4i4i4pi4i4i4_i4i4s_i4i4i4pi4i4i4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_i4i4s_i4i4i4pi4i4i4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp3 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[3]);
    s_i4i4i4pi4i4i4_ p3 = pp3 ? *pp3 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, int32_t p1, int32_t p2, struct s_i4i4i4pi4i4i4_ p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void SwitchIntoFastMemory(UnityEngine.Rendering.CommandBuffer, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.FastMemoryFlags, Single, Boolean)
static bool w_vts_i4i4i4pi4i4i4_i4r4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_i4r4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, int32_t p1, float p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void ConvertTexture(UnityEngine.Rendering.RenderTargetIdentifier, Int32, UnityEngine.Rendering.RenderTargetIdentifier, Int32)
static bool w_vts_i4i4i4pi4i4i4_i4s_i4i4i4pi4i4i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_i4s_i4i4i4pi4i4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp2 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[2]);
    s_i4i4i4pi4i4i4_ p2 = pp2 ? *pp2 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, int32_t p1, struct s_i4i4i4pi4i4i4_ p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void ProcessVTFeedback(UnityEngine.Rendering.RenderTargetIdentifier, IntPtr, Int32, Int32, Int32, Int32, Int32, Int32)
static bool w_vts_i4i4i4pi4i4i4_pi4i4i4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_pi4i4i4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsArrayBuffer()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    void* p1 = DataTransfer::GetPointer<void>(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, void* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, int32_t p6, int32_t p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void ConvertTexture(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier)
static bool w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, struct s_i4i4i4pi4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, Int32)
static bool w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, struct s_i4i4i4pi4i4i4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, Int32, UnityEngine.CubemapFace)
static bool w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, struct s_i4i4i4pi4i4i4_ p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, Int32, UnityEngine.CubemapFace, Int32)
static bool w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, struct s_i4i4i4pi4i4i4_ p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Blit(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Material)
static bool w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, struct s_i4i4i4pi4i4i4_ p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Blit(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Material, Int32)
static bool w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, struct s_i4i4i4pi4i4i4_ p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Blit(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Material, Int32, Int32)
static bool w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_oi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_oi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, struct s_i4i4i4pi4i4i4_ p1, void* p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void Blit(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Vector2, UnityEngine.Vector2)
static bool w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_s_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_s_r4r4_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4_>(context, info[2]);
    s_r4r4_ p2 = pp2 ? *pp2 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4_>(context, info[3]);
    s_r4r4_ p3 = pp3 ? *pp3 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, struct s_i4i4i4pi4i4i4_ p1, struct s_r4r4_ p2, struct s_r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Blit(UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Vector2, UnityEngine.Vector2, Int32, Int32)
static bool w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_s_r4r4_s_r4r4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_s_r4r4_s_r4r4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp0 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[0]);
    s_i4i4i4pi4i4i4_ p0 = pp0 ? *pp0 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4_>(context, info[2]);
    s_r4r4_ p2 = pp2 ? *pp2 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4_>(context, info[3]);
    s_r4r4_ p3 = pp3 ? *pp3 : s_r4r4_ {};
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,struct s_i4i4i4pi4i4i4_ p0, struct s_i4i4i4pi4i4i4_ p1, struct s_r4r4_ p2, struct s_r4r4_ p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void set_rasterState(UnityEngine.Rendering.RasterState)
static bool w_vts_i4i4r4u1u1u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4i4r4u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4i4r4u1u1u1u1_* pp0 = DataTransfer::GetPointer<s_i4i4r4u1u1u1u1_>(context, info[0]);
    s_i4i4r4u1u1u1u1_ p0 = pp0 ? *pp0 : s_i4i4r4u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,struct s_i4i4r4u1u1u1u1_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UnityEngine.RenderBuffer, Int32, UnityEngine.CubemapFace, Int32)
static bool w_vts_i4p_Di4Di4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4p_Di4Di4Di4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (length > 1 && !converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4p_* pp0 = DataTransfer::GetPointer<s_i4p_>(context, info[0]);
    s_i4p_ p0 = pp0 ? *pp0 : s_i4p_ {};
    // JSValToCSVal primitive with default
    int32_t p1 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,struct s_i4p_ p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetTargetBuffers(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer)
static bool w_vts_i4p_s_i4p_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4p_s_i4p_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4p_* pp0 = DataTransfer::GetPointer<s_i4p_>(context, info[0]);
    s_i4p_ p0 = pp0 ? *pp0 : s_i4p_ {};
    // JSValToCSVal struct
    s_i4p_* pp1 = DataTransfer::GetPointer<s_i4p_>(context, info[1]);
    s_i4p_ p1 = pp1 ? *pp1 : s_i4p_ {};

    typedef void (*FuncToCall)(void*,struct s_i4p_ p0, struct s_i4p_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer, Int32)
static bool w_vts_i4p_s_i4p_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4p_s_i4p_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4p_* pp0 = DataTransfer::GetPointer<s_i4p_>(context, info[0]);
    s_i4p_ p0 = pp0 ? *pp0 : s_i4p_ {};
    // JSValToCSVal struct
    s_i4p_* pp1 = DataTransfer::GetPointer<s_i4p_>(context, info[1]);
    s_i4p_ p1 = pp1 ? *pp1 : s_i4p_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_i4p_ p0, struct s_i4p_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer, Int32, UnityEngine.CubemapFace)
static bool w_vts_i4p_s_i4p_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4p_s_i4p_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4p_* pp0 = DataTransfer::GetPointer<s_i4p_>(context, info[0]);
    s_i4p_ p0 = pp0 ? *pp0 : s_i4p_ {};
    // JSValToCSVal struct
    s_i4p_* pp1 = DataTransfer::GetPointer<s_i4p_>(context, info[1]);
    s_i4p_ p1 = pp1 ? *pp1 : s_i4p_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,struct s_i4p_ p0, struct s_i4p_ p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(UnityEngine.RenderBuffer, UnityEngine.RenderBuffer, Int32, UnityEngine.CubemapFace, Int32)
static bool w_vts_i4p_s_i4p_i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4p_s_i4p_i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4p_* pp0 = DataTransfer::GetPointer<s_i4p_>(context, info[0]);
    s_i4p_ p0 = pp0 ? *pp0 : s_i4p_ {};
    // JSValToCSVal struct
    s_i4p_* pp1 = DataTransfer::GetPointer<s_i4p_>(context, info[1]);
    s_i4p_ p1 = pp1 ? *pp1 : s_i4p_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,struct s_i4p_ p0, struct s_i4p_ p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void set_lodParameters(UnityEngine.Rendering.LODParameters)
static bool w_vts_i4r4r4r4r4r4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4r4r4r4r4r4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4r4r4r4r4r4i4_* pp0 = DataTransfer::GetPointer<s_i4r4r4r4r4r4i4_>(context, info[0]);
    s_i4r4r4r4r4r4i4_ p0 = pp0 ? *pp0 : s_i4r4r4r4r4r4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4r4r4r4r4r4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_splitData(UnityEngine.Rendering.ShadowSplitData)
static bool w_vts_i4u1r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4u1r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4u1r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_i4u1r4r4r4r4r4r4_>(context, info[0]);
    s_i4u1r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_i4u1r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_i4u1r4r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_color(UnityEngine.Color32)
static bool w_vts_i4u1u1u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i4u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i4u1u1u1u1_* pp0 = DataTransfer::GetPointer<s_i4u1u1u1u1_>(context, info[0]);
    s_i4u1u1u1u1_ p0 = pp0 ? *pp0 : s_i4u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,struct s_i4u1u1u1u1_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(GCore.F64, GCore.F64, GCore.F64)
static bool w_vts_i8_s_i8_s_i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i8_s_i8_s_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8_* pp0 = DataTransfer::GetPointer<s_i8_>(context, info[0]);
    s_i8_ p0 = pp0 ? *pp0 : s_i8_ {};
    // JSValToCSVal struct
    s_i8_* pp1 = DataTransfer::GetPointer<s_i8_>(context, info[1]);
    s_i8_ p1 = pp1 ? *pp1 : s_i8_ {};
    // JSValToCSVal struct
    s_i8_* pp2 = DataTransfer::GetPointer<s_i8_>(context, info[2]);
    s_i8_ p2 = pp2 ? *pp2 : s_i8_ {};

    typedef void (*FuncToCall)(void*,struct s_i8_ p0, struct s_i8_ p1, struct s_i8_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(GCore.F64, GCore.F64, GCore.F64, GCore.F64)
static bool w_vts_i8_s_i8_s_i8_s_i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i8_s_i8_s_i8_s_i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8_* pp0 = DataTransfer::GetPointer<s_i8_>(context, info[0]);
    s_i8_ p0 = pp0 ? *pp0 : s_i8_ {};
    // JSValToCSVal struct
    s_i8_* pp1 = DataTransfer::GetPointer<s_i8_>(context, info[1]);
    s_i8_ p1 = pp1 ? *pp1 : s_i8_ {};
    // JSValToCSVal struct
    s_i8_* pp2 = DataTransfer::GetPointer<s_i8_>(context, info[2]);
    s_i8_ p2 = pp2 ? *pp2 : s_i8_ {};
    // JSValToCSVal struct
    s_i8_* pp3 = DataTransfer::GetPointer<s_i8_>(context, info[3]);
    s_i8_ p3 = pp3 ? *pp3 : s_i8_ {};

    typedef void (*FuncToCall)(void*,struct s_i8_ p0, struct s_i8_ p1, struct s_i8_ p2, struct s_i8_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void CopyFrom(GCore.FVector3)
static bool w_vts_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};

    typedef void (*FuncToCall)(void*,struct s_i8i8i8_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void InsertPolyPoint(GCore.FVector3, Int32)
static bool w_vts_i8i8i8_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i8i8i8_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_i8i8i8_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void CopyFrom(GCore.FQuaterion)
static bool w_vts_i8i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_i8i8i8i8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_i8i8i8i8_* pp0 = DataTransfer::GetPointer<s_i8i8i8i8_>(context, info[0]);
    s_i8i8i8i8_ p0 = pp0 ? *pp0 : s_i8i8i8i8_ {};

    typedef void (*FuncToCall)(void*,struct s_i8i8i8i8_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetBinding)
static bool w_vts_oi4i4i4pi4i4i4ooi4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_oi4i4i4pi4i4i4ooi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_oi4i4i4pi4i4i4ooi4i4i4_* pp0 = DataTransfer::GetPointer<s_oi4i4i4pi4i4i4ooi4i4i4_>(context, info[0]);
    s_oi4i4i4pi4i4i4ooi4i4i4_ p0 = pp0 ? *pp0 : s_oi4i4i4pi4i4i4ooi4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_oi4i4i4pi4i4i4ooi4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetRenderTarget(UnityEngine.Rendering.RenderTargetBinding, Int32, UnityEngine.CubemapFace, Int32)
static bool w_vts_oi4i4i4pi4i4i4ooi4i4i4_i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_oi4i4i4pi4i4i4ooi4i4i4_i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_oi4i4i4pi4i4i4ooi4i4i4_* pp0 = DataTransfer::GetPointer<s_oi4i4i4pi4i4i4ooi4i4i4_>(context, info[0]);
    s_oi4i4i4pi4i4i4ooi4i4i4_ p0 = pp0 ? *pp0 : s_oi4i4i4pi4i4i4ooi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,struct s_oi4i4i4pi4i4i4ooi4i4i4_ p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(UnityEngine.RenderTargetSetup)
static bool w_vts_oi4pi4i4i4ooi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_oi4pi4i4i4ooi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_oi4pi4i4i4ooi4i4_* pp0 = DataTransfer::GetPointer<s_oi4pi4i4i4ooi4i4_>(context, info[0]);
    s_oi4pi4i4i4ooi4i4_ p0 = pp0 ? *pp0 : s_oi4pi4i4i4ooi4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_oi4pi4i4i4ooi4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_cullingResults(UnityEngine.Rendering.CullingResults)
static bool w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_* pp0 = DataTransfer::GetPointer<s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_>(context, info[0]);
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p0 = pp0 ? *pp0 : s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void DrawRenderers(UnityEngine.Rendering.CullingResults, UnityEngine.Rendering.DrawingSettings ByRef, UnityEngine.Rendering.FilteringSettings ByRef)
static bool w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_Ps_i4i4i4u4i4i2i2_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_Ps_i4i4i4u4i4i2i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_* pp0 = DataTransfer::GetPointer<s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_>(context, info[0]);
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p0 = pp0 ? *pp0 : s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i4i4i4u4i4i2i2_* p2 = nullptr; // valuetype ref
    s_i4i4i4u4i4i2i2_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i4i4i4u4i4i2i2_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        

    typedef void (*FuncToCall)(void*,struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_* p1, struct s_i4i4i4u4i4i2i2_* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void DrawRenderers(UnityEngine.Rendering.CullingResults, UnityEngine.Rendering.DrawingSettings ByRef, UnityEngine.Rendering.FilteringSettings ByRef, UnityEngine.Rendering.RenderStateBlock ByRef)
static bool w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_Ps_i4i4i4u4i4i2i2_Ps_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_Ps_i4i4i4u4i4i2i2_Ps_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if (!info[3]->IsObject()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_* pp0 = DataTransfer::GetPointer<s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_>(context, info[0]);
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p0 = pp0 ? *pp0 : s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i4i4i4u4i4i2i2_* p2 = nullptr; // valuetype ref
    s_i4i4i4u4i4i2i2_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i4i4i4u4i4i2i2_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal Pstruct
    s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_* p3 = nullptr; // valuetype ref
    s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_ up3;
    v8::Local<v8::Object> op3;
    if (!info[3].IsEmpty() && info[3]->IsObject()) {
        op3 = info[3]->ToObject(context).ToLocalChecked();
        auto tp3 = op3->Get(context, 0).ToLocalChecked();
        p3 = DataTransfer::GetPointer<s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_>(context, tp3);
    }
    if (!p3) {
        p3 = &up3;
    }
        

    typedef void (*FuncToCall)(void*,struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_* p1, struct s_i4i4i4u4i4i2i2_* p2, struct s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
            
    if (!op3.IsEmpty() && p3 == &up3)
    {
        auto _unused = op3->Set(context, 0, CopyValueType(isolate, context, TIp3, p3, sizeof(*p3)));
    }
    
    return true;
}

// Void DrawRenderers(UnityEngine.Rendering.CullingResults, UnityEngine.Rendering.DrawingSettings ByRef, UnityEngine.Rendering.FilteringSettings ByRef, Unity.Collections.NativeArray`1[UnityEngine.Rendering.ShaderTagId], Unity.Collections.NativeArray`1[UnityEngine.Rendering.RenderStateBlock])
static bool w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_Ps_i4i4i4u4i4i2i2_s_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_Ps_i4i4i4u4i4i2i2_s_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if ((!info[4]->IsObject() || !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_* pp0 = DataTransfer::GetPointer<s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_>(context, info[0]);
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p0 = pp0 ? *pp0 : s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i4i4i4u4i4i2i2_* p2 = nullptr; // valuetype ref
    s_i4i4i4u4i4i2i2_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i4i4i4u4i4i2i2_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp3 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[3]);
    s_Pvi4i4i4pi4i4oi4_ p3 = pp3 ? *pp3 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp4 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[4]);
    s_Pvi4i4i4pi4i4oi4_ p4 = pp4 ? *pp4 : s_Pvi4i4i4pi4i4oi4_ {};

    typedef void (*FuncToCall)(void*,struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_* p1, struct s_i4i4i4u4i4i2i2_* p2, struct s_Pvi4i4i4pi4i4oi4_ p3, struct s_Pvi4i4i4pi4i4oi4_ p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void DrawRenderers(UnityEngine.Rendering.CullingResults, UnityEngine.Rendering.DrawingSettings ByRef, UnityEngine.Rendering.FilteringSettings ByRef, UnityEngine.Rendering.ShaderTagId, Boolean, Unity.Collections.NativeArray`1[UnityEngine.Rendering.ShaderTagId], Unity.Collections.NativeArray`1[UnityEngine.Rendering.RenderStateBlock])
static bool w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_Ps_i4i4i4u4i4i2i2_s_i4_bs_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_Ps_i4i4i4u4i4i2i2_s_i4_bs_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp5 = wrapData->TypeInfos[4];
    auto TIp6 = wrapData->TypeInfos[5];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsObject()) return false;
        if (!info[2]->IsObject()) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if ((!info[5]->IsObject() || !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>())))) return false;
        if ((!info[6]->IsObject() || !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_* pp0 = DataTransfer::GetPointer<s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_>(context, info[0]);
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p0 = pp0 ? *pp0 : s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ {};
    // JSValToCSVal Pstruct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_* p1 = nullptr; // valuetype ref
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_ up1;
    v8::Local<v8::Object> op1;
    if (!info[1].IsEmpty() && info[1]->IsObject()) {
        op1 = info[1]->ToObject(context).ToLocalChecked();
        auto tp1 = op1->Get(context, 0).ToLocalChecked();
        p1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_>(context, tp1);
    }
    if (!p1) {
        p1 = &up1;
    }
        
    // JSValToCSVal Pstruct
    s_i4i4i4u4i4i2i2_* p2 = nullptr; // valuetype ref
    s_i4i4i4u4i4i2i2_ up2;
    v8::Local<v8::Object> op2;
    if (!info[2].IsEmpty() && info[2]->IsObject()) {
        op2 = info[2]->ToObject(context).ToLocalChecked();
        auto tp2 = op2->Get(context, 0).ToLocalChecked();
        p2 = DataTransfer::GetPointer<s_i4i4i4u4i4i2i2_>(context, tp2);
    }
    if (!p2) {
        p2 = &up2;
    }
        
    // JSValToCSVal struct
    s_i4_* pp3 = DataTransfer::GetPointer<s_i4_>(context, info[3]);
    s_i4_ p3 = pp3 ? *pp3 : s_i4_ {};
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp5 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[5]);
    s_Pvi4i4i4pi4i4oi4_ p5 = pp5 ? *pp5 : s_Pvi4i4i4pi4i4oi4_ {};
    // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp6 = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[6]);
    s_Pvi4i4i4pi4i4oi4_ p6 = pp6 ? *pp6 : s_Pvi4i4i4pi4i4oi4_ {};

    typedef void (*FuncToCall)(void*,struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_* p1, struct s_i4i4i4u4i4i2i2_* p2, struct s_i4_ p3, bool p4, struct s_Pvi4i4i4pi4i4oi4_ p5, struct s_Pvi4i4i4pi4i4oi4_ p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    if (!op1.IsEmpty() && p1 == &up1)
    {
        auto _unused = op1->Set(context, 0, CopyValueType(isolate, context, TIp1, p1, sizeof(*p1)));
    }
            
    if (!op2.IsEmpty() && p2 == &up2)
    {
        auto _unused = op2->Set(context, 0, CopyValueType(isolate, context, TIp2, p2, sizeof(*p2)));
    }
    
    return true;
}

// Void .ctor(UnityEngine.Rendering.CullingResults, Int32)
static bool w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_* pp0 = DataTransfer::GetPointer<s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_>(context, info[0]);
    s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p0 = pp0 ? *pp0 : s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void WaitOnAsyncGraphicsFence(UnityEngine.Rendering.GraphicsFence)
static bool w_vts_pi4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_pi4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_pi4i4_* pp0 = DataTransfer::GetPointer<s_pi4i4_>(context, info[0]);
    s_pi4i4_ p0 = pp0 ? *pp0 : s_pi4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_pi4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void WaitOnAsyncGraphicsFence(UnityEngine.Rendering.GraphicsFence, UnityEngine.Rendering.SynchronisationStage)
static bool w_vts_pi4i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_pi4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_pi4i4_* pp0 = DataTransfer::GetPointer<s_pi4i4_>(context, info[0]);
    s_pi4i4_ p0 = pp0 ? *pp0 : s_pi4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_pi4i4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void OnGraphStart(UnityEngine.Playables.Playable)
static bool w_vts_pu4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_pu4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_pu4_* pp0 = DataTransfer::GetPointer<s_pu4_>(context, info[0]);
    s_pu4_ p0 = pp0 ? *pp0 : s_pu4_ {};

    typedef void (*FuncToCall)(void*,struct s_pu4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void OnBehaviourPlay(UnityEngine.Playables.Playable, UnityEngine.Playables.FrameData)
static bool w_vts_pu4_s_u8r8r4r4r8r4r4i4pu4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_pu4_s_u8r8r4r4r8r4r4i4pu4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_pu4_* pp0 = DataTransfer::GetPointer<s_pu4_>(context, info[0]);
    s_pu4_ p0 = pp0 ? *pp0 : s_pu4_ {};
    // JSValToCSVal struct
    s_u8r8r4r4r8r4r4i4pu4_* pp1 = DataTransfer::GetPointer<s_u8r8r4r4r8r4r4i4pu4_>(context, info[1]);
    s_u8r8r4r4r8r4r4i4pu4_ p1 = pp1 ? *pp1 : s_u8r8r4r4r8r4r4i4pu4_ {};

    typedef void (*FuncToCall)(void*,struct s_pu4_ p0, struct s_u8r8r4r4r8r4r4i4pu4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void ProcessFrame(UnityEngine.Playables.Playable, UnityEngine.Playables.FrameData, System.Object)
static bool w_vts_pu4_s_u8r8r4r4r8r4r4i4pu4_O(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_pu4_s_u8r8r4r4r8r4r4i4pu4_O");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_pu4_* pp0 = DataTransfer::GetPointer<s_pu4_>(context, info[0]);
    s_pu4_ p0 = pp0 ? *pp0 : s_pu4_ {};
    // JSValToCSVal struct
    s_u8r8r4r4r8r4r4i4pu4_* pp1 = DataTransfer::GetPointer<s_u8r8r4r4r8r4r4i4pu4_>(context, info[1]);
    s_u8r8r4r4r8r4r4i4pu4_ p1 = pp1 ? *pp1 : s_u8r8r4r4r8r4r4i4pu4_ {};
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,struct s_pu4_ p0, struct s_u8r8r4r4r8r4r4i4pu4_ p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void DrawRendererList(UnityEngine.Rendering.RendererUtils.RendererList)
static bool w_vts_pu4u4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_pu4u4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_pu4u4_* pp0 = DataTransfer::GetPointer<s_pu4u4_>(context, info[0]);
    s_pu4u4_ p0 = pp0 ? *pp0 : s_pu4u4_ {};

    typedef void (*FuncToCall)(void*,struct s_pu4u4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_xy(UnityEngine.Vector2)
static bool w_vts_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetCustomInput(UnityEngine.Vector2, Boolean)
static bool w_vts_r4r4_b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4_b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_r4r4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetCustomInput(UnityEngine.Vector2, Boolean, Boolean)
static bool w_vts_r4r4_bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4_bb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_r4r4_ p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Add(UnityEngine.Vector2, UnityEngine.Vector2)
static bool w_vts_r4r4_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p0 = pp0 ? *pp0 : s_r4r4_ {};
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4_ p0, struct s_r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void StartVideoModeAsync(UnityEngine.Windows.WebCam.CameraParameters, AudioState, OnVideoModeStartedCallback)
static bool w_vts_r4r4i4i4i4_i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4i4i4i4_i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4i4i4i4_* pp0 = DataTransfer::GetPointer<s_r4r4i4i4i4_>(context, info[0]);
    s_r4r4i4i4i4_ p0 = pp0 ? *pp0 : s_r4r4i4i4i4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,struct s_r4r4i4i4i4_ p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void StartPhotoModeAsync(UnityEngine.Windows.WebCam.CameraParameters, OnPhotoModeStartedCallback)
static bool w_vts_r4r4i4i4i4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4i4i4i4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4i4i4i4_* pp0 = DataTransfer::GetPointer<s_r4r4i4i4i4_>(context, info[0]);
    s_r4r4i4i4i4_ p0 = pp0 ? *pp0 : s_r4r4i4i4i4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,struct s_r4r4i4i4i4_ p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_position(UnityEngine.Vector3)
static bool w_vts_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void SetTargetPos(UnityEngine.Vector3, Boolean)
static bool w_vts_r4r4r4_Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_Db");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (length > 1 && !converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal primitive with default
    bool p1 = OptionalParameter<bool>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Translate(UnityEngine.Vector3, UnityEngine.Space)
static bool w_vts_r4r4r4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Translate(UnityEngine.Vector3, UnityEngine.Transform)
static bool w_vts_r4r4r4_o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void LerpTo(UnityEngine.Vector3, Single)
static bool w_vts_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Rotate(UnityEngine.Vector3, Single, UnityEngine.Space)
static bool w_vts_r4r4r4_r4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_r4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, float p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void AddVert(UnityEngine.Vector3, UnityEngine.Color32)
static bool w_vts_r4r4r4_s_i4u1u1u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_i4u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_i4u1u1u1u1_* pp1 = DataTransfer::GetPointer<s_i4u1u1u1u1_>(context, info[1]);
    s_i4u1u1u1u1_ p1 = pp1 ? *pp1 : s_i4u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_i4u1u1u1u1_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddVert(UnityEngine.Vector3, UnityEngine.Color32, UnityEngine.Vector2)
static bool w_vts_r4r4r4_s_i4u1u1u1u1_s_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_i4u1u1u1u1_s_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_i4u1u1u1u1_* pp1 = DataTransfer::GetPointer<s_i4u1u1u1u1_>(context, info[1]);
    s_i4u1u1u1u1_ p1 = pp1 ? *pp1 : s_i4u1u1u1u1_ {};
    // JSValToCSVal struct
    s_r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4_>(context, info[2]);
    s_r4r4_ p2 = pp2 ? *pp2 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_i4u1u1u1u1_ p1, struct s_r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetMinMax(UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_vts_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void RotateAround(UnityEngine.Vector3, UnityEngine.Vector3, Single)
static bool w_vts_r4r4r4_s_r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Set3Points(UnityEngine.Vector3, UnityEngine.Vector3, UnityEngine.Vector3)
static bool w_vts_r4r4r4_s_r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[1]);
    s_r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4_ p1, struct s_r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetPositionAndRotation(UnityEngine.Vector3, UnityEngine.Quaternion)
static bool w_vts_r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddDirectionalLight(UnityEngine.Vector3, UnityEngine.Color, Single)
static bool w_vts_r4r4r4_s_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4r4_ p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetTRS(UnityEngine.Vector3, UnityEngine.Quaternion, UnityEngine.Vector3)
static bool w_vts_r4r4r4_s_r4r4r4r4_s_r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4_s_r4r4r4r4_s_r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4_>(context, info[2]);
    s_r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4_ p0, struct s_r4r4r4r4_ p1, struct s_r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void set_color(UnityEngine.Color)
static bool w_vts_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Tint(UnityEngine.Color, Single)
static bool w_vts_r4r4r4r4_Dr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_Dr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (length > 1 && !converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(context, info, method, 1);
                

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void ConfigureClear(UnityEngine.Color, Single, UInt32)
static bool w_vts_r4r4r4r4_Dr4Du4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_Dr4Du4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (length > 1 && !converter::Converter<float>::accept(context, info[1])) return false;
        if (length > 2 && !converter::Converter<uint32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal primitive with default
    float p1 = OptionalParameter<float>::GetPrimitive(context, info, method, 1);
                
    // JSValToCSVal primitive with default
    uint32_t p2 = OptionalParameter<uint32_t>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, float p1, uint32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ScrollToView(UnityEngine.Rect, Boolean, Boolean)
static bool w_vts_r4r4r4r4_bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_bb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, bool p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ReadPixels(UnityEngine.Rect, Int32, Int32)
static bool w_vts_r4r4r4r4_i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ReadPixels(UnityEngine.Rect, Int32, Int32, Boolean)
static bool w_vts_r4r4r4r4_i4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_i4i4b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, int32_t p1, int32_t p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void LerpRotation(UnityEngine.Quaternion, Single)
static bool w_vts_r4r4r4r4_r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void CalculateFrustumCorners(UnityEngine.Rect, Single, MonoOrStereoscopicEye, UnityEngine.Vector3[])
static bool w_vts_r4r4r4r4_r4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_r4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp3 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, float p1, int32_t p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void AddQuad(UnityEngine.Rect, UnityEngine.Color32)
static bool w_vts_r4r4r4r4_s_i4u1u1u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_s_i4u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_i4u1u1u1u1_* pp1 = DataTransfer::GetPointer<s_i4u1u1u1u1_>(context, info[1]);
    s_i4u1u1u1u1_ p1 = pp1 ? *pp1 : s_i4u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, struct s_i4u1u1u1u1_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddQuad(UnityEngine.Rect, UnityEngine.Color32, UnityEngine.Rect)
static bool w_vts_r4r4r4r4_s_i4u1u1u1u1_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_s_i4u1u1u1u1_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_i4u1u1u1u1_* pp1 = DataTransfer::GetPointer<s_i4u1u1u1u1_>(context, info[1]);
    s_i4u1u1u1u1_ p1 = pp1 ? *pp1 : s_i4u1u1u1u1_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, struct s_i4u1u1u1u1_ p1, struct s_r4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(UnityEngine.Vector4, UnityEngine.Vector4, UnityEngine.Vector4, UnityEngine.Vector4)
static bool w_vts_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[2]);
    s_r4r4r4r4_ p2 = pp2 ? *pp2 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[3]);
    s_r4r4r4r4_ p3 = pp3 ? *pp3 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4_ p0, struct s_r4r4r4r4_ p1, struct s_r4r4r4r4_ p2, struct s_r4r4r4r4_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Encapsulate(UnityEngine.Bounds)
static bool w_vts_r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Create(FairyGUI.GPathPoint, FairyGUI.GPathPoint)
static bool w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4i4b_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4i4b_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4i4b_ p0, struct s_r4r4r4r4r4r4r4r4r4i4b_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void Create(FairyGUI.GPathPoint, FairyGUI.GPathPoint, FairyGUI.GPathPoint)
static bool w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4i4b_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4i4b_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[2]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p2 = pp2 ? *pp2 : s_r4r4r4r4r4r4r4r4r4i4b_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4i4b_ p0, struct s_r4r4r4r4r4r4r4r4r4i4b_ p1, struct s_r4r4r4r4r4r4r4r4r4i4b_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Create(FairyGUI.GPathPoint, FairyGUI.GPathPoint, FairyGUI.GPathPoint, FairyGUI.GPathPoint)
static bool w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
        if ((!info[3]->IsObject() || !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4i4b_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4i4b_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp2 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[2]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p2 = pp2 ? *pp2 : s_r4r4r4r4r4r4r4r4r4i4b_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4i4b_* pp3 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4i4b_>(context, info[3]);
    s_r4r4r4r4r4r4r4r4r4i4b_ p3 = pp3 ? *pp3 : s_r4r4r4r4r4r4r4r4r4i4b_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4i4b_ p0, struct s_r4r4r4r4r4r4r4r4r4i4b_ p1, struct s_r4r4r4r4r4r4r4r4r4i4b_ p2, struct s_r4r4r4r4r4r4r4r4r4i4b_ p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void set_cullingMatrix(UnityEngine.Matrix4x4)
static bool w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void DrawProcedural(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, Int32)
static bool w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, void* p1, int32_t p2, int32_t p3, int32_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawProcedural(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, Int32, Int32)
static bool w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, void* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void DrawProcedural(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, Int32, Int32, UnityEngine.MaterialPropertyBlock)
static bool w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp6 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, void* p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5, void* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void DrawProceduralIndirect(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, UnityEngine.ComputeBuffer)
static bool w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, void* p1, int32_t p2, int32_t p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void DrawProceduralIndirect(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, UnityEngine.ComputeBuffer, Int32)
static bool w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, void* p1, int32_t p2, int32_t p3, void* p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void DrawProceduralIndirect(UnityEngine.Matrix4x4, UnityEngine.Material, Int32, UnityEngine.MeshTopology, UnityEngine.ComputeBuffer, Int32, UnityEngine.MaterialPropertyBlock)
static bool w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp4 = wrapData->TypeInfos[2];
    auto TIp6 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, void* p1, int32_t p2, int32_t p3, void* p4, int32_t p5, void* p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void SetViewProjectionMatrices(UnityEngine.Matrix4x4, UnityEngine.Matrix4x4)
static bool w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void set_sortingSettings(UnityEngine.Rendering.SortingSettings)
static bool w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_cameraProperties(UnityEngine.Rendering.CameraProperties)
static bool w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_* pp0 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_ p0 = pp0 ? *pp0 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_ {};

    typedef void (*FuncToCall)(void*,struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void Enable(UnityEngine.Rendering.ShaderKeyword)
static bool w_vts_su4bbb_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_su4bbb_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_su4bbb_* pp0 = DataTransfer::GetPointer<s_su4bbb_>(context, info[0]);
    s_su4bbb_ p0 = pp0 ? *pp0 : s_su4bbb_ {};

    typedef void (*FuncToCall)(void*,struct s_su4bbb_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_depthState(UnityEngine.Rendering.DepthState)
static bool w_vts_u1i1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_u1i1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u1i1_* pp0 = DataTransfer::GetPointer<s_u1i1_>(context, info[0]);
    s_u1i1_ p0 = pp0 ? *pp0 : s_u1i1_ {};

    typedef void (*FuncToCall)(void*,struct s_u1i1_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_blendState0(UnityEngine.Rendering.RenderTargetBlendState)
static bool w_vts_u1u1u1u1u1u1u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<s_u1u1u1u1u1u1u1u1_>(context, info[0]);
    s_u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : s_u1u1u1u1u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,struct s_u1u1u1u1u1u1u1u1_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_stencilState(UnityEngine.Rendering.StencilState)
static bool w_vts_u1u1u1u1u1u1u1u1u1u1u1u1_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_u1u1u1u1u1u1u1u1u1u1u1u1_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u1u1u1u1u1u1u1u1u1u1u1u1_* pp0 = DataTransfer::GetPointer<s_u1u1u1u1u1u1u1u1u1u1u1u1_>(context, info[0]);
    s_u1u1u1u1u1u1u1u1u1u1u1u1_ p0 = pp0 ? *pp0 : s_u1u1u1u1u1u1u1u1u1u1u1u1_ {};

    typedef void (*FuncToCall)(void*,struct s_u1u1u1u1u1u1u1u1u1u1u1u1_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_blendState(UnityEngine.Rendering.BlendState)
static bool w_vts_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_* pp0 = DataTransfer::GetPointer<s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_>(context, info[0]);
    s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_ p0 = pp0 ? *pp0 : s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_ {};

    typedef void (*FuncToCall)(void*,struct s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void set_hash(UnityEngine.Hash128)
static bool w_vts_u8u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vts_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if ((!info[0]->IsObject() || !IsAssignableFrom(TIp0, GetTypeId(info[0].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal struct
    s_u8u8_* pp0 = DataTransfer::GetPointer<s_u8u8_>(context, info[0]);
    s_u8u8_ p0 = pp0 ? *pp0 : s_u8u8_ {};

    typedef void (*FuncToCall)(void*,struct s_u8u8_ p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void ToggleKeyword(System.String, Boolean)
static bool w_vtsb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsb");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void OpenKeyboard(System.String, Boolean, Boolean, Boolean, Boolean, System.String, Int32, Boolean)
static bool w_vtsbbbbsi4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsbbbbsi4b");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp5 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!info[5]->IsString() && !info[5]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal s
    v8::String::Utf8Value tp5(isolate, info[5]);
    void* p5 = CStringToCSharpString(*tp5);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, bool p2, bool p3, bool p4, void* p5, int32_t p6, bool p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void .ctor(System.String, Boolean, Int32)
static bool w_vtsbi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsbi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, bool p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void InitDB(System.String, Boolean, System.String, Int32)
static bool w_vtsbsDi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsbsDi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,void* p0, bool p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void AddPageAt(System.String, Int32)
static bool w_vtsi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsi4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.String, UnityEngine.Search.SearchViewFlags, System.Type[])
static bool w_vtsi4Vo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsi4Vo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && !info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal ref params
    void* p2 = RestArguments<void*>::PackRef(context, info, TIp2, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(System.String, UnityEngine.TouchScreenKeyboardType, Boolean, Boolean, Boolean, Boolean, System.String, Int32)
static bool w_vtsi4bbbbsi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsi4bbbbsi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp6 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!converter::Converter<bool>::accept(context, info[5])) return false;
        if (!info[6]->IsString() && !info[6]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(context, info[5]);
    // JSValToCSVal s
    v8::String::Utf8Value tp6(isolate, info[6]);
    void* p6 = CStringToCSharpString(*tp6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, bool p2, bool p3, bool p4, bool p5, void* p6, int32_t p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void .ctor(System.String, Int32, Int32)
static bool w_vtsi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Dispatch(System.String, Int32, Int32, Int32, UnityEngine.Camera)
static bool w_vtsi4i4i4Do(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsi4i4i4Do");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp4 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
        if (length > 4 && !info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);
    // JSValToCSVal ref  with default
    void* p4 = OptionalParameter<void*>::GetRefType(context, info, method, 4, TIp4);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, int32_t p2, int32_t p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void TakePhotoAsync(System.String, UnityEngine.Windows.WebCam.PhotoCaptureFileOutputFormat, OnCapturedToDiskCallback)
static bool w_vtsi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void .ctor(System.String, UnityEngine.Search.SearchViewFlags, System.String, System.Type[])
static bool w_vtsi4sVo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsi4sVo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!info[3]->IsNullOrUndefined() && !info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal ref params
    void* p3 = RestArguments<void*>::PackRef(context, info, TIp3, 3);
                

    typedef void (*FuncToCall)(void*,void* p0, int32_t p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void StartGamePlay(System.String, Int64, Int64)
static bool w_vtsi8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsi8i8");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, int64_t p1, int64_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetShaderAndTexture(System.String, FairyGUI.NTexture)
static bool w_vtso(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtso");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void getTextrue(System.String, System.Action`1[UnityEngine.Texture], Boolean)
static bool w_vtsoDb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsoDb");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (length > 2 && !converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal primitive with default
    bool p2 = OptionalParameter<bool>::GetPrimitive(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetValue(System.String, System.Action, System.String)
static bool w_vtsoDs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsoDs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (length > 2 && !info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal string  with default
    void* p2 = OptionalParameter<void*>::GetString(context, info, method, 2);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SaveEditorMap(System.String, Puerts.ArrayBuffer, Boolean)
static bool w_vtsob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsob");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetTexture(System.String, UnityEngine.RenderTexture, UnityEngine.Rendering.RenderTextureSubElement)
static bool w_vtsoi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsoi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetConstantBuffer(System.String, UnityEngine.ComputeBuffer, Int32, Int32)
static bool w_vtsoi4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsoi4i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SetValue(System.String, System.Action, System.Action, System.String, System.String)
static bool w_vtsooDsDs(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsooDsDs");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (length > 3 && !info[3]->IsString() && !info[3]->IsNullOrUndefined()) return false;
        if (length > 4 && !info[4]->IsString() && !info[4]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal string  with default
    void* p3 = OptionalParameter<void*>::GetString(context, info, method, 3);
                
    // JSValToCSVal string  with default
    void* p4 = OptionalParameter<void*>::GetString(context, info, method, 4);
                

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, void* p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void .ctor(System.String, UnityEngine.GameObject, System.Type, Int32)
static bool w_vtsooi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsooi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void Parse(System.String, FairyGUI.TextFormat, System.Collections.Generic.List`1[FairyGUI.Utils.HtmlElement], FairyGUI.Utils.HtmlParseOptions)
static bool w_vtsooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void .ctor(System.String, GCore.DBPool, GCore.DBPool, GCore.DBPool, GCore.EthereumUtil, System.Collections.Generic.Dictionary`2[System.String,System.Byte[]], System.Func`2[System.String,System.Byte[]], GCore.GIMode, GCore.IRedisConnect)
static bool w_vtsooooooi4o(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsooooooi4o");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];
    auto TIp4 = wrapData->TypeInfos[4];
    auto TIp5 = wrapData->TypeInfos[5];
    auto TIp6 = wrapData->TypeInfos[6];
    auto TIp8 = wrapData->TypeInfos[7];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
        if (!info[5]->IsNullOrUndefined() && (!info[5]->IsObject() || (info[5]->IsFunction() ? !IsDelegate(TIp5) : !IsAssignableFrom(TIp5, GetTypeId(info[5].As<v8::Object>()))))) return false;
        if (!info[6]->IsNullOrUndefined() && (!info[6]->IsObject() || (info[6]->IsFunction() ? !IsDelegate(TIp6) : !IsAssignableFrom(TIp6, GetTypeId(info[6].As<v8::Object>()))))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[7])) return false;
        if (!info[8]->IsNullOrUndefined() && (!info[8]->IsObject() || (info[8]->IsFunction() ? !IsDelegate(TIp8) : !IsAssignableFrom(TIp8, GetTypeId(info[8].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);
    // JSValToCSVal o/O
    void* p5 = JsValueToCSRef(context, info[5], TIp5);
    // JSValToCSVal o/O
    void* p6 = JsValueToCSRef(context, info[6], TIp6);
    // JSValToCSVal P any
    int32_t p7 = converter::Converter<int32_t>::toCpp(context, info[7]);
    // JSValToCSVal o/O
    void* p8 = JsValueToCSRef(context, info[8], TIp8);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, int32_t p7, void* p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void RegisterCursor(System.String, UnityEngine.Texture2D, UnityEngine.Vector2)
static bool w_vtsos_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsos_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal struct
    s_r4r4_* pp2 = DataTransfer::GetPointer<s_r4r4_>(context, info[2]);
    s_r4r4_ p2 = pp2 ? *pp2 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, void* p1, struct s_r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ShowTooltips(System.String, Single)
static bool w_vtsr4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsr4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,void* p0, float p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AddBlendShapeFrame(System.String, Single, UnityEngine.Vector3[], UnityEngine.Vector3[], UnityEngine.Vector3[])
static bool w_vtsr4ooo(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsr4ooo");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];
    auto TIp3 = wrapData->TypeInfos[2];
    auto TIp4 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!info[2]->IsNullOrUndefined() && (!info[2]->IsObject() || (info[2]->IsFunction() ? !IsDelegate(TIp2) : !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>()))))) return false;
        if (!info[3]->IsNullOrUndefined() && (!info[3]->IsObject() || (info[3]->IsFunction() ? !IsDelegate(TIp3) : !IsAssignableFrom(TIp3, GetTypeId(info[3].As<v8::Object>()))))) return false;
        if (!info[4]->IsNullOrUndefined() && (!info[4]->IsObject() || (info[4]->IsFunction() ? !IsDelegate(TIp4) : !IsAssignableFrom(TIp4, GetTypeId(info[4].As<v8::Object>()))))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal o/O
    void* p2 = JsValueToCSRef(context, info[2], TIp2);
    // JSValToCSVal o/O
    void* p3 = JsValueToCSRef(context, info[3], TIp3);
    // JSValToCSVal o/O
    void* p4 = JsValueToCSRef(context, info[4], TIp4);

    typedef void (*FuncToCall)(void*,void* p0, float p1, void* p2, void* p3, void* p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void InvokeRepeating(System.String, Single, Single)
static bool w_vtsr4r4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsr4r4");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<float>::accept(context, info[1])) return false;
        if (!converter::Converter<float>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    float p1 = converter::Converter<float>::toCpp(context, info[1]);
    // JSValToCSVal P any
    float p2 = converter::Converter<float>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, float p1, float p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetItemText(System.String, System.String)
static bool w_vtss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetGlobalTexture(System.String, UnityEngine.Rendering.RenderTargetIdentifier)
static bool w_vtss_i4i4i4pi4i4i4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtss_i4i4i4pi4i4i4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_i4i4i4pi4i4i4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetGlobalTexture(System.String, UnityEngine.Rendering.RenderTargetIdentifier, UnityEngine.Rendering.RenderTextureSubElement)
static bool w_vtss_i4i4i4pi4i4i4_i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtss_i4i4i4pi4i4i4_i4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_i4i4i4pi4i4i4_* pp1 = DataTransfer::GetPointer<s_i4i4i4pi4i4i4_>(context, info[1]);
    s_i4i4i4pi4i4i4_ p1 = pp1 ? *pp1 : s_i4i4i4pi4i4i4_ {};
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, struct s_i4i4i4pi4i4i4_ p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetTextureOffset(System.String, UnityEngine.Vector2)
static bool w_vtss_r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtss_r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4_>(context, info[1]);
    s_r4r4_ p1 = pp1 ? *pp1 : s_r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetVector(System.String, UnityEngine.Vector4)
static bool w_vtss_r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtss_r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void SetMatrix(System.String, UnityEngine.Matrix4x4)
static bool w_vtss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.String, UnityEngine.Hash128)
static bool w_vtss_u8u8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtss_u8u8_");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal struct
    s_u8u8_* pp1 = DataTransfer::GetPointer<s_u8u8_>(context, info[1]);
    s_u8u8_ p1 = pp1 ? *pp1 : s_u8u8_ {};

    typedef void (*FuncToCall)(void*,void* p0, struct s_u8u8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void .ctor(System.String, System.String, UnityEngine.Search.SearchViewFlags)
static bool w_vtssi4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtssi4");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void ListenNFTTransfer(System.String, System.String, System.String)
static bool w_vtsss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void Update(System.String, System.String, System.String, System.String)
static bool w_vtssss(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtssss");
    
    auto TIp0 = wrapData->TypeInfos[0];
    auto TIp1 = wrapData->TypeInfos[1];
    auto TIp2 = wrapData->TypeInfos[2];
    auto TIp3 = wrapData->TypeInfos[3];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!info[1]->IsString() && !info[1]->IsNullOrUndefined()) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
        if (!info[3]->IsString() && !info[3]->IsNullOrUndefined()) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal s
    v8::String::Utf8Value tp1(isolate, info[1]);
    void* p1 = CStringToCSharpString(*tp1);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);
    // JSValToCSVal s
    v8::String::Utf8Value tp3(isolate, info[3]);
    void* p3 = CStringToCSharpString(*tp3);

    typedef void (*FuncToCall)(void*,void* p0, void* p1, void* p2, void* p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void C_AddMeshCollider(System.String, UInt32, Int32, Int64, Boolean, Boolean, Int64, Boolean)
static bool w_vtsu4i4i8bbi8b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtsu4i4i8bbi8b");
    
    auto TIp0 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!info[0]->IsString() && !info[0]->IsNullOrUndefined()) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!converter::Converter<bool>::accept(context, info[5])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[6])) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal s
    v8::String::Utf8Value tp0(isolate, info[0]);
    void* p0 = CStringToCSharpString(*tp0);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int64_t p6 = converter::Converter<int64_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void*,void* p0, uint32_t p1, int32_t p2, int64_t p3, bool p4, bool p5, int64_t p6, bool p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void set_readMask(Byte)
static bool w_vtu1(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu1");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint8_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,uint8_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(Byte, Byte, Byte, Byte)
static bool w_vtu1u1u1u1(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu1u1u1u1");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<uint8_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint8_t>::accept(context, info[1])) return false;
        if (!converter::Converter<uint8_t>::accept(context, info[2])) return false;
        if (!converter::Converter<uint8_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    uint8_t p2 = converter::Converter<uint8_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    uint8_t p3 = converter::Converter<uint8_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,uint8_t p0, uint8_t p1, uint8_t p2, uint8_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SendMsg(UInt16, Byte[], Int32, Int32)
static bool w_vtu2oDi4Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu2oDi4Di4");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 2) return false;
        if (!converter::Converter<uint16_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (length > 2 && !converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (length > 3 && !converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal primitive with default
    int32_t p2 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 2);
                
    // JSValToCSVal primitive with default
    int32_t p3 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 3);
                

    typedef void (*FuncToCall)(void*,uint16_t p0, void* p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void SendBuffer(UInt16, Puerts.ArrayBuffer, Boolean)
static bool w_vtu2ob(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu2ob");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<uint16_t>::accept(context, info[0])) return false;
        if (!info[1]->IsNullOrUndefined() && (!info[1]->IsObject() || (info[1]->IsFunction() ? !IsDelegate(TIp1) : !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>()))))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(context, info[0]);
    // JSValToCSVal o/O
    void* p1 = JsValueToCSRef(context, info[1], TIp1);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,uint16_t p0, void* p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetColor(UInt32)
static bool w_vtu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,uint32_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void EnterClipping(UInt32, Boolean)
static bool w_vtu4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,uint32_t p0, bool p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void C_FreezePhyRot(UInt32, Boolean, Boolean, Boolean)
static bool w_vtu4bbb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4bbb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<bool>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    bool p1 = converter::Converter<bool>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,uint32_t p0, bool p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void C_SetPhyLayer(UInt32, Int32)
static bool w_vtu4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int32_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void C_SetActionBlacklist(UInt32, Int32, Boolean)
static bool w_vtu4i4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void SetGridUnit(UInt32, Int32, Int32, Int32)
static bool w_vtu4i4i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i4i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int32_t p3 = converter::Converter<int32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int32_t p1, int32_t p2, int32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void C_AddRVOObstacle(UInt32, Int32, Int64, Int64)
static bool w_vtu4i4i8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i4i8i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int32_t p1, int64_t p2, int64_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void C_AddRVOAgent(UInt32, Int32, Int64, Int64, Int32, Int64)
static bool w_vtu4i4i8i8i4i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i4i8i8i4i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int64_t p5 = converter::Converter<int64_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int32_t p1, int64_t p2, int64_t p3, int32_t p4, int64_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void C_AddCrowd(UInt32, Int32, Int64, Int64, Int64, Int64, Int32)
static bool w_vtu4i4i8i8i8i8Di4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i4i8i8i8i8Di4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 6) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[5])) return false;
        if (length > 6 && !converter::Converter<int32_t>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int32_t p1 = converter::Converter<int32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int64_t p5 = converter::Converter<int64_t>::toCpp(context, info[5]);
    // JSValToCSVal primitive with default
    int32_t p6 = OptionalParameter<int32_t>::GetPrimitive(context, info, method, 6);
                

    typedef void (*FuncToCall)(void*,uint32_t p0, int32_t p1, int64_t p2, int64_t p3, int64_t p4, int64_t p5, int32_t p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void C_SetWorldSt(UInt32, Int64)
static bool w_vtu4i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void C_SetAIGoal(UInt32, Int64, Boolean, Boolean)
static bool w_vtu4i8bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8bb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, bool p2, bool p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void C_AddSphereCollider(UInt32, Int64, Boolean, Boolean, Int64, Int32, Int64, Boolean)
static bool w_vtu4i8bbi8i4i8b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8bbi8i4i8b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[6])) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int64_t p6 = converter::Converter<int64_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, bool p2, bool p3, int64_t p4, int32_t p5, int64_t p6, bool p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void C_AddCapsuleCollider(UInt32, Int64, Int64, Boolean, Boolean, Int64, Int32, Int64, Boolean)
static bool w_vtu4i8i8bbi8i4i8b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8i8bbi8i4i8b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 9) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<bool>::accept(context, info[4])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[7])) return false;
        if (!converter::Converter<bool>::accept(context, info[8])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    bool p4 = converter::Converter<bool>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int64_t p5 = converter::Converter<int64_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int32_t p6 = converter::Converter<int32_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int64_t p7 = converter::Converter<int64_t>::toCpp(context, info[7]);
    // JSValToCSVal P any
    bool p8 = converter::Converter<bool>::toCpp(context, info[8]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, int64_t p2, bool p3, bool p4, int64_t p5, int32_t p6, int64_t p7, bool p8, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7, p8,  method);

    
    return true;
}

// Void C_SetPosition(UInt32, Int64, Int64, Int64)
static bool w_vtu4i8i8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8i8i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, int64_t p2, int64_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void C_SetRVOVelocity(UInt32, Int64, Int64, Int64, Boolean)
static bool w_vtu4i8i8i8Db(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8i8i8Db");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (true) {
        auto length = info.Length();
        if (length < 4) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (length > 4 && !converter::Converter<bool>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal primitive with default
    bool p4 = OptionalParameter<bool>::GetPrimitive(context, info, method, 4);
                

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, int64_t p2, int64_t p3, bool p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void C_SetRotation(UInt32, Int64, Int64, Int64, Int64)
static bool w_vtu4i8i8i8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8i8i8i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 5) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[4])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(context, info[4]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, int64_t p2, int64_t p3, int64_t p4, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4,  method);

    
    return true;
}

// Void MoveTo(UInt32, Int64, Int64, Int64, Int64, Boolean, Boolean)
static bool w_vtu4i8i8i8i8bb(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8i8i8i8bb");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 7) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[4])) return false;
        if (!converter::Converter<bool>::accept(context, info[5])) return false;
        if (!converter::Converter<bool>::accept(context, info[6])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(context, info[5]);
    // JSValToCSVal P any
    bool p6 = converter::Converter<bool>::toCpp(context, info[6]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, int64_t p2, int64_t p3, int64_t p4, bool p5, bool p6, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6,  method);

    
    return true;
}

// Void MoveToWithRad(UInt32, Int64, Int64, Int64, Int64, Boolean, Int64, Int64)
static bool w_vtu4i8i8i8i8bi8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4i8i8i8i8bi8i8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[4])) return false;
        if (!converter::Converter<bool>::accept(context, info[5])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[6])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[7])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    int64_t p1 = converter::Converter<int64_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    bool p5 = converter::Converter<bool>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int64_t p6 = converter::Converter<int64_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    int64_t p7 = converter::Converter<int64_t>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void*,uint32_t p0, int64_t p1, int64_t p2, int64_t p3, int64_t p4, bool p5, int64_t p6, int64_t p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void C_SetCrowdVelocity(UInt32, GCore.FVector3)
static bool w_vtu4s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4s_i8i8i8_");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};

    typedef void (*FuncToCall)(void*,uint32_t p0, struct s_i8i8i8_ p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void C_AddBoxCollider(UInt32, GCore.FVector3, Boolean, Boolean, Int64, Int32, Int64, Boolean)
static bool w_vtu4s_i8i8i8_bbi8i4i8b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4s_i8i8i8_bbi8i4i8b");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 8) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
        if (!converter::Converter<bool>::accept(context, info[3])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[6])) return false;
        if (!converter::Converter<bool>::accept(context, info[7])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);
    // JSValToCSVal P any
    bool p3 = converter::Converter<bool>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int64_t p4 = converter::Converter<int64_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);
    // JSValToCSVal P any
    int64_t p6 = converter::Converter<int64_t>::toCpp(context, info[6]);
    // JSValToCSVal P any
    bool p7 = converter::Converter<bool>::toCpp(context, info[7]);

    typedef void (*FuncToCall)(void*,uint32_t p0, struct s_i8i8i8_ p1, bool p2, bool p3, int64_t p4, int32_t p5, int64_t p6, bool p7, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5, p6, p7,  method);

    
    return true;
}

// Void C_AddTempObstacle(UInt32, GCore.FVector3, Int64, Int64)
static bool w_vtu4s_i8i8i8_i8i8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4s_i8i8i8_i8i8");
    
    auto TIp1 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,uint32_t p0, struct s_i8i8i8_ p1, int64_t p2, int64_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void C_AddPointForce(UInt32, GCore.FVector3, GCore.FVector3)
static bool w_vtu4s_i8i8i8_s_i8i8i8_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4s_i8i8i8_s_i8i8i8_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_i8i8i8_* pp1 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[1]);
    s_i8i8i8_ p1 = pp1 ? *pp1 : s_i8i8i8_ {};
    // JSValToCSVal struct
    s_i8i8i8_* pp2 = DataTransfer::GetPointer<s_i8i8i8_>(context, info[2]);
    s_i8i8i8_ p2 = pp2 ? *pp2 : s_i8i8i8_ {};

    typedef void (*FuncToCall)(void*,uint32_t p0, struct s_i8i8i8_ p1, struct s_i8i8i8_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void EnterClipping(UInt32, UnityEngine.Rect, System.Nullable`1[UnityEngine.Vector4])
static bool w_vtu4s_r4r4r4r4_s_br4r4r4r4_(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4s_r4r4r4r4_s_br4r4r4r4_");
    
    auto TIp1 = wrapData->TypeInfos[0];
    auto TIp2 = wrapData->TypeInfos[1];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if ((!info[1]->IsObject() || !IsAssignableFrom(TIp1, GetTypeId(info[1].As<v8::Object>())))) return false;
        if ((!info[2]->IsObject() || !IsAssignableFrom(TIp2, GetTypeId(info[2].As<v8::Object>())))) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal struct
    s_r4r4r4r4_* pp1 = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[1]);
    s_r4r4r4r4_ p1 = pp1 ? *pp1 : s_r4r4r4r4_ {};
    // JSValToCSVal struct
    s_br4r4r4r4_* pp2 = DataTransfer::GetPointer<s_br4r4r4r4_>(context, info[2]);
    s_br4r4r4r4_ p2 = pp2 ? *pp2 : s_br4r4r4r4_ {};

    typedef void (*FuncToCall)(void*,uint32_t p0, struct s_r4r4r4r4_ p1, struct s_br4r4r4r4_ p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void C_IgnorePhyCollision(UInt32, UInt32, Boolean)
static bool w_vtu4u4b(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4u4b");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<bool>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    bool p2 = converter::Converter<bool>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,uint32_t p0, uint32_t p1, bool p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void C_SetActionCost(UInt32, UInt32, Int32)
static bool w_vtu4u4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4u4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[2])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int32_t p2 = converter::Converter<int32_t>::toCpp(context, info[2]);

    typedef void (*FuncToCall)(void*,uint32_t p0, uint32_t p1, int32_t p2, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2,  method);

    
    return true;
}

// Void C_AddAction(UInt32, UInt32, Int64, Int64, Int32, Int32)
static bool w_vtu4u4i8i8i4i4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4u4i8i8i4i4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 6) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[2])) return false;
        if (!converter::Converter<int64_t>::accept(context, info[3])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[4])) return false;
        if (!converter::Converter<int32_t>::accept(context, info[5])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    int64_t p2 = converter::Converter<int64_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    int64_t p3 = converter::Converter<int64_t>::toCpp(context, info[3]);
    // JSValToCSVal P any
    int32_t p4 = converter::Converter<int32_t>::toCpp(context, info[4]);
    // JSValToCSVal P any
    int32_t p5 = converter::Converter<int32_t>::toCpp(context, info[5]);

    typedef void (*FuncToCall)(void*,uint32_t p0, uint32_t p1, int64_t p2, int64_t p3, int32_t p4, int32_t p5, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3, p4, p5,  method);

    
    return true;
}

// Void .ctor(UInt32, UInt32, UInt32, UInt32)
static bool w_vtu4u4u4u4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu4u4u4u4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 4) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[2])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[3])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal P any
    uint32_t p2 = converter::Converter<uint32_t>::toCpp(context, info[2]);
    // JSValToCSVal P any
    uint32_t p3 = converter::Converter<uint32_t>::toCpp(context, info[3]);

    typedef void (*FuncToCall)(void*,uint32_t p0, uint32_t p1, uint32_t p2, uint32_t p3, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1, p2, p3,  method);

    
    return true;
}

// Void set_overrideSceneCullingMask(UInt64)
static bool w_vtu8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint64_t>::accept(context, info[0])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(void*,uint64_t p0, const void* method);
    ((FuncToCall)methodPointer)(self, p0,  method);

    
    return true;
}

// Void .ctor(UInt64, UInt64)
static bool w_vtu8u8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vtu8u8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint64_t>::accept(context, info[1])) return false;
    }
    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(void*,uint64_t p0, uint64_t p1, const void* method);
    ((FuncToCall)methodPointer)(self, p0, p1,  method);

    
    return true;
}

// Void AreEqual(Byte, Byte)
static bool w_vu1u1(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vu1u1");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint8_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint8_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(uint8_t p0, uint8_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void AreEqual(Byte, Byte, System.String)
static bool w_vu1u1s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vu1u1s");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<uint8_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint8_t>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    uint8_t p0 = converter::Converter<uint8_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint8_t p1 = converter::Converter<uint8_t>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(uint8_t p0, uint8_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void AreEqual(UInt16, UInt16)
static bool w_vu2u2(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vu2u2");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint16_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint16_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(uint16_t p0, uint16_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void AreEqual(UInt16, UInt16, System.String)
static bool w_vu2u2s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vu2u2s");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<uint16_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint16_t>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    uint16_t p0 = converter::Converter<uint16_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint16_t p1 = converter::Converter<uint16_t>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(uint16_t p0, uint16_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void SetCustomCursor(UInt32)
static bool w_vu4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vu4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(uint32_t p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void AreEqual(UInt32, UInt32)
static bool w_vu4u4(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vu4u4");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(uint32_t p0, uint32_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void AreEqual(UInt32, UInt32, System.String)
static bool w_vu4u4s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vu4u4s");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint32_t>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    uint32_t p0 = converter::Converter<uint32_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint32_t p1 = converter::Converter<uint32_t>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(uint32_t p0, uint32_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

// Void set_incrementalTimeSliceNanoseconds(UInt64)
static bool w_vu8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vu8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 1) return false;
        if (!converter::Converter<uint64_t>::accept(context, info[0])) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(context, info[0]);

    typedef void (*FuncToCall)(uint64_t p0, const void* method);
    ((FuncToCall)methodPointer)( p0,  method);

    
    return true;
}

// Void AreEqual(UInt64, UInt64)
static bool w_vu8u8(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vu8u8");
    

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 2) return false;
        if (!converter::Converter<uint64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint64_t>::accept(context, info[1])) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(context, info[1]);

    typedef void (*FuncToCall)(uint64_t p0, uint64_t p1, const void* method);
    ((FuncToCall)methodPointer)( p0, p1,  method);

    
    return true;
}

// Void AreEqual(UInt64, UInt64, System.String)
static bool w_vu8u8s(void* method, MethodPointer methodPointer, const v8::FunctionCallbackInfo<v8::Value>& info, bool checkJSArgument, WrapData* wrapData) {
    // PLog(LogLevel::Log, "Running w_vu8u8s");
    
    auto TIp2 = wrapData->TypeInfos[0];

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    if (checkJSArgument) {
        auto length = info.Length();
        if (length != 3) return false;
        if (!converter::Converter<uint64_t>::accept(context, info[0])) return false;
        if (!converter::Converter<uint64_t>::accept(context, info[1])) return false;
        if (!info[2]->IsString() && !info[2]->IsNullOrUndefined()) return false;
    }
    
    // JSValToCSVal P any
    uint64_t p0 = converter::Converter<uint64_t>::toCpp(context, info[0]);
    // JSValToCSVal P any
    uint64_t p1 = converter::Converter<uint64_t>::toCpp(context, info[1]);
    // JSValToCSVal s
    v8::String::Utf8Value tp2(isolate, info[2]);
    void* p2 = CStringToCSharpString(*tp2);

    typedef void (*FuncToCall)(uint64_t p0, uint64_t p1, void* p2, const void* method);
    ((FuncToCall)methodPointer)( p0, p1, p2,  method);

    
    return true;
}

static WrapFuncInfo g_wrapFuncInfos[] = {
    
    {"Os", w_Os},
    {"Oss", w_Oss},
    {"Ot", w_Ot},
    {"OtVO", w_OtVO},
    {"Oti4", w_Oti4},
    {"Oto", w_Oto},
    {"Ots", w_Ots},
    {"POti4", w_POti4},
    {"b", w_b},
    {"bDu8", w_bDu8},
    {"bO", w_bO},
    {"bOi4", w_bOi4},
    {"bPs_su4_", w_bPs_su4_},
    {"bb", w_bb},
    {"bbb", w_bbb},
    {"bc", w_bc},
    {"bi4", w_bi4},
    {"bi4i4", w_bi4i4},
    {"bo", w_bo},
    {"boPs_r4r4r4r4_", w_boPs_r4r4r4r4_},
    {"boPs_r4r4r4r4r4r4u4r4r4r4i4_", w_boPs_r4r4r4r4r4r4u4r4r4r4i4_},
    {"boi4", w_boi4},
    {"boi4i4o", w_boi4i4o},
    {"boi4oi4", w_boi4oi4},
    {"boo", w_boo},
    {"boor4o", w_boor4o},
    {"bos_r4r4r4r4r4r4_", w_bos_r4r4r4r4r4r4_},
    {"br4r4", w_br4r4},
    {"br4r4r4", w_br4r4r4},
    {"br4r4r4r4", w_br4r4r4r4},
    {"bs", w_bs},
    {"bsPs_r4r4r4r4_", w_bsPs_r4r4r4r4_},
    {"bs_i2i2_s_i2i2_", w_bs_i2i2_s_i2i2_},
    {"bs_i4_", w_bs_i4_},
    {"bs_i4_s_i4_", w_bs_i4_s_i4_},
    {"bs_i4i4_", w_bs_i4i4_},
    {"bs_i4i4_s_i4i4_", w_bs_i4i4_s_i4i4_},
    {"bs_i4i4i4_s_i4i4i4_", w_bs_i4i4i4_s_i4i4i4_},
    {"bs_i4i4i4i4_s_i4i4i4i4_", w_bs_i4i4i4i4_s_i4i4i4i4_},
    {"bs_i4i4i4i4i4i4_s_i4i4i4i4i4i4_", w_bs_i4i4i4i4i4i4_s_i4i4i4i4i4i4_},
    {"bs_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_", w_bs_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_s_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_},
    {"bs_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_", w_bs_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_},
    {"bs_i4i4i4u4i4i2i2_s_i4i4i4u4i4i2i2_", w_bs_i4i4i4u4i4i2i2_s_i4i4i4u4i4i2i2_},
    {"bs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_", w_bs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_s_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_},
    {"bs_i4i4r4u1u1u1u1_s_i4i4r4u1u1u1u1_", w_bs_i4i4r4u1u1u1u1_s_i4i4r4u1u1u1u1_},
    {"bs_i4r4r4r4r4r4i4_s_i4r4r4r4r4r4i4_", w_bs_i4r4r4r4r4r4i4_s_i4r4r4r4r4r4i4_},
    {"bs_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_", w_bs_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_s_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_},
    {"bs_i4u1r4r4r4r4r4r4_s_i4u1r4r4r4r4r4r4_", w_bs_i4u1r4r4r4r4r4r4_s_i4u1r4r4r4r4r4r4_},
    {"bs_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_", w_bs_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_},
    {"bs_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_", w_bs_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_},
    {"bs_p_s_p_", w_bs_p_s_p_},
    {"bs_ppi4i4_s_ppi4i4_", w_bs_ppi4i4_s_ppi4i4_},
    {"bs_psu4_s_psu4_", w_bs_psu4_s_psu4_},
    {"bs_pu4_s_pu4_", w_bs_pu4_s_pu4_},
    {"bs_r4i4_s_r4i4_", w_bs_r4i4_s_r4i4_},
    {"bs_r4r4_s_r4r4_", w_bs_r4r4_s_r4r4_},
    {"bs_r4r4r4_s_r4r4r4_", w_bs_r4r4r4_s_r4r4r4_},
    {"bs_r4r4r4r4_s_r4r4r4r4_", w_bs_r4r4r4r4_s_r4r4r4r4_},
    {"bs_r4r4r4r4i4i4i4i4_s_r4r4r4r4i4i4i4i4_", w_bs_r4r4r4r4i4i4i4i4_s_r4r4r4r4i4i4i4i4_},
    {"bs_r4r4r4r4r4r4_s_r4r4r4r4r4r4_", w_bs_r4r4r4r4r4r4_s_r4r4r4r4r4r4_},
    {"bs_r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4_", w_bs_r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4_},
    {"bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_", w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_},
    {"bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_", w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_},
    {"bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_", w_bs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_},
    {"bs_su4bbb_", w_bs_su4bbb_},
    {"bs_su8u8_", w_bs_su8u8_},
    {"bs_u1i1_s_u1i1_", w_bs_u1i1_s_u1i1_},
    {"bs_u1u1u1u1u1u1u1u1_s_u1u1u1u1u1u1u1u1_", w_bs_u1u1u1u1u1u1u1u1_s_u1u1u1u1u1u1u1u1_},
    {"bs_u1u1u1u1u1u1u1u1u1u1u1u1_s_u1u1u1u1u1u1u1u1u1u1u1u1_", w_bs_u1u1u1u1u1u1u1u1u1u1u1u1_s_u1u1u1u1u1u1u1u1u1u1u1u1_},
    {"bs_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_", w_bs_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_},
    {"bs_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_", w_bs_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_},
    {"bs_u2_", w_bs_u2_},
    {"bs_u4u4_s_u4u4_", w_bs_u4u4_s_u4u4_},
    {"bs_u8u8_s_u8u8_", w_bs_u8u8_s_u8u8_},
    {"bsb", w_bsb},
    {"bss_r4r4r4r4_", w_bss_r4r4r4r4_},
    {"bss_r4r4r4r4_i4", w_bss_r4r4r4r4_i4},
    {"bss_r4r4r4r4_i4i4", w_bss_r4r4r4r4_i4i4},
    {"bss_u8u8_", w_bss_u8u8_},
    {"bt", w_bt},
    {"btO", w_btO},
    {"btPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_", w_btPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_},
    {"btPs_psu4_", w_btPs_psu4_},
    {"btPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_btPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"btb", w_btb},
    {"btbPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_", w_btbPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_},
    {"btc", w_btc},
    {"btcPr4Pr4Pr4", w_btcPr4Pr4Pr4},
    {"bti4", w_bti4},
    {"bti4Po", w_bti4Po},
    {"bti4PsPi4", w_bti4PsPi4},
    {"bti4Ps_r4r4r4r4r4r4_", w_bti4Ps_r4r4r4r4r4r4_},
    {"bti4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4u1r4r4r4r4r4r4_", w_bti4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4u1r4r4r4r4r4r4_},
    {"bti4i4", w_bti4i4},
    {"bti4i4i4b", w_bti4i4i4b},
    {"bti4i4i4i4", w_bti4i4i4i4},
    {"bti4i4i4s_r4r4r4_i4r4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4u1r4r4r4r4r4r4_", w_bti4i4i4s_r4r4r4_i4r4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4u1r4r4r4r4r4r4_},
    {"bti4i4r4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4u1r4r4r4r4r4r4_", w_bti4i4r4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4u1r4r4r4r4r4r4_},
    {"bti4o", w_bti4o},
    {"bto", w_bto},
    {"btoPo", w_btoPo},
    {"btoi4", w_btoi4},
    {"btoi4i4", w_btoi4i4},
    {"btr4r4", w_btr4r4},
    {"btr4r4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_btr4r4Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"bts", w_bts},
    {"btsO", w_btsO},
    {"btsOO", w_btsOO},
    {"btsPo", w_btsPo},
    {"bts_i2i2_", w_bts_i2i2_},
    {"bts_i4_", w_bts_i4_},
    {"bts_i4i2i2u1u1u1u1u1u1u1u1_i4", w_bts_i4i2i2u1u1u1u1u1u1u1u1_i4},
    {"bts_i4i2i2u1u1u1u1u1u1u1u1_o", w_bts_i4i2i2u1u1u1u1u1u1u1u1_o},
    {"bts_i4i4_", w_bts_i4i4_},
    {"bts_i4i4i4_", w_bts_i4i4i4_},
    {"bts_i4i4i4i4_", w_bts_i4i4i4i4_},
    {"bts_i4i4i4i4i4i4_", w_bts_i4i4i4i4i4i4_},
    {"bts_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_", w_bts_i4i4i4i4i4i4pi4i4i4i4i4i4pi4i4i4r4r4r4r4r4u4_},
    {"bts_i4i4i4pi4i4i4_", w_bts_i4i4i4pi4i4i4_},
    {"bts_i4i4i4u4i4i2i2_", w_bts_i4i4i4u4i4i2i2_},
    {"bts_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_", w_bts_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_},
    {"bts_i4i4r4u1u1u1u1_", w_bts_i4i4r4u1u1u1u1_},
    {"bts_i4r4r4r4r4r4i4_", w_bts_i4r4r4r4r4r4i4_},
    {"bts_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_", w_bts_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_},
    {"bts_i4u1r4r4r4r4r4r4_", w_bts_i4u1r4r4r4r4r4r4_},
    {"bts_i8i8i8_s_i8i8i8_i8i4i4i4", w_bts_i8i8i8_s_i8i8i8_i8i4i4i4},
    {"bts_i8i8i8_s_i8i8i8_i8i4i4i4i8", w_bts_i8i8i8_s_i8i8i8_i8i4i4i4i8},
    {"bts_oi4o_", w_bts_oi4o_},
    {"bts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_", w_bts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_},
    {"bts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_", w_bts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_},
    {"bts_p_", w_bts_p_},
    {"bts_ppi4i4_", w_bts_ppi4i4_},
    {"bts_psu4_", w_bts_psu4_},
    {"bts_pu4_", w_bts_pu4_},
    {"bts_r4i4_", w_bts_r4i4_},
    {"bts_r4r4_", w_bts_r4r4_},
    {"bts_r4r4r4_", w_bts_r4r4r4_},
    {"bts_r4r4r4_b", w_bts_r4r4r4_b},
    {"bts_r4r4r4_s_r4r4r4_", w_bts_r4r4r4_s_r4r4r4_},
    {"bts_r4r4r4r4_", w_bts_r4r4r4r4_},
    {"bts_r4r4r4r4_b", w_bts_r4r4r4r4_b},
    {"bts_r4r4r4r4_s_r4r4_", w_bts_r4r4r4r4_s_r4r4_},
    {"bts_r4r4r4r4i4i4i4i4_", w_bts_r4r4r4r4i4i4i4i4_},
    {"bts_r4r4r4r4r4r4_", w_bts_r4r4r4r4r4r4_},
    {"bts_r4r4r4r4r4r4_Pr4", w_bts_r4r4r4r4r4r4_Pr4},
    {"bts_r4r4r4r4r4r4r4_", w_bts_r4r4r4r4r4r4r4_},
    {"bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_", w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_},
    {"bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_", w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_},
    {"bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_", w_bts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_},
    {"bts_su4_", w_bts_su4_},
    {"bts_su4bbb_", w_bts_su4bbb_},
    {"bts_u1i1_", w_bts_u1i1_},
    {"bts_u1u1u1u1u1u1u1u1_", w_bts_u1u1u1u1u1u1u1u1_},
    {"bts_u1u1u1u1u1u1u1u1u1u1u1u1_", w_bts_u1u1u1u1u1u1u1u1u1u1u1u1_},
    {"bts_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_", w_bts_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_},
    {"bts_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_", w_bts_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_},
    {"bts_u4u4_", w_bts_u4u4_},
    {"bts_u8i4i4u4u4i4i4i4i4s_", w_bts_u8i4i4u4u4i4i4i4i4s_},
    {"bts_u8u8_", w_bts_u8u8_},
    {"btsb", w_btsb},
    {"btso", w_btso},
    {"btsssi4i4si8so", w_btsssi4i4si8so},
    {"btu4", w_btu4},
    {"btu4i4", w_btu4i4},
    {"bu4", w_bu4},
    {"ct", w_ct},
    {"i2t", w_i2t},
    {"i4", w_i4},
    {"i4Vi4", w_i4Vi4},
    {"i4Vs", w_i4Vs},
    {"i4c", w_i4c},
    {"i4i4", w_i4i4},
    {"i4i4b", w_i4i4b},
    {"i4i4i4", w_i4i4i4},
    {"i4i4i4i4", w_i4i4i4i4},
    {"i4o", w_i4o},
    {"i4p", w_i4p},
    {"i4pPs_i8_Ps_i8_i4", w_i4pPs_i8_Ps_i8_i4},
    {"i4pPs_i8i8i8_Di4Di4", w_i4pPs_i8i8i8_Di4Di4},
    {"i4pPs_i8i8i8_Ps_i8i8i8_Pi8i4i4i4Ps_i8i8i8_", w_i4pPs_i8i8i8_Ps_i8i8i8_Pi8i4i4i4Ps_i8i8i8_},
    {"i4pPs_i8i8i8_Ps_i8i8i8_Pi8i4i4i4Ps_i8i8i8_Pi8", w_i4pPs_i8i8i8_Ps_i8i8i8_Pi8i4i4i4Ps_i8i8i8_Pi8},
    {"i4pPs_i8i8i8_Ps_i8i8i8_Ps_i8_", w_i4pPs_i8i8i8_Ps_i8i8i8_Ps_i8_},
    {"i4pPs_i8i8i8_Ps_i8i8i8_o", w_i4pPs_i8i8i8_Ps_i8i8i8_o},
    {"i4pi4", w_i4pi4},
    {"i4pi4Ps_i8i8i8_Ps_i8i8i8_o", w_i4pi4Ps_i8i8i8_Ps_i8i8i8_o},
    {"i4pi4Ps_i8i8i8_Ps_i8i8i8_oPi8", w_i4pi4Ps_i8i8i8_Ps_i8i8i8_oPi8},
    {"i4pi4i4", w_i4pi4i4},
    {"i4pi4i4Di4Di4", w_i4pi4i4Di4Di4},
    {"i4pi4i4i4i4", w_i4pi4i4i4i4},
    {"i4po", w_i4po},
    {"i4poi4", w_i4poi4},
    {"i4ps", w_i4ps},
    {"i4pu4", w_i4pu4},
    {"i4pu4i4", w_i4pu4i4},
    {"i4pu4o", w_i4pu4o},
    {"i4r4", w_i4r4},
    {"i4s", w_i4s},
    {"i4s_i4_", w_i4s_i4_},
    {"i4s_i4i4i4i4i4i4i4i4i4i4i4i4i4_", w_i4s_i4i4i4i4i4i4i4i4i4i4i4i4i4_},
    {"i4s_su4bbb_", w_i4s_su4bbb_},
    {"i4si4", w_i4si4},
    {"i4t", w_i4t},
    {"i4tO", w_i4tO},
    {"i4tOi4", w_i4tOi4},
    {"i4tOi4i4", w_i4tOi4i4},
    {"i4tOo", w_i4tOo},
    {"i4tbi4oi4", w_i4tbi4oi4},
    {"i4tboi4", w_i4tboi4},
    {"i4ti4", w_i4ti4},
    {"i4ti4i4", w_i4ti4i4},
    {"i4ti4i4Oo", w_i4ti4i4Oo},
    {"i4ti4i4i4", w_i4ti4i4i4},
    {"i4ti4i4i4i4", w_i4ti4i4i4i4},
    {"i4ti4i4i4o", w_i4ti4i4i4o},
    {"i4ti4i4o", w_i4ti4i4o},
    {"i4ti4i4so", w_i4ti4i4so},
    {"i4ti4o", w_i4ti4o},
    {"i4ti4oi4", w_i4ti4oi4},
    {"i4ti4s_r4r4r4r4i4i4r4r4_", w_i4ti4s_r4r4r4r4i4i4r4r4_},
    {"i4ti8i8i4", w_i4ti8i8i4},
    {"i4ti8i8i4i4", w_i4ti8i8i4i4},
    {"i4ti8i8i8i8", w_i4ti8i8i8i8},
    {"i4to", w_i4to},
    {"i4toi4", w_i4toi4},
    {"i4toi4oi4i4bbs_r4r4r4r4r4r4_i4ooDu8Du4", w_i4toi4oi4i4bbs_r4r4r4r4r4r4_i4ooDu8Du4},
    {"i4tos", w_i4tos},
    {"i4tr4", w_i4tr4},
    {"i4tr4r4", w_i4tr4r4},
    {"i4tr4r4oooo", w_i4tr4r4oooo},
    {"i4tr4r4r4i4i4oooo", w_i4tr4r4r4i4i4oooo},
    {"i4ts", w_i4ts},
    {"i4ts_Pu1i4i4i4i4pi4i4_", w_i4ts_Pu1i4i4i4i4pi4i4_},
    {"i4ts_Pvi4i4i4pi4i4oi4_", w_i4ts_Pvi4i4i4pi4i4oi4_},
    {"i4ts_pu4u4_", w_i4ts_pu4u4_},
    {"i4ts_r4r4r4r4i4i4r4r4_", w_i4ts_r4r4r4r4i4i4r4r4_},
    {"i4ts_u8u8_", w_i4ts_u8u8_},
    {"i4tsi4", w_i4tsi4},
    {"i4tsi4i4", w_i4tsi4i4},
    {"i4tso", w_i4tso},
    {"i4tu4", w_i4tu4},
    {"i8", w_i8},
    {"i8Pi8", w_i8Pi8},
    {"i8Pi8Pi8", w_i8Pi8Pi8},
    {"i8Ps_i8i8i8_", w_i8Ps_i8i8i8_},
    {"i8Ps_i8i8i8_Ps_i8i8i8_", w_i8Ps_i8i8i8_Ps_i8i8i8_},
    {"i8Ps_i8i8i8i8_", w_i8Ps_i8i8i8i8_},
    {"i8o", w_i8o},
    {"i8pPs_i8_", w_i8pPs_i8_},
    {"i8pPs_i8_Ps_i8_Ps_i8i8i8_", w_i8pPs_i8_Ps_i8_Ps_i8i8i8_},
    {"i8pi4", w_i8pi4},
    {"i8s_Pvi4i4i4pi4i4oi4_", w_i8s_Pvi4i4i4pi4i4oi4_},
    {"i8t", w_i8t},
    {"i8ti4", w_i8ti4},
    {"i8ti4s_i8i8i8_s_i8i8i8_", w_i8ti4s_i8i8i8_s_i8i8i8_},
    {"i8ti8", w_i8ti8},
    {"i8ti8i8", w_i8ti8i8},
    {"i8ti8i8i8i8", w_i8ti8i8i8i8},
    {"i8ts_i8i8i8_", w_i8ts_i8i8i8_},
    {"i8tss_i8i8i8_s_i8i8i8_", w_i8tss_i8i8i8_s_i8i8i8_},
    {"o", w_o},
    {"oO", w_oO},
    {"oOi4", w_oOi4},
    {"oOso", w_oOso},
    {"oPs_u8i4i4u4u4i4i4i4i4s_s_i4i4_", w_oPs_u8i4i4u4u4i4i4i4i4s_s_i4i4_},
    {"oVo", w_oVo},
    {"oi4", w_oi4},
    {"oi4i4", w_oi4i4},
    {"oi4i4b", w_oi4i4b},
    {"oi4i4bp", w_oi4i4bp},
    {"oi4i4i4", w_oi4i4i4},
    {"oi4i4i4bbp", w_oi4i4i4bbp},
    {"oi4i4i4i4", w_oi4i4i4i4},
    {"oi4i4i4i4bp", w_oi4i4i4i4bp},
    {"oi4i4i4i4i4", w_oi4i4i4i4i4},
    {"oi4i4i4i4i4i4", w_oi4i4i4i4i4i4},
    {"oi4i4i4i4i4i4i4", w_oi4i4i4i4i4i4i4},
    {"oi4i4i4i4i4i4i4b", w_oi4i4i4i4i4i4i4b},
    {"oi4i4i4i4i4i4i4i4", w_oi4i4i4i4i4i4i4i4},
    {"oi4i4i4i4i4i4i4i4b", w_oi4i4i4i4i4i4i4i4b},
    {"oi4s_i4i4_", w_oi4s_i4i4_},
    {"oo", w_oo},
    {"ooDo", w_ooDo},
    {"ooOo", w_ooOo},
    {"ooOob", w_ooOob},
    {"ooOs", w_ooOs},
    {"ooOsb", w_ooOsb},
    {"ooOsbb", w_ooOsbb},
    {"oob", w_oob},
    {"ooi4", w_ooi4},
    {"ooi4i4", w_ooi4i4},
    {"ooo", w_ooo},
    {"ooob", w_ooob},
    {"ooos", w_ooos},
    {"ooosb", w_ooosb},
    {"ooosbb", w_ooosbb},
    {"oos", w_oos},
    {"oos_r4r4r4_s_r4r4r4r4_", w_oos_r4r4r4_s_r4r4r4r4_},
    {"oos_r4r4r4_s_r4r4r4r4_o", w_oos_r4r4r4_s_r4r4r4r4_o},
    {"oos_r4r4r4r4_s_r4r4_", w_oos_r4r4r4r4_s_r4r4_},
    {"oos_r4r4r4r4_s_r4r4_r4", w_oos_r4r4r4r4_s_r4r4_r4},
    {"oos_r4r4r4r4_s_r4r4_r4u4", w_oos_r4r4r4r4_s_r4r4_r4u4},
    {"oos_r4r4r4r4_s_r4r4_r4u4i4", w_oos_r4r4r4r4_s_r4r4_r4u4i4},
    {"oos_r4r4r4r4_s_r4r4_r4u4i4s_r4r4r4r4_", w_oos_r4r4r4r4_s_r4r4_r4u4i4s_r4r4r4r4_},
    {"oos_r4r4r4r4_s_r4r4_r4u4i4s_r4r4r4r4_b", w_oos_r4r4r4r4_s_r4r4_r4u4i4s_r4r4r4r4_b},
    {"ooso", w_ooso},
    {"or4", w_or4},
    {"or4r4r4", w_or4r4r4},
    {"or4r4r4r4", w_or4r4r4r4},
    {"or8r8r4", w_or8r8r4},
    {"os", w_os},
    {"osDb", w_osDb},
    {"os_i4_", w_os_i4_},
    {"os_i4_i4", w_os_i4_i4},
    {"os_i4i4i4_", w_os_i4i4i4_},
    {"os_i4i4i4i4i4i4i4i4i4i4i4i4i4_", w_os_i4i4i4i4i4i4i4i4i4i4i4i4i4_},
    {"os_r4r4_s_r4r4_r4", w_os_r4r4_s_r4r4_r4},
    {"os_r4r4r4_r4r4", w_os_r4r4r4_r4r4},
    {"os_r4r4r4_s_r4r4r4_r4", w_os_r4r4r4_s_r4r4r4_r4},
    {"os_r4r4r4r4_s_r4r4r4r4_r4", w_os_r4r4r4r4_s_r4r4r4r4_r4},
    {"os_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_os_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"os_si4u1u1u1u1bsi4sbsbbbbssssss_", w_os_si4u1u1u1u1bsi4sbsbbbbssssss_},
    {"os_si4u1u1u1u1bsi4sbsbbbbssssss_s_r4r4_", w_os_si4u1u1u1u1bsi4sbsbbbbssssss_s_r4r4_},
    {"os_si4u1u1u1u1bsi4sbsbbbbssssss_s_r4r4r4r4_", w_os_si4u1u1u1u1bsi4sbsbbbbssssss_s_r4r4r4r4_},
    {"osi4", w_osi4},
    {"osi4b", w_osi4b},
    {"osi4bb", w_osi4bb},
    {"osi4bbb", w_osi4bbb},
    {"osi4bbbb", w_osi4bbbb},
    {"osi4bbbbs", w_osi4bbbbs},
    {"osi4bbbbsi4", w_osi4bbbbsi4},
    {"oso", w_oso},
    {"oss", w_oss},
    {"oss_i4i4_", w_oss_i4i4_},
    {"osso", w_osso},
    {"ot", w_ot},
    {"otO", w_otO},
    {"otOi4", w_otOi4},
    {"otb", w_otb},
    {"oti4", w_oti4},
    {"oti4Db", w_oti4Db},
    {"oti4b", w_oti4b},
    {"oti4i4", w_oti4i4},
    {"oti4i4i4", w_oti4i4i4},
    {"oti4i4i4i4", w_oti4i4i4i4},
    {"oti4i4i4i4i4", w_oti4i4i4i4i4},
    {"oti4i4u4", w_oti4i4u4},
    {"oti4o", w_oti4o},
    {"oti4s", w_oti4s},
    {"oti4s_i8i8i8_s_i8i8i8_", w_oti4s_i8i8i8_s_i8i8i8_},
    {"oti4s_i8i8i8_s_i8i8i8_i8Pi4", w_oti4s_i8i8i8_s_i8i8i8_i8Pi4},
    {"oti8i8Di4Di4Di4", w_oti8i8Di4Di4Di4},
    {"oto", w_oto},
    {"otoDb", w_otoDb},
    {"otob", w_otob},
    {"otoi4", w_otoi4},
    {"otoi4i4", w_otoi4i4},
    {"otoi4i4b", w_otoi4i4b},
    {"otoo", w_otoo},
    {"otos", w_otos},
    {"otosDb", w_otosDb},
    {"otos_Oi4_Po", w_otos_Oi4_Po},
    {"otr4", w_otr4},
    {"otr4r4", w_otr4r4},
    {"otr8r4", w_otr8r4},
    {"ots", w_ots},
    {"otsDi4Do", w_otsDi4Do},
    {"otsDo", w_otsDo},
    {"otsDs", w_otsDs},
    {"otsO", w_otsO},
    {"otsVO", w_otsVO},
    {"ots_bi4i4i4i4_r4", w_ots_bi4i4i4i4_r4},
    {"ots_i8i8i8_s_i8i8i8_s_i8i8i8_", w_ots_i8i8i8_s_i8i8i8_s_i8i8i8_},
    {"ots_i8i8i8_s_i8i8i8_s_i8i8i8_s_i8i8i8_", w_ots_i8i8i8_s_i8i8i8_s_i8i8i8_s_i8i8i8_},
    {"ots_r4r4_b", w_ots_r4r4_b},
    {"ots_r4r4_r4", w_ots_r4r4_r4},
    {"ots_r4r4r4_s_r4r4r4_i4", w_ots_r4r4r4_s_r4r4r4_i4},
    {"otsb", w_otsb},
    {"otsc", w_otsc},
    {"otsi4o", w_otsi4o},
    {"otso", w_otso},
    {"otss", w_otss},
    {"otss_i8i8i8_s_i8i8i8_", w_otss_i8i8i8_s_i8i8i8_},
    {"otsso", w_otsso},
    {"otsu4", w_otsu4},
    {"otsu4o", w_otsu4o},
    {"otu4Pi4", w_otu4Pi4},
    {"p", w_p},
    {"pPi8Pi8Di4Di4Di4", w_pPi8Pi8Di4Di4Di4},
    {"pPs_i8_", w_pPs_i8_},
    {"pi4i4i4Ps_i8_i4i4i4", w_pi4i4i4Ps_i8_i4i4i4},
    {"pi4pPi8Pi8oo", w_pi4pPi8Pi8oo},
    {"po", w_po},
    {"poi4oi4Pi8Pi8Pi8Pi8", w_poi4oi4Pi8Pi8Pi8Pi8},
    {"poi4oi4Ps_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_", w_poi4oi4Ps_i8i8i8i8i8i8i8i8i8i8i8i8i8i8_},
    {"pp", w_pp},
    {"ppPi8Pi8i4i4i4", w_ppPi8Pi8i4i4i4},
    {"ppPs_i8_Ps_i8_Ps_i8i8i8_", w_ppPs_i8_Ps_i8_Ps_i8i8i8_},
    {"ppi4", w_ppi4},
    {"ppu4Pi8", w_ppu4Pi8},
    {"ppu4oi4oi4i4Pi8i4i4Pi8i4", w_ppu4oi4oi4i4Pi8i4i4Pi8i4},
    {"ps", w_ps},
    {"psi4oi4", w_psi4oi4},
    {"pt", w_pt},
    {"pti4", w_pti4},
    {"r4", w_r4},
    {"r4Vr4", w_r4Vr4},
    {"r4i4", w_r4i4},
    {"r4i4r4r4Dr4Dr4Do", w_r4i4r4r4Dr4Dr4Do},
    {"r4o", w_r4o},
    {"r4r4", w_r4r4},
    {"r4r4r4", w_r4r4r4},
    {"r4r4r4Pr4r4", w_r4r4r4Pr4r4},
    {"r4r4r4Pr4r4r4", w_r4r4r4Pr4r4r4},
    {"r4r4r4Pr4r4r4r4", w_r4r4r4Pr4r4r4r4},
    {"r4r4r4r4", w_r4r4r4r4},
    {"r4s", w_r4s},
    {"r4s_i4i4_s_i4i4_", w_r4s_i4i4_s_i4i4_},
    {"r4s_i4i4i4_s_i4i4i4_", w_r4s_i4i4i4_s_i4i4i4_},
    {"r4s_r4r4_", w_r4s_r4r4_},
    {"r4s_r4r4_s_r4r4_", w_r4s_r4r4_s_r4r4_},
    {"r4s_r4r4r4_", w_r4s_r4r4r4_},
    {"r4s_r4r4r4_s_r4r4r4_", w_r4s_r4r4r4_s_r4r4r4_},
    {"r4s_r4r4r4_s_r4r4r4_s_r4r4r4_", w_r4s_r4r4r4_s_r4r4r4_s_r4r4r4_},
    {"r4s_r4r4r4r4_", w_r4s_r4r4r4r4_},
    {"r4s_r4r4r4r4_s_r4r4r4r4_", w_r4s_r4r4r4r4_s_r4r4r4r4_},
    {"r4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_r4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"r4sr4", w_r4sr4},
    {"r4t", w_r4t},
    {"r4ti4", w_r4ti4},
    {"r4ti4i4", w_r4ti4i4},
    {"r4tr4", w_r4tr4},
    {"r4ts", w_r4ts},
    {"r4ts_r4r4r4_", w_r4ts_r4r4r4_},
    {"r4tsr4", w_r4tsr4},
    {"r4u2", w_r4u2},
    {"r8", w_r8},
    {"r8pi4", w_r8pi4},
    {"r8t", w_r8t},
    {"r8ti4", w_r8ti4},
    {"s", w_s},
    {"sDb", w_sDb},
    {"sO", w_sO},
    {"s_Ppi4i4i4pi4i4o_i4", w_s_Ppi4i4i4pi4i4o_i4},
    {"s_Ppi4i4i4pi4i4o_o", w_s_Ppi4i4i4pi4i4o_o},
    {"s_Pvi4i4i4pi4i4oi4_t", w_s_Pvi4i4i4pi4i4oi4_t},
    {"s_Pvi4i4i4pi4i4oi4_ti4", w_s_Pvi4i4i4pi4i4oi4_ti4},
    {"s_Pvi4i4i4pi4i4oi4_ti4i4", w_s_Pvi4i4i4pi4i4oi4_ti4i4},
    {"s_Pvi4i4i4pi4i4oi4_ti4s", w_s_Pvi4i4i4pi4i4oi4_ti4s},
    {"s_bi4o_t", w_s_bi4o_t},
    {"s_br4r4r4r4_t", w_s_br4r4r4r4_t},
    {"s_i2i2_", w_s_i2i2_},
    {"s_i2i2_t", w_s_i2i2_t},
    {"s_i4_", w_s_i4_},
    {"s_i4_i4", w_s_i4_i4},
    {"s_i4_i4s_i4i4_", w_s_i4_i4s_i4i4_},
    {"s_i4_s", w_s_i4_s},
    {"s_i4_ss_i4_", w_s_i4_ss_i4_},
    {"s_i4_ss_i4i4_", w_s_i4_ss_i4i4_},
    {"s_i4_t", w_s_i4_t},
    {"s_i4_ti4", w_s_i4_ti4},
    {"s_i4_ti4i4s_i4_", w_s_i4_ti4i4s_i4_},
    {"s_i4_ti4s_i4_", w_s_i4_ti4s_i4_},
    {"s_i4i4_", w_s_i4i4_},
    {"s_i4i4_i4", w_s_i4i4_i4},
    {"s_i4i4_i4s_i4i4_", w_s_i4i4_i4s_i4i4_},
    {"s_i4i4_s", w_s_i4i4_s},
    {"s_i4i4_s_i4i4_", w_s_i4i4_s_i4i4_},
    {"s_i4i4_s_i4i4_i4", w_s_i4i4_s_i4i4_i4},
    {"s_i4i4_s_i4i4_s_i4i4_", w_s_i4i4_s_i4i4_s_i4i4_},
    {"s_i4i4_s_i4i4i4_", w_s_i4i4_s_i4i4i4_},
    {"s_i4i4_s_r4r4_", w_s_i4i4_s_r4r4_},
    {"s_i4i4_t", w_s_i4i4_t},
    {"s_i4i4i4_", w_s_i4i4i4_},
    {"s_i4i4i4_i4s_i4i4i4_", w_s_i4i4i4_i4s_i4i4i4_},
    {"s_i4i4i4_s_i4i4_", w_s_i4i4i4_s_i4i4_},
    {"s_i4i4i4_s_i4i4i4_", w_s_i4i4i4_s_i4i4i4_},
    {"s_i4i4i4_s_i4i4i4_i4", w_s_i4i4i4_s_i4i4i4_i4},
    {"s_i4i4i4_s_i4i4i4_s_i4i4i4_", w_s_i4i4i4_s_i4i4i4_s_i4i4i4_},
    {"s_i4i4i4_s_r4r4r4_", w_s_i4i4i4_s_r4r4r4_},
    {"s_i4i4i4_t", w_s_i4i4i4_t},
    {"s_i4i4i4i4_", w_s_i4i4i4i4_},
    {"s_i4i4i4i4_t", w_s_i4i4i4i4_t},
    {"s_i4i4i4i4_ti4", w_s_i4i4i4i4_ti4},
    {"s_i4i4i4i4b_t", w_s_i4i4i4i4b_t},
    {"s_i4i4i4i4i4i4_t", w_s_i4i4i4i4i4i4_t},
    {"s_i4i4i4i4i4i4i4i4i4_t", w_s_i4i4i4i4i4i4i4i4i4_t},
    {"s_i4i4i4i4i4i4i4i4i4i4i4i4i4_t", w_s_i4i4i4i4i4i4i4i4i4i4i4i4i4_t},
    {"s_i4i4i4pi4i4i4_i4", w_s_i4i4i4pi4i4i4_i4},
    {"s_i4i4i4pi4i4i4_o", w_s_i4i4i4pi4i4i4_o},
    {"s_i4i4i4pi4i4i4_s", w_s_i4i4i4pi4i4i4_s},
    {"s_i4i4i4pi4i4i4_s_i4p_", w_s_i4i4i4pi4i4i4_s_i4p_},
    {"s_i4i4i4pi4i4i4_t", w_s_i4i4i4pi4i4i4_t},
    {"s_i4i4i4u4i4i2i2_", w_s_i4i4i4u4i4i2i2_},
    {"s_i4i4r4u1u1u1u1_t", w_s_i4i4r4u1u1u1u1_t},
    {"s_i4p_", w_s_i4p_},
    {"s_i4p_t", w_s_i4p_t},
    {"s_i4r4r4r4_", w_s_i4r4r4r4_},
    {"s_i4r4r4r4r4r4i4_t", w_s_i4r4r4r4r4r4i4_t},
    {"s_i4u1r4r4r4r4r4r4_t", w_s_i4u1r4r4r4r4r4r4_t},
    {"s_i4u1u1u1u1_s_i4u1u1u1u1_s_i4u1u1u1u1_r4", w_s_i4u1u1u1u1_s_i4u1u1u1u1_s_i4u1u1u1u1_r4},
    {"s_i4u1u1u1u1_s_r4r4r4r4_", w_s_i4u1u1u1u1_s_r4r4r4r4_},
    {"s_i4u1u1u1u1_t", w_s_i4u1u1u1u1_t},
    {"s_i8_i4", w_s_i8_i4},
    {"s_i8_i8", w_s_i8_i8},
    {"s_i8_r4", w_s_i8_r4},
    {"s_i8i8i8_Di8Di8Di8", w_s_i8i8i8_Di8Di8Di8},
    {"s_i8i8i8_s_i8i8i8_i8", w_s_i8i8i8_s_i8i8i8_i8},
    {"s_i8i8i8_s_i8i8i8_s_i8i8i8_", w_s_i8i8i8_s_i8i8i8_s_i8i8i8_},
    {"s_i8i8i8_t", w_s_i8i8i8_t},
    {"s_i8i8i8_ti4", w_s_i8i8i8_ti4},
    {"s_i8i8i8_ti4Di4Di4", w_s_i8i8i8_ti4Di4Di4},
    {"s_i8i8i8_ti4i4", w_s_i8i8i8_ti4i4},
    {"s_i8i8i8_ti4s_i8i8i8_i8", w_s_i8i8i8_ti4s_i8i8i8_i8},
    {"s_i8i8i8_ti4s_i8i8i8_s_i8i8i8_", w_s_i8i8i8_ti4s_i8i8i8_s_i8i8i8_},
    {"s_i8i8i8_ti8", w_s_i8i8i8_ti8},
    {"s_i8i8i8_ts_i8i8i8_", w_s_i8i8i8_ts_i8i8i8_},
    {"s_i8i8i8_ts_i8i8i8_i8", w_s_i8i8i8_ts_i8i8i8_i8},
    {"s_i8i8i8_tss_i8i8i8_s_i8i8i8_", w_s_i8i8i8_tss_i8i8i8_s_i8i8i8_},
    {"s_i8i8i8_tu4", w_s_i8i8i8_tu4},
    {"s_i8i8i8_tu4s_i8i8i8_", w_s_i8i8i8_tu4s_i8i8i8_},
    {"s_i8i8i8i8_Di8Di8Di8Di8", w_s_i8i8i8i8_Di8Di8Di8Di8},
    {"s_i8i8i8i8_s_i8i8i8_", w_s_i8i8i8i8_s_i8i8i8_},
    {"s_i8i8i8i8_s_i8i8i8i8_s_i8i8i8_", w_s_i8i8i8i8_s_i8i8i8i8_s_i8i8i8_},
    {"s_i8i8i8i8_s_i8i8i8i8_s_i8i8i8i8_", w_s_i8i8i8i8_s_i8i8i8i8_s_i8i8i8i8_},
    {"s_i8i8i8i8_t", w_s_i8i8i8i8_t},
    {"s_i8i8i8i8_ti8i8i8", w_s_i8i8i8i8_ti8i8i8},
    {"s_i8i8i8i8_ts_i8i8i8_i8", w_s_i8i8i8i8_ts_i8i8i8_i8},
    {"s_i8i8i8i8_tu4", w_s_i8i8i8i8_tu4},
    {"s_i8i8i8i8i8i8i8_ti4s_i8i8i8_s_i8i8i8_i8", w_s_i8i8i8i8i8i8i8_ti4s_i8i8i8_s_i8i8i8_i8},
    {"s_oi4i4O_t", w_s_oi4i4O_t},
    {"s_oi4i4_o", w_s_oi4i4_o},
    {"s_oi4i4i4_t", w_s_oi4i4i4_t},
    {"s_oi4i4i4oi4_t", w_s_oi4i4i4oi4_t},
    {"s_oi4i4s_t", w_s_oi4i4s_t},
    {"s_oi4i4soi4_t", w_s_oi4i4soi4_t},
    {"s_ooopp_", w_s_ooopp_},
    {"s_osi4i4o_t", w_s_osi4i4o_t},
    {"s_osi4i4o_ts", w_s_osi4i4o_ts},
    {"s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_t", w_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_t},
    {"s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_tPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_", w_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_tPs_i4i4r4r4r4r4r4i4u1i4u4u8r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4bi4_},
    {"s_p_t", w_s_p_t},
    {"s_pi4_oDi4Do", w_s_pi4_oDi4Do},
    {"s_pi4_oDo", w_s_pi4_oDo},
    {"s_pi4_oi4i4Do", w_s_pi4_oi4i4Do},
    {"s_pi4_oi4i4i4i4i4i4i4Do", w_s_pi4_oi4i4i4i4i4i4i4Do},
    {"s_pi4_oi4i4i4i4i4i4i4i4Do", w_s_pi4_oi4i4i4i4i4i4i4i4Do},
    {"s_pi4i4_", w_s_pi4i4_},
    {"s_pi4i4_i4", w_s_pi4i4_i4},
    {"s_pi4i4_i4i4", w_s_pi4i4_i4i4},
    {"s_pi4i4_t", w_s_pi4i4_t},
    {"s_pi4i4_ti4", w_s_pi4i4_ti4},
    {"s_pi4i4_ti4i4", w_s_pi4i4_ti4i4},
    {"s_ppi4i4_ti4", w_s_ppi4i4_ti4},
    {"s_ppi4i4_ti4i4i4s_Pvi4i4i4pi4i4oi4_Di4", w_s_ppi4i4_ti4i4i4s_Pvi4i4i4pi4i4oi4_Di4},
    {"s_ppi4i4_ts_Pvi4i4i4pi4i4oi4_Db", w_s_ppi4i4_ts_Pvi4i4i4pi4i4oi4_Db},
    {"s_ppi4i4_ts_Pvi4i4i4pi4i4oi4_bb", w_s_ppi4i4_ts_Pvi4i4i4pi4i4oi4_bb},
    {"s_ppi4i4_ts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_Db", w_s_ppi4i4_ts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_Db},
    {"s_ppi4i4_ts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_bb", w_s_ppi4i4_ts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_bb},
    {"s_psu4_ts", w_s_psu4_ts},
    {"s_pu4_", w_s_pu4_},
    {"s_pu4_s", w_s_pu4_s},
    {"s_pu4_s_pu4_", w_s_pu4_s_pu4_},
    {"s_pu4_s_pu4_Di4", w_s_pu4_s_pu4_Di4},
    {"s_pu4_s_pu4_o", w_s_pu4_s_pu4_o},
    {"s_pu4_s_pu4_oDi4", w_s_pu4_s_pu4_oDi4},
    {"s_pu4_s_pu4_s", w_s_pu4_s_pu4_s},
    {"s_pu4_s_pu4_so", w_s_pu4_s_pu4_so},
    {"s_pu4_t", w_s_pu4_t},
    {"s_pu4_ti4", w_s_pu4_ti4},
    {"s_pu4u4_ts_i4i4i4i4bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4obi4i4pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4oi4o_", w_s_pu4u4_ts_i4i4i4i4bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4obi4i4pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4oi4o_},
    {"s_r4r4_", w_s_r4r4_},
    {"s_r4r4_o", w_s_r4r4_o},
    {"s_r4r4_r4s_r4r4_", w_s_r4r4_r4s_r4r4_},
    {"s_r4r4_s_i4i4_", w_s_r4r4_s_i4i4_},
    {"s_r4r4_s_r4r4_", w_s_r4r4_s_r4r4_},
    {"s_r4r4_s_r4r4_r4", w_s_r4r4_s_r4r4_r4},
    {"s_r4r4_s_r4r4_s_r4r4_", w_s_r4r4_s_r4r4_s_r4r4_},
    {"s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4", w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4},
    {"s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4", w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4},
    {"s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4r4", w_s_r4r4_s_r4r4_s_r4r4_Ps_r4r4_r4r4r4},
    {"s_r4r4_s_r4r4_s_r4r4_r4", w_s_r4r4_s_r4r4_s_r4r4_r4},
    {"s_r4r4_s_r4r4r4_", w_s_r4r4_s_r4r4r4_},
    {"s_r4r4_s_r4r4r4r4_", w_s_r4r4_s_r4r4r4r4_},
    {"s_r4r4_s_r4r4r4r4_s_r4r4_", w_s_r4r4_s_r4r4r4r4_s_r4r4_},
    {"s_r4r4_t", w_s_r4r4_t},
    {"s_r4r4_ti4", w_s_r4r4_ti4},
    {"s_r4r4_tooi4", w_s_r4r4_tooi4},
    {"s_r4r4_tr4", w_s_r4r4_tr4},
    {"s_r4r4_ts", w_s_r4r4_ts},
    {"s_r4r4_ts_r4r4_", w_s_r4r4_ts_r4r4_},
    {"s_r4r4_ts_r4r4_b", w_s_r4r4_ts_r4r4_b},
    {"s_r4r4_ts_r4r4_o", w_s_r4r4_ts_r4r4_o},
    {"s_r4r4_ts_r4r4r4_", w_s_r4r4_ts_r4r4r4_},
    {"s_r4r4_ts_r4r4r4_o", w_s_r4r4_ts_r4r4r4_o},
    {"s_r4r4r4_", w_s_r4r4r4_},
    {"s_r4r4r4_r4s_r4r4r4_", w_s_r4r4r4_r4s_r4r4r4_},
    {"s_r4r4r4_s_i4i4i4_", w_s_r4r4r4_s_i4i4i4_},
    {"s_r4r4r4_s_r4r4_", w_s_r4r4r4_s_r4r4_},
    {"s_r4r4r4_s_r4r4r4_", w_s_r4r4r4_s_r4r4r4_},
    {"s_r4r4r4_s_r4r4r4_r4", w_s_r4r4r4_s_r4r4r4_r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_Du1", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Du1},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_Ps_r4r4r4_r4r4r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4},
    {"s_r4r4r4_s_r4r4r4_s_r4r4r4_r4r4", w_s_r4r4r4_s_r4r4r4_s_r4r4r4_r4r4},
    {"s_r4r4r4_s_r4r4r4r4_", w_s_r4r4r4_s_r4r4r4r4_},
    {"s_r4r4r4_s_r4r4r4r4_s_r4r4r4_", w_s_r4r4r4_s_r4r4r4r4_s_r4r4r4_},
    {"s_r4r4r4_t", w_s_r4r4r4_t},
    {"s_r4r4r4_ti4", w_s_r4r4r4_ti4},
    {"s_r4r4r4_tr4", w_s_r4r4r4_tr4},
    {"s_r4r4r4_tr4r4r4", w_s_r4r4r4_tr4r4r4},
    {"s_r4r4r4_ts_r4r4r4_", w_s_r4r4r4_ts_r4r4r4_},
    {"s_r4r4r4_ts_r4r4r4_Dr4", w_s_r4r4r4_ts_r4r4r4_Dr4},
    {"s_r4r4r4_ts_r4r4r4_i4", w_s_r4r4r4_ts_r4r4r4_i4},
    {"s_r4r4r4_ts_r4r4r4_s_r4r4r4_", w_s_r4r4r4_ts_r4r4r4_s_r4r4r4_},
    {"s_r4r4r4r4_", w_s_r4r4r4r4_},
    {"s_r4r4r4r4_Ps_r4r4r4r4_Ps_r4r4r4r4_", w_s_r4r4r4r4_Ps_r4r4r4r4_Ps_r4r4r4r4_},
    {"s_r4r4r4r4_i4", w_s_r4r4r4r4_i4},
    {"s_r4r4r4r4_o", w_s_r4r4r4r4_o},
    {"s_r4r4r4r4_r4", w_s_r4r4r4r4_r4},
    {"s_r4r4r4r4_r4r4", w_s_r4r4r4r4_r4r4},
    {"s_r4r4r4r4_r4r4r4", w_s_r4r4r4r4_r4r4r4},
    {"s_r4r4r4r4_r4r4r4b", w_s_r4r4r4r4_r4r4r4b},
    {"s_r4r4r4r4_r4r4r4r4", w_s_r4r4r4r4_r4r4r4r4},
    {"s_r4r4r4r4_r4r4r4r4r4r4", w_s_r4r4r4r4_r4r4r4r4r4r4},
    {"s_r4r4r4r4_r4r4r4r4r4r4r4r4", w_s_r4r4r4r4_r4r4r4r4r4r4r4r4},
    {"s_r4r4r4r4_r4s_r4r4r4_", w_s_r4r4r4r4_r4s_r4r4r4_},
    {"s_r4r4r4r4_r4s_r4r4r4r4_", w_s_r4r4r4r4_r4s_r4r4r4r4_},
    {"s_r4r4r4r4_s", w_s_r4r4r4r4_s},
    {"s_r4r4r4r4_s_i4u1u1u1u1_", w_s_r4r4r4r4_s_i4u1u1u1u1_},
    {"s_r4r4r4r4_s_r4r4_", w_s_r4r4r4r4_s_r4r4_},
    {"s_r4r4r4r4_s_r4r4r4_", w_s_r4r4r4r4_s_r4r4r4_},
    {"s_r4r4r4r4_s_r4r4r4_s_r4r4r4_", w_s_r4r4r4r4_s_r4r4r4_s_r4r4r4_},
    {"s_r4r4r4r4_s_r4r4r4r4_", w_s_r4r4r4r4_s_r4r4r4r4_},
    {"s_r4r4r4r4_s_r4r4r4r4_r4", w_s_r4r4r4r4_s_r4r4r4r4_r4},
    {"s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4_", w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4_},
    {"s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_", w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_},
    {"s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4", w_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4},
    {"s_r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4_", w_s_r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4_},
    {"s_r4r4r4r4_t", w_s_r4r4r4r4_t},
    {"s_r4r4r4r4_ti4", w_s_r4r4r4r4_ti4},
    {"s_r4r4r4r4_ti4i4", w_s_r4r4r4r4_ti4i4},
    {"s_r4r4r4r4_ti4i4i4", w_s_r4r4r4r4_ti4i4i4},
    {"s_r4r4r4r4_ti4i4i4i4", w_s_r4r4r4r4_ti4i4i4i4},
    {"s_r4r4r4r4_to", w_s_r4r4r4r4_to},
    {"s_r4r4r4r4_tr4", w_s_r4r4r4r4_tr4},
    {"s_r4r4r4r4_tr4r4", w_s_r4r4r4r4_tr4r4},
    {"s_r4r4r4r4_tr4r4i4", w_s_r4r4r4r4_tr4r4i4},
    {"s_r4r4r4r4_tr4r4r4", w_s_r4r4r4r4_tr4r4r4},
    {"s_r4r4r4r4_tr4r4r4i4", w_s_r4r4r4r4_tr4r4r4i4},
    {"s_r4r4r4r4_ts", w_s_r4r4r4r4_ts},
    {"s_r4r4r4r4_ts_r4r4r4r4_", w_s_r4r4r4r4_ts_r4r4r4r4_},
    {"s_r4r4r4r4_ts_r4r4r4r4_o", w_s_r4r4r4r4_ts_r4r4r4r4_o},
    {"s_r4r4r4r4_tss_r4r4r4r4_", w_s_r4r4r4r4_tss_r4r4r4r4_},
    {"s_r4r4r4r4_u4", w_s_r4r4r4r4_u4},
    {"s_r4r4r4r4i4i4r4r4_ti4", w_s_r4r4r4r4i4i4r4r4_ti4},
    {"s_r4r4r4r4r4r4_os_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_s_r4r4r4r4r4r4_os_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"s_r4r4r4r4r4r4_t", w_s_r4r4r4r4r4r4_t},
    {"s_r4r4r4r4r4r4_ts_r4r4r4_", w_s_r4r4r4r4r4r4_ts_r4r4r4_},
    {"s_r4r4r4r4r4r4_ts_r4r4r4_i4", w_s_r4r4r4r4r4r4_ts_r4r4r4_i4},
    {"s_r4r4r4r4r4r4i4i4i4i4i4i4_ti4", w_s_r4r4r4r4r4r4i4i4i4i4i4i4_ti4},
    {"s_r4r4r4r4r4r4r4_", w_s_r4r4r4r4r4r4r4_},
    {"s_r4r4r4r4r4r4r4_to", w_s_r4r4r4r4r4r4r4_to},
    {"s_r4r4r4r4r4r4r4_ts_r4r4r4r4r4r4r4_", w_s_r4r4r4r4r4r4r4_ts_r4r4r4r4r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4r4r4", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4r4r4r4r4},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_s_r4r4r4_s_r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_s_r4r4r4r4_s_r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4_s_r4r4r4r4_s_r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_b", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_b},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ti4", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ti4},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts_r4r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ts_r4r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_t},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_t", w_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_t},
    {"s_sooo_so", w_s_sooo_so},
    {"s_sooo_soo", w_s_sooo_soo},
    {"s_su4_s", w_s_su4_s},
    {"s_u1i1_", w_s_u1i1_},
    {"s_u1i1_t", w_s_u1i1_t},
    {"s_u1u1u1u1u1u1u1u1_", w_s_u1u1u1u1u1u1u1u1_},
    {"s_u1u1u1u1u1u1u1u1_t", w_s_u1u1u1u1u1u1u1u1_t},
    {"s_u1u1u1u1u1u1u1u1u1u1u1u1_", w_s_u1u1u1u1u1u1u1u1u1u1u1u1_},
    {"s_u1u1u1u1u1u1u1u1u1u1u1u1_t", w_s_u1u1u1u1u1u1u1u1u1u1u1u1_t},
    {"s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_", w_s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_},
    {"s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_t", w_s_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_t},
    {"s_u8i4i4u4u4i4i4i4i4s_", w_s_u8i4i4u4u4i4i4i4i4s_},
    {"s_u8u8_i4", w_s_u8u8_i4},
    {"s_u8u8_r4", w_s_u8u8_r4},
    {"s_u8u8_s", w_s_u8u8_s},
    {"s_u8u8_t", w_s_u8u8_t},
    {"si4", w_si4},
    {"spi4", w_spi4},
    {"ss", w_ss},
    {"ssDb", w_ssDb},
    {"ss_i4_", w_ss_i4_},
    {"ss_r4r4r4r4_", w_ss_r4r4r4r4_},
    {"sss", w_sss},
    {"st", w_st},
    {"stb", w_stb},
    {"sti4", w_sti4},
    {"sto", w_sto},
    {"sts", w_sts},
    {"stsPs", w_stsPs},
    {"stsb", w_stsb},
    {"stsbs", w_stsbs},
    {"stso", w_stso},
    {"stss", w_stss},
    {"u1i4", w_u1i4},
    {"u1t", w_u1t},
    {"u1ti4", w_u1ti4},
    {"u2r4", w_u2r4},
    {"u2t", w_u2t},
    {"u4", w_u4},
    {"u4i4", w_u4i4},
    {"u4i4i4i4", w_u4i4i4i4},
    {"u4i4i4i4i4", w_u4i4i4i4i4},
    {"u4pPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_", w_u4pPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_},
    {"u4pi4", w_u4pi4},
    {"u4pi4Ps_i8i8i8_Ps_i8i8i8_Pi8", w_u4pi4Ps_i8i8i8_Ps_i8i8i8_Pi8},
    {"u4pi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_", w_u4pi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_},
    {"u4t", w_u4t},
    {"u4ti4", w_u4ti4},
    {"u4u4o", w_u4u4o},
    {"u8", w_u8},
    {"u8p", w_u8p},
    {"u8t", w_u8t},
    {"v", w_v},
    {"vO", w_vO},
    {"vOb", w_vOb},
    {"vOi4b", w_vOi4b},
    {"vOo", w_vOo},
    {"vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_i4i4Di4", w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_i4i4Di4},
    {"vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_i4oDi4Di4", w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_i4oDi4Di4},
    {"vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_i4oi4Di4Di4", w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_i4oi4Di4Di4},
    {"vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_i4ooDi4Di4", w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_i4ooDi4Di4},
    {"vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_oi4Di4", w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_oi4Di4},
    {"vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_oi4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ds_br4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_oi4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ds_br4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_ooDi4Di4", w_vPs_i4u4i4r4r4r4r4r4r4oi4i4ooi4bi4o_ooDi4Di4},
    {"vPs_i8i8i8_Pi8Ps_i8i8i8_", w_vPs_i8i8i8_Pi8Ps_i8i8i8_},
    {"vPs_i8i8i8_Ps_i8i8i8_", w_vPs_i8i8i8_Ps_i8i8i8_},
    {"vPs_i8i8i8_Ps_i8i8i8_Pi8Ps_i8i8i8_", w_vPs_i8i8i8_Ps_i8i8i8_Pi8Ps_i8i8i8_},
    {"vPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_", w_vPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_},
    {"vPs_i8i8i8i8_Pi8Pi8Pi8Ps_i8i8i8i8_", w_vPs_i8i8i8i8_Pi8Pi8Pi8Ps_i8i8i8i8_},
    {"vPs_i8i8i8i8_Ps_i8i8i8_", w_vPs_i8i8i8i8_Ps_i8i8i8_},
    {"vPs_i8i8i8i8_Ps_i8i8i8_Pi8Ps_i8i8i8i8_", w_vPs_i8i8i8i8_Ps_i8i8i8_Pi8Ps_i8i8i8i8_},
    {"vPs_i8i8i8i8_Ps_i8i8i8_Ps_i8i8i8_", w_vPs_i8i8i8i8_Ps_i8i8i8_Ps_i8i8i8_},
    {"vPs_i8i8i8i8_Ps_i8i8i8_Ps_i8i8i8i8_", w_vPs_i8i8i8i8_Ps_i8i8i8_Ps_i8i8i8i8_},
    {"vPs_i8i8i8i8_Ps_i8i8i8i8_", w_vPs_i8i8i8i8_Ps_i8i8i8i8_},
    {"vPs_i8i8i8i8_Ps_i8i8i8i8_Ps_i8i8i8i8_", w_vPs_i8i8i8i8_Ps_i8i8i8i8_Ps_i8i8i8i8_},
    {"vPs_r4r4r4_Ps_r4r4r4_", w_vPs_r4r4r4_Ps_r4r4r4_},
    {"vPs_r4r4r4_Ps_r4r4r4_Ps_r4r4r4_", w_vPs_r4r4r4_Ps_r4r4r4_Ps_r4r4r4_},
    {"vPs_r4r4r4_Ps_u8u8_", w_vPs_r4r4r4_Ps_u8u8_},
    {"vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_u8u8_", w_vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_u8u8_},
    {"vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4", w_vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4r4},
    {"vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4s_r4r4_s_r4r4_r4r4Ds_i4r4_", w_vPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_r4s_r4r4_s_r4r4_r4r4Ds_i4r4_},
    {"vPs_su4_", w_vPs_su4_},
    {"vPs_su4_b", w_vPs_su4_b},
    {"vPs_u8u8_Ps_u8u8_", w_vPs_u8u8_Ps_u8u8_},
    {"vb", w_vb},
    {"vbO", w_vbO},
    {"vbOo", w_vbOo},
    {"vbbs_r4r4r4r4_", w_vbbs_r4r4r4r4_},
    {"vbbs_r4r4r4r4_r4", w_vbbs_r4r4r4r4_r4},
    {"vbo", w_vbo},
    {"vbosVO", w_vbosVO},
    {"vbs", w_vbs},
    {"vbsVO", w_vbsVO},
    {"vbso", w_vbso},
    {"vcc", w_vcc},
    {"vccs", w_vccs},
    {"vi1i1", w_vi1i1},
    {"vi1i1s", w_vi1i1s},
    {"vi2i2", w_vi2i2},
    {"vi2i2s", w_vi2i2s},
    {"vi4", w_vi4},
    {"vi4b", w_vi4b},
    {"vi4i4", w_vi4i4},
    {"vi4i4Di4", w_vi4i4Di4},
    {"vi4i4Ps_ppi4i4o_", w_vi4i4Ps_ppi4i4o_},
    {"vi4i4b", w_vi4i4b},
    {"vi4i4bi4", w_vi4i4bi4},
    {"vi4i4i4", w_vi4i4i4},
    {"vi4i4i4i4", w_vi4i4i4i4},
    {"vi4i4osVO", w_vi4i4osVO},
    {"vi4i4s", w_vi4i4s},
    {"vi4o", w_vi4o},
    {"vi4oDi4", w_vi4oDi4},
    {"vi4ob", w_vi4ob},
    {"vi4oi4", w_vi4oi4},
    {"vi4oi4Di4", w_vi4oi4Di4},
    {"vi4oi4i4", w_vi4oi4i4},
    {"vi4ooDi4", w_vi4ooDi4},
    {"vi4r4", w_vi4r4},
    {"vi4r4r4", w_vi4r4r4},
    {"vi4r4r4r4", w_vi4r4r4r4},
    {"vi4s", w_vi4s},
    {"vi4s_r4r4r4_", w_vi4s_r4r4r4_},
    {"vi4s_r4r4r4r4_", w_vi4s_r4r4r4r4_},
    {"vi4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vi4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vi4sb", w_vi4sb},
    {"vi8", w_vi8},
    {"vi8i8", w_vi8i8},
    {"vi8i8s", w_vi8i8s},
    {"vo", w_vo},
    {"voDs", w_voDs},
    {"voDu4", w_voDu4},
    {"voPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_voPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"voPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_", w_voPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_},
    {"voPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_", w_voPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_},
    {"voPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_", w_voPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_},
    {"voPs_i4r4r4r4_", w_voPs_i4r4r4r4_},
    {"voPs_r4r4r4r4_", w_voPs_r4r4r4r4_},
    {"voPs_r4r4r4r4r4r4u4r4r4r4i4_", w_voPs_r4r4r4r4r4r4u4r4r4r4i4_},
    {"voPs_u8u8_", w_voPs_u8u8_},
    {"vob", w_vob},
    {"vobb", w_vobb},
    {"voi4", w_voi4},
    {"voi4Db", w_voi4Db},
    {"voi4i4", w_voi4i4},
    {"voi4i4i4", w_voi4i4i4},
    {"voi4i4i4i4i4i4oi4i4i4i4", w_voi4i4i4i4i4i4oi4i4i4i4},
    {"voi4i4oi4i4", w_voi4i4oi4i4},
    {"voi4oi4", w_voi4oi4},
    {"voi4oo", w_voi4oo},
    {"voi4ooi4", w_voi4ooi4},
    {"voi4ooi4o", w_voi4ooi4o},
    {"voi4ooi4oi4", w_voi4ooi4oi4},
    {"voi4ooi4oi4b", w_voi4ooi4oi4b},
    {"voi4ooi4oi4bi4", w_voi4ooi4oi4bi4},
    {"voi4ooi4oi4bi4o", w_voi4ooi4oi4bi4o},
    {"voi4ooi4oi4bi4oi4", w_voi4ooi4oi4bi4oi4},
    {"voi4ooi4oi4bi4oi4o", w_voi4ooi4oi4bi4oi4o},
    {"voi4ooo", w_voi4ooo},
    {"voi4oooi4", w_voi4oooi4},
    {"voi4oooi4b", w_voi4oooi4b},
    {"voi4oooi4bi4", w_voi4oooi4bi4},
    {"voi4oooi4bi4o", w_voi4oooi4bi4o},
    {"voi4oooi4bi4oi4", w_voi4oooi4bi4oi4},
    {"voi4oooi4bi4oi4o", w_voi4oooi4bi4oi4o},
    {"voi4os_r4r4r4r4r4r4_i4DoDi4DbDi4DoDi4Do", w_voi4os_r4r4r4r4r4r4_i4DoDi4DbDi4DoDi4Do},
    {"voi4os_r4r4r4r4r4r4_oDi4DoDi4DbDi4DoDi4", w_voi4os_r4r4r4r4r4r4_oDi4DoDi4DbDi4DoDi4},
    {"voi4os_r4r4r4r4r4r4_oi4oi4bi4oi4o", w_voi4os_r4r4r4r4r4r4_oi4oi4bi4oi4o},
    {"voi4s_r4r4r4_", w_voi4s_r4r4r4_},
    {"voi4s_r4r4r4_s_r4r4r4r4_", w_voi4s_r4r4r4_s_r4r4r4r4_},
    {"voi4s_r4r4r4_s_r4r4r4r4_s_r4r4r4_", w_voi4s_r4r4r4_s_r4r4r4r4_s_r4r4r4_},
    {"voo", w_voo},
    {"vooi4", w_vooi4},
    {"vooi4i4", w_vooi4i4},
    {"vooo", w_vooo},
    {"voooVs_r4r4_", w_voooVs_r4r4_},
    {"voooi4", w_voooi4},
    {"voooi4Vs_r4r4_", w_voooi4Vs_r4r4_},
    {"voooi4i4", w_voooi4i4},
    {"voor4s_r4r4_", w_voor4s_r4r4_},
    {"voos", w_voos},
    {"voos_o_", w_voos_o_},
    {"voos_r4r4_s_r4r4_", w_voos_r4r4_s_r4r4_},
    {"voos_r4r4_s_r4r4_i4i4", w_voos_r4r4_s_r4r4_i4i4},
    {"vor4", w_vor4},
    {"vor4o", w_vor4o},
    {"vos", w_vos},
    {"vosVO", w_vosVO},
    {"vos_i4_", w_vos_i4_},
    {"vos_i4p_", w_vos_i4p_},
    {"vos_o_", w_vos_o_},
    {"vos_r4r4_i4", w_vos_r4r4_i4},
    {"vos_r4r4r4_", w_vos_r4r4r4_},
    {"vos_r4r4r4_s_r4r4r4r4_", w_vos_r4r4r4_s_r4r4r4r4_},
    {"vos_r4r4r4_s_r4r4r4r4_i4", w_vos_r4r4r4_s_r4r4r4r4_i4},
    {"vos_r4r4r4_s_r4r4r4r4_oi4", w_vos_r4r4r4_s_r4r4r4r4_oi4},
    {"vos_r4r4r4_s_r4r4r4r4_oi4o", w_vos_r4r4r4_s_r4r4r4r4_oi4o},
    {"vos_r4r4r4_s_r4r4r4r4_oi4oi4", w_vos_r4r4r4_s_r4r4r4r4_oi4oi4},
    {"vos_r4r4r4_s_r4r4r4r4_oi4oi4o", w_vos_r4r4r4_s_r4r4r4r4_oi4oi4o},
    {"vos_r4r4r4_s_r4r4r4r4_oi4oi4ob", w_vos_r4r4r4_s_r4r4r4r4_oi4oi4ob},
    {"vos_r4r4r4_s_r4r4r4r4_oi4oi4obb", w_vos_r4r4r4_s_r4r4r4r4_oi4oi4obb},
    {"vos_r4r4r4_s_r4r4r4r4_oi4oi4obbb", w_vos_r4r4r4_s_r4r4r4r4_oi4oi4obbb},
    {"vos_r4r4r4_s_r4r4r4r4_oi4oi4oi4", w_vos_r4r4r4_s_r4r4r4r4_oi4oi4oi4},
    {"vos_r4r4r4_s_r4r4r4r4_oi4oi4oi4b", w_vos_r4r4r4_s_r4r4r4r4_oi4oi4oi4b},
    {"vos_r4r4r4_s_r4r4r4r4_oi4oi4oi4bo", w_vos_r4r4r4_s_r4r4r4r4_oi4oi4oi4bo},
    {"vos_r4r4r4_s_r4r4r4r4_oi4oi4oi4bob", w_vos_r4r4r4_s_r4r4r4r4_oi4oi4oi4bob},
    {"vos_r4r4r4_s_r4r4r4r4_s_r4r4r4_", w_vos_r4r4r4_s_r4r4r4r4_s_r4r4r4_},
    {"vos_r4r4r4r4_", w_vos_r4r4r4r4_},
    {"vos_r4r4r4r4r4r4_i4i4Di4DoDoDi4DbDi4", w_vos_r4r4r4r4r4r4_i4i4Di4DoDoDi4DbDi4},
    {"vos_r4r4r4r4r4r4_i4oDi4DoDoDi4DbDi4", w_vos_r4r4r4r4r4r4_i4oDi4DoDoDi4DbDi4},
    {"vos_r4r4r4r4r4r4_i4oi4Di4DoDoDi4DbDi4", w_vos_r4r4r4r4r4r4_i4oi4Di4DoDoDi4DbDi4},
    {"vos_r4r4r4r4r4r4_i4ooDi4DoDoDi4DbDi4", w_vos_r4r4r4r4r4r4_i4ooDi4DoDoDi4DbDi4},
    {"vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4", w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_i4},
    {"vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4", w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4},
    {"vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4o", w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4o},
    {"vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4", w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4},
    {"vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4o", w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4o},
    {"vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4ob", w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4ob},
    {"vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4obb", w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4obb},
    {"vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4obbb", w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4obbb},
    {"vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4", w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4},
    {"vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4b", w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4b},
    {"vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4bo", w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4bo},
    {"vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4bob", w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4bob},
    {"vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4boi4", w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4boi4},
    {"vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4boi4o", w_vos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4oi4oi4boi4o},
    {"vp", w_vp},
    {"vpPs_i8_", w_vpPs_i8_},
    {"vpPs_i8i8i8_Ps_i8i8i8_", w_vpPs_i8i8i8_Ps_i8i8i8_},
    {"vpPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_", w_vpPs_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_},
    {"vpPs_i8i8i8_ooi4pop", w_vpPs_i8i8i8_ooi4pop},
    {"vpi4", w_vpi4},
    {"vpi4Pi4Pi4Di4Di4", w_vpi4Pi4Pi4Di4Di4},
    {"vpi4Ps_i8i8i8_", w_vpi4Ps_i8i8i8_},
    {"vpi4Ps_i8i8i8_Di4Di4", w_vpi4Ps_i8i8i8_Di4Di4},
    {"vpi4Ps_i8i8i8_Ps_i8i8i8_", w_vpi4Ps_i8i8i8_Ps_i8i8i8_},
    {"vpi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_", w_vpi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8_},
    {"vpi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8i8i8i8i8_Pi8", w_vpi4Ps_i8i8i8_Ps_i8i8i8_Ps_i8i8i8i8i8i8i8_Pi8},
    {"vpi4i4", w_vpi4i4},
    {"vpi4i4Ps_i8i8i8_", w_vpi4i4Ps_i8i8i8_},
    {"vpi4i4i4", w_vpi4i4i4},
    {"vpi4i4i4i4", w_vpi4i4i4i4},
    {"vpi4i4i4i4i4o", w_vpi4i4i4i4i4o},
    {"vpi4i4i4o", w_vpi4i4i4o},
    {"vpi4o", w_vpi4o},
    {"vpi4po", w_vpi4po},
    {"vpi4ppi8", w_vpi4ppi8},
    {"vpi8", w_vpi8},
    {"vpi8Ps_i8_", w_vpi8Ps_i8_},
    {"vpi8Ps_i8i8i8_", w_vpi8Ps_i8i8i8_},
    {"vpoi4", w_vpoi4},
    {"vpoi4o", w_vpoi4o},
    {"vpoopop", w_vpoopop},
    {"vpop", w_vpop},
    {"vpp", w_vpp},
    {"vppp", w_vppp},
    {"vppu4pu4", w_vppu4pu4},
    {"vps", w_vps},
    {"vpu4", w_vpu4},
    {"vpu4Pi8Pi8i4i4Pi8i4Pi8i4", w_vpu4Pi8Pi8i4i4Pi8i4Pi8i4},
    {"vpu4Pi8i4i4Pi8i4Pi8i4", w_vpu4Pi8i4i4Pi8i4Pi8i4},
    {"vpu4Ps_i8i8i8_", w_vpu4Ps_i8i8i8_},
    {"vpu4Ps_i8i8i8_Pi8Pi8", w_vpu4Ps_i8i8i8_Pi8Pi8},
    {"vpu4Ps_i8i8i8_Ps_i8i8i8_", w_vpu4Ps_i8i8i8_Ps_i8i8i8_},
    {"vpu4Ps_i8i8i8_i4", w_vpu4Ps_i8i8i8_i4},
    {"vpu4Ps_i8i8i8_i4Pi8Pi8Pi8", w_vpu4Ps_i8i8i8_i4Pi8Pi8Pi8},
    {"vpu4Ps_i8i8i8_i4Pi8i4", w_vpu4Ps_i8i8i8_i4Pi8i4},
    {"vpu4Ps_i8i8i8_i4i4Pi8i4Pi8i4", w_vpu4Ps_i8i8i8_i4i4Pi8i4Pi8i4},
    {"vpu4Ps_i8i8i8i8_", w_vpu4Ps_i8i8i8i8_},
    {"vpu4i4", w_vpu4i4},
    {"vpu4i4Pi8", w_vpu4i4Pi8},
    {"vpu4i4Pi8Pi8", w_vpu4i4Pi8Pi8},
    {"vpu4i4Pi8Pi8Pi8Pi8i4", w_vpu4i4Pi8Pi8Pi8Pi8i4},
    {"vpu4i4Pi8Pi8i4Pi8", w_vpu4i4Pi8Pi8i4Pi8},
    {"vpu4i4i4", w_vpu4i4i4},
    {"vpu4i4i4i4", w_vpu4i4i4i4},
    {"vpu4i8", w_vpu4i8},
    {"vpu4i8i4i4", w_vpu4i8i4i4},
    {"vpu4u4i4", w_vpu4u4i4},
    {"vpu4u4i8i8i4i4", w_vpu4u4i8i8i4i4},
    {"vr4", w_vr4},
    {"vr4i4Db", w_vr4i4Db},
    {"vr4r4", w_vr4r4},
    {"vr4r4r4", w_vr4r4r4},
    {"vr4r4r4r4", w_vr4r4r4r4},
    {"vr4r4r4s", w_vr4r4r4s},
    {"vr4r4s", w_vr4r4s},
    {"vs", w_vs},
    {"vsDb", w_vsDb},
    {"vsPo", w_vsPo},
    {"vsVO", w_vsVO},
    {"vs_Ppi4i4i4pi4i4o_oDi4", w_vs_Ppi4i4i4pi4i4o_oDi4},
    {"vs_Pvi4i4i4pi4i4oi4_", w_vs_Pvi4i4i4pi4i4oi4_},
    {"vs_Pvi4i4i4pi4i4oi4_o", w_vs_Pvi4i4i4pi4i4oi4_o},
    {"vs_i4_", w_vs_i4_},
    {"vs_i4_s_i4_", w_vs_i4_s_i4_},
    {"vs_i4i2i2u1u1u1u1u1u1u1u1_i4o", w_vs_i4i2i2u1u1u1u1u1u1u1u1_i4o},
    {"vs_i4i4i4i4_", w_vs_i4i4i4i4_},
    {"vs_i4p_s_i4p_", w_vs_i4p_s_i4p_},
    {"vs_i4p_s_i4p_i4", w_vs_i4p_s_i4p_i4},
    {"vs_i4p_s_i4p_i4i4", w_vs_i4p_s_i4p_i4i4},
    {"vs_i4p_s_i4p_i4i4i4", w_vs_i4p_s_i4p_i4i4i4},
    {"vs_oi4pi4i4i4ooi4i4_", w_vs_oi4pi4i4i4ooi4i4_},
    {"vs_ooopp_", w_vs_ooopp_},
    {"vs_pi4i4_", w_vs_pi4i4_},
    {"vs_pi4i4_i4", w_vs_pi4i4_i4},
    {"vs_r4r4r4_", w_vs_r4r4r4_},
    {"vs_r4r4r4_oPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vs_r4r4r4_oPs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vs_r4r4r4_r4", w_vs_r4r4r4_r4},
    {"vs_r4r4r4_r4r4r4r4", w_vs_r4r4r4_r4r4r4r4},
    {"vs_r4r4r4_s", w_vs_r4r4r4_s},
    {"vs_r4r4r4_s_r4r4r4_", w_vs_r4r4r4_s_r4r4r4_},
    {"vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_", w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_},
    {"vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4", w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4},
    {"vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4b", w_vs_r4r4r4_s_r4r4r4_s_r4r4r4r4_r4b},
    {"vs_r4r4r4_sb", w_vs_r4r4r4_sb},
    {"vs_r4r4r4_sbs_r4r4r4r4_", w_vs_r4r4r4_sbs_r4r4r4r4_},
    {"vs_r4r4r4r4_", w_vs_r4r4r4r4_},
    {"vs_r4r4r4r4_Pr4Pr4Pr4", w_vs_r4r4r4r4_Pr4Pr4Pr4},
    {"vs_r4r4r4r4_o", w_vs_r4r4r4r4_o},
    {"vs_r4r4r4r4_oi4i4i4i4", w_vs_r4r4r4r4_oi4i4i4i4},
    {"vs_r4r4r4r4_oi4i4i4i4o", w_vs_r4r4r4r4_oi4i4i4i4o},
    {"vs_r4r4r4r4_oi4i4i4i4oi4", w_vs_r4r4r4r4_oi4i4i4i4oi4},
    {"vs_r4r4r4r4_oo", w_vs_r4r4r4r4_oo},
    {"vs_r4r4r4r4_ooi4", w_vs_r4r4r4r4_ooi4},
    {"vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4", w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4},
    {"vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4o", w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4o},
    {"vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4oi4", w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4oi4},
    {"vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4s_r4r4r4r4_", w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4s_r4r4r4r4_},
    {"vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4s_r4r4r4r4_o", w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4s_r4r4r4r4_o},
    {"vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4s_r4r4r4r4_oi4", w_vs_r4r4r4r4_os_r4r4r4r4_i4i4i4i4s_r4r4r4r4_oi4},
    {"vs_r4r4r4r4r4r4_", w_vs_r4r4r4r4r4r4_},
    {"vs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_o", w_vs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_o},
    {"vs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vs_su8u8_", w_vs_su8u8_},
    {"vs_u2_b", w_vs_u2_b},
    {"vsb", w_vsb},
    {"vsi4", w_vsi4},
    {"vso", w_vso},
    {"vsoDu4", w_vsoDu4},
    {"vsoi4", w_vsoi4},
    {"vsoi4i4", w_vsoi4i4},
    {"vsooDu4", w_vsooDu4},
    {"vsr4", w_vsr4},
    {"vss", w_vss},
    {"vss_r4r4_", w_vss_r4r4_},
    {"vss_r4r4r4r4_", w_vss_r4r4r4r4_},
    {"vss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vss_u8u8_", w_vss_u8u8_},
    {"vsso", w_vsso},
    {"vt", w_vt},
    {"vtDb", w_vtDb},
    {"vtDbDb", w_vtDbDb},
    {"vtDbDi4", w_vtDbDi4},
    {"vtDbDu1Du1Di4Di4Di4Di4", w_vtDbDu1Du1Di4Di4Di4Di4},
    {"vtDi4", w_vtDi4},
    {"vtDi4Di4", w_vtDi4Di4},
    {"vtDi4Di4Di4", w_vtDi4Di4Di4},
    {"vtDi4Di4Di4Di4", w_vtDi4Di4Di4Di4},
    {"vtDi4Di4Di4Di4Di4Di4Di4", w_vtDi4Di4Di4Di4Di4Di4Di4},
    {"vtDi4Di4Dr4Db", w_vtDi4Di4Dr4Db},
    {"vtDi4Do", w_vtDi4Do},
    {"vtDi8Di8Di8", w_vtDi8Di8Di8},
    {"vtDi8Di8Di8Di8", w_vtDi8Di8Di8Di8},
    {"vtDr4", w_vtDr4},
    {"vtDr4Dr4Dr4", w_vtDr4Dr4Dr4},
    {"vtDr4Dr4Dr4Dr4", w_vtDr4Dr4Dr4Dr4},
    {"vtDs_bi4i4_Di4Du4Di4", w_vtDs_bi4i4_Di4Du4Di4},
    {"vtO", w_vtO},
    {"vtPr4Pr4", w_vtPr4Pr4},
    {"vtPr4Pr4r4r4", w_vtPr4Pr4r4r4},
    {"vtPr4Ps_r4r4r4_", w_vtPr4Ps_r4r4r4_},
    {"vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4r4r4r4_", w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4r4r4r4_},
    {"vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4r4r4r4_", w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_Ps_i4r4r4r4_},
    {"vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_", w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_},
    {"vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_Ps_i4r4r4r4_", w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1u1_Ps_i4r4r4r4_},
    {"vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_", w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_},
    {"vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_Ps_i4r4r4r4_", w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_Ps_i4r4r4r4_},
    {"vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_", w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_},
    {"vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_Ps_i4r4r4r4_", w_vtPs_i4bu1r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u1_Ps_i4r4r4r4_},
    {"vtPs_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_", w_vtPs_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4i4i4i4u1r4r4r4r4r4r4i4_},
    {"vtPs_psu4_", w_vtPs_psu4_},
    {"vtPs_psu4_b", w_vtPs_psu4_b},
    {"vtPs_r4r4r4_Ps_r4r4r4r4_", w_vtPs_r4r4r4_Ps_r4r4r4r4_},
    {"vtPs_r4r4r4r4r4r4u4r4r4r4i4_b", w_vtPs_r4r4r4r4r4r4u4r4r4r4i4_b},
    {"vtPs_r4r4r4r4r4r4u4r4r4r4i4_bb", w_vtPs_r4r4r4r4r4r4u4r4r4r4i4_bb},
    {"vtPs_su4_", w_vtPs_su4_},
    {"vtPs_su4_b", w_vtPs_su4_b},
    {"vtVO", w_vtVO},
    {"vtVr4", w_vtVr4},
    {"vtVs_r4r4r4r4i4i4r4r4_", w_vtVs_r4r4r4r4i4i4r4r4_},
    {"vtb", w_vtb},
    {"vtbDb", w_vtbDb},
    {"vtbDs", w_vtbDs},
    {"vtbDsDsDs", w_vtbDsDsDs},
    {"vtbb", w_vtbb},
    {"vtbbs_r4r4r4r4_", w_vtbbs_r4r4r4r4_},
    {"vtbbs_r4r4r4r4_r4", w_vtbbs_r4r4r4r4_r4},
    {"vtbi4", w_vtbi4},
    {"vtbi4r4", w_vtbi4r4},
    {"vtbs", w_vtbs},
    {"vtbu1u1i4i4i4i4i4i4i4i4", w_vtbu1u1i4i4i4i4i4i4i4i4},
    {"vtco", w_vtco},
    {"vti2", w_vti2},
    {"vti2i2", w_vti2i2},
    {"vti4", w_vti4},
    {"vti4Di4", w_vti4Di4},
    {"vti4Di4Di4Di4", w_vti4Di4Di4Di4},
    {"vti4Di4Dr4", w_vti4Di4Dr4},
    {"vti4Do", w_vti4Do},
    {"vti4Dr4", w_vti4Dr4},
    {"vti4O", w_vti4O},
    {"vti4Oo", w_vti4Oo},
    {"vti4Pi4Pi4Di4Di4", w_vti4Pi4Pi4Di4Di4},
    {"vti4Pu4Pu4Pu4", w_vti4Pu4Pu4Pu4},
    {"vti4Vi4", w_vti4Vi4},
    {"vti4Vr4", w_vti4Vr4},
    {"vti4Vs_i4i4i4i4_", w_vti4Vs_i4i4i4i4_},
    {"vti4b", w_vti4b},
    {"vti4bDi4", w_vti4bDi4},
    {"vti4bb", w_vti4bb},
    {"vti4i4", w_vti4i4},
    {"vti4i4Db", w_vti4i4Db},
    {"vti4i4Di4", w_vti4i4Di4},
    {"vti4i4Ds", w_vti4i4Ds},
    {"vti4i4b", w_vti4i4b},
    {"vti4i4i4", w_vti4i4i4},
    {"vti4i4i4b", w_vti4i4i4b},
    {"vti4i4i4bb", w_vti4i4i4bb},
    {"vti4i4i4i4", w_vti4i4i4i4},
    {"vti4i4i4i4b", w_vti4i4i4i4b},
    {"vti4i4i4i4bb", w_vti4i4i4i4bb},
    {"vti4i4i4i4bp", w_vti4i4i4i4bp},
    {"vti4i4i4i4i4", w_vti4i4i4i4i4},
    {"vti4i4i4i4i4b", w_vti4i4i4i4i4b},
    {"vti4i4i4i4i4i4", w_vti4i4i4i4i4i4},
    {"vti4i4i4i4i4i4i4", w_vti4i4i4i4i4i4i4},
    {"vti4i4i4i4i4i4i4b", w_vti4i4i4i4i4i4i4b},
    {"vti4i4i4i4i4i4i4bi4", w_vti4i4i4i4i4i4i4bi4},
    {"vti4i4i4i4i4i4i4bi4b", w_vti4i4i4i4i4i4i4bi4b},
    {"vti4i4i4i4i4i4i4i4", w_vti4i4i4i4i4i4i4i4},
    {"vti4i4i4i4i4i4i4i4b", w_vti4i4i4i4i4i4i4i4b},
    {"vti4i4i4i4i4i4i4i4bb", w_vti4i4i4i4i4i4i4i4bb},
    {"vti4i4i4i4i4i4i4i4bi4", w_vti4i4i4i4i4i4i4i4bi4},
    {"vti4i4i4i4i4i4i4i4bi4b", w_vti4i4i4i4i4i4i4i4bi4b},
    {"vti4i4i4i4i4i4i4i4i4", w_vti4i4i4i4i4i4i4i4i4},
    {"vti4i4i4i4i4i4i4i4i4b", w_vti4i4i4i4i4i4i4i4i4b},
    {"vti4i4i4i4i4p", w_vti4i4i4i4i4p},
    {"vti4i4i4i4o", w_vti4i4i4i4o},
    {"vti4i4i4i4oi4", w_vti4i4i4i4oi4},
    {"vti4i4i4i8", w_vti4i4i4i8},
    {"vti4i4i4o", w_vti4i4i4o},
    {"vti4i4i4s_Pvi4i4i4pi4i4oi4_Di4", w_vti4i4i4s_Pvi4i4i4pi4i4oi4_Di4},
    {"vti4i4i4s_r4r4r4r4_", w_vti4i4i4s_r4r4r4r4_},
    {"vti4i4i4s_r4r4r4r4_i4", w_vti4i4i4s_r4r4r4r4_i4},
    {"vti4i4o", w_vti4i4o},
    {"vti4i4oi4", w_vti4i4oi4},
    {"vti4i4oi4i4", w_vti4i4oi4i4},
    {"vti4i4ooo", w_vti4i4ooo},
    {"vti4i4r4", w_vti4i4r4},
    {"vti4i4s_i8i8i8_", w_vti4i4s_i8i8i8_},
    {"vti4i4s_r4r4r4r4_", w_vti4i4s_r4r4r4r4_},
    {"vti4i4s_r4r4r4r4_i4", w_vti4i4s_r4r4r4r4_i4},
    {"vti4o", w_vti4o},
    {"vti4ob", w_vti4ob},
    {"vti4obb", w_vti4obb},
    {"vti4oi4", w_vti4oi4},
    {"vti4oi4i4", w_vti4oi4i4},
    {"vti4oi4i4i4", w_vti4oi4i4i4},
    {"vti4osVO", w_vti4osVO},
    {"vti4ou4", w_vti4ou4},
    {"vti4r4", w_vti4r4},
    {"vti4r4i4r4", w_vti4r4i4r4},
    {"vti4r4i4r4bo", w_vti4r4i4r4bo},
    {"vti4r4o", w_vti4r4o},
    {"vti4r4r4", w_vti4r4r4},
    {"vti4r4r4oDoDr4", w_vti4r4r4oDoDr4},
    {"vti4r4r4r4o", w_vti4r4r4r4o},
    {"vti4r4r4ssss", w_vti4r4r4ssss},
    {"vti4r4s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4o", w_vti4r4s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4o},
    {"vti4s", w_vti4s},
    {"vti4sO", w_vti4sO},
    {"vti4sOo", w_vti4sOo},
    {"vti4sVO", w_vti4sVO},
    {"vti4s_Pvi4i4i4pi4i4oi4_", w_vti4s_Pvi4i4i4pi4i4oi4_},
    {"vti4s_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_", w_vti4s_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_},
    {"vti4s_bi4i4i4i4_", w_vti4s_bi4i4i4i4_},
    {"vti4s_bi4i4i4i4_r4", w_vti4s_bi4i4i4i4_r4},
    {"vti4s_i4_", w_vti4s_i4_},
    {"vti4s_i4i4i4i4i4i4i4i4i4i4i4i4i4_", w_vti4s_i4i4i4i4i4i4i4i4i4i4i4i4i4_},
    {"vti4s_i4i4i4i4i4i4i4i4i4i4i4i4i4_i4", w_vti4s_i4i4i4i4i4i4i4i4i4i4i4i4i4_i4},
    {"vti4s_i4i4i4pi4i4i4_", w_vti4s_i4i4i4pi4i4i4_},
    {"vti4s_i4i4i4pi4i4i4_DbDbDb", w_vti4s_i4i4i4pi4i4i4_DbDbDb},
    {"vti4s_i4i4i4pi4i4i4_i4", w_vti4s_i4i4i4pi4i4i4_i4},
    {"vti4s_r4r4_", w_vti4s_r4r4_},
    {"vti4s_r4r4r4_", w_vti4s_r4r4r4_},
    {"vti4s_r4r4r4r4_", w_vti4s_r4r4r4r4_},
    {"vti4s_r4r4r4r4_r4u4", w_vti4s_r4r4r4r4_r4u4},
    {"vti4s_r4r4r4r4r4r4_", w_vti4s_r4r4r4r4r4r4_},
    {"vti4s_r4r4r4r4r4r4i4i4i4i4i4i4_Di4", w_vti4s_r4r4r4r4r4r4i4i4i4i4i4i4_Di4},
    {"vti4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vti4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vti4so", w_vti4so},
    {"vti4soi4", w_vti4soi4},
    {"vti4soi4i4", w_vti4soi4i4},
    {"vti4soo", w_vti4soo},
    {"vti4ss", w_vti4ss},
    {"vti4u1", w_vti4u1},
    {"vti4u8", w_vti4u8},
    {"vti8", w_vti8},
    {"vti8i8Di4Di4Di4", w_vti8i8Di4Di4Di4},
    {"vti8i8i8", w_vti8i8i8},
    {"vti8i8i8i4", w_vti8i8i8i4},
    {"vti8s", w_vti8s},
    {"vto", w_vto},
    {"vtoDb", w_vtoDb},
    {"vtoDi4", w_vtoDi4},
    {"vtoDi4Di4", w_vtoDi4Di4},
    {"vtoDi4Di4Di4", w_vtoDi4Di4Di4},
    {"vtoDo", w_vtoDo},
    {"vtoDoDoDbDbDu4Du4", w_vtoDoDoDbDbDu4Du4},
    {"vtoDr4", w_vtoDr4},
    {"vtoO", w_vtoO},
    {"vtoOi4", w_vtoOi4},
    {"vtoPs_psu4_", w_vtoPs_psu4_},
    {"vtoPs_psu4_b", w_vtoPs_psu4_b},
    {"vtob", w_vtob},
    {"vtobDbDb", w_vtobDbDb},
    {"vtobb", w_vtobb},
    {"vtobbb", w_vtobbb},
    {"vtobi4", w_vtobi4},
    {"vtobi4i4", w_vtobi4i4},
    {"vtoi4", w_vtoi4},
    {"vtoi4Db", w_vtoi4Db},
    {"vtoi4DbDi4", w_vtoi4DbDi4},
    {"vtoi4Vi4", w_vtoi4Vi4},
    {"vtoi4Vr4", w_vtoi4Vr4},
    {"vtoi4Vs", w_vtoi4Vs},
    {"vtoi4Vs_r4r4r4r4_", w_vtoi4Vs_r4r4r4r4_},
    {"vtoi4Vs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vtoi4Vs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vtoi4b", w_vtoi4b},
    {"vtoi4bi4", w_vtoi4bi4},
    {"vtoi4i4", w_vtoi4i4},
    {"vtoi4i4DbDi4", w_vtoi4i4DbDi4},
    {"vtoi4i4Di4", w_vtoi4i4Di4},
    {"vtoi4i4b", w_vtoi4i4b},
    {"vtoi4i4bi4", w_vtoi4i4bi4},
    {"vtoi4i4i4", w_vtoi4i4i4},
    {"vtoi4i4i4DbDi4", w_vtoi4i4i4DbDi4},
    {"vtoi4i4i4i4", w_vtoi4i4i4i4},
    {"vtoi4i4i4i4DbDi4", w_vtoi4i4i4i4DbDi4},
    {"vtoi4i4i4i4i4i4i4i4o", w_vtoi4i4i4i4i4i4i4i4o},
    {"vtoi4i4i4i4i4i4i4o", w_vtoi4i4i4i4i4i4i4o},
    {"vtoi4i4o", w_vtoi4i4o},
    {"vtoi4i4r4r4", w_vtoi4i4r4r4},
    {"vtoi4i4s_i4i4i4pi4i4i4_", w_vtoi4i4s_i4i4i4pi4i4i4_},
    {"vtoi4i4s_i4i4i4pi4i4i4_i4", w_vtoi4i4s_i4i4i4pi4i4i4_i4},
    {"vtoi4i4s_i4i4i4pi4i4i4_i4i4", w_vtoi4i4s_i4i4i4pi4i4i4_i4i4},
    {"vtoi4o", w_vtoi4o},
    {"vtoi4oi4i4", w_vtoi4oi4i4},
    {"vtoi4oi4i4Do", w_vtoi4oi4i4Do},
    {"vtoi4oi4o", w_vtoi4oi4o},
    {"vtoi4oi4oi4", w_vtoi4oi4oi4},
    {"vtoi4oi4oi4o", w_vtoi4oi4oi4o},
    {"vtoi4ou4", w_vtoi4ou4},
    {"vtoi4r4", w_vtoi4r4},
    {"vtoi4s_i4i4i4pi4i4i4_", w_vtoi4s_i4i4i4pi4i4i4_},
    {"vtoi4s_r4r4r4r4_", w_vtoi4s_r4r4r4r4_},
    {"vtoi4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vtoi4s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vtoi4so", w_vtoi4so},
    {"vtoi4ss_i4i4i4pi4i4i4_", w_vtoi4ss_i4i4i4pi4i4i4_},
    {"vtoi4ss_i4i4i4pi4i4i4_i4", w_vtoi4ss_i4i4i4pi4i4i4_i4},
    {"vtoi4ss_i4i4i4pi4i4i4_i4i4", w_vtoi4ss_i4i4i4pi4i4i4_i4i4},
    {"vtoo", w_vtoo},
    {"vtooDb", w_vtooDb},
    {"vtooDbDbDu4Du4", w_vtooDbDbDu4Du4},
    {"vtooi4", w_vtooi4},
    {"vtooi4b", w_vtooi4b},
    {"vtooi4i4", w_vtooi4i4},
    {"vtooi4i4i4", w_vtooi4i4i4},
    {"vtooo", w_vtooo},
    {"vtooos_i4i4i4pi4i4i4_i4i4", w_vtooos_i4i4i4pi4i4i4_i4i4},
    {"vtoor4", w_vtoor4},
    {"vtoor4r4", w_vtoor4r4},
    {"vtoou4", w_vtoou4},
    {"vtor4", w_vtor4},
    {"vtor4b", w_vtor4b},
    {"vtos", w_vtos},
    {"vtosODi4", w_vtosODi4},
    {"vtosVi4", w_vtosVi4},
    {"vtosVr4", w_vtosVr4},
    {"vtosVs_r4r4r4r4_", w_vtosVs_r4r4r4r4_},
    {"vtosVs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vtosVs_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vtos_Oi4_", w_vtos_Oi4_},
    {"vtos_i4i4i4pi4i4i4_", w_vtos_i4i4i4pi4i4i4_},
    {"vtos_i4i4i4pi4i4i4_i4i4i4", w_vtos_i4i4i4pi4i4i4_i4i4i4},
    {"vtos_i4i4i4pi4i4i4_o", w_vtos_i4i4i4pi4i4i4_o},
    {"vtos_i4i4i4pi4i4i4_oi4", w_vtos_i4i4i4pi4i4i4_oi4},
    {"vtos_i4i4i4pi4i4i4_s_r4r4_s_r4r4_", w_vtos_i4i4i4pi4i4i4_s_r4r4_s_r4r4_},
    {"vtos_i4p_", w_vtos_i4p_},
    {"vtos_i4p_i4", w_vtos_i4p_i4},
    {"vtos_i4p_i4i4", w_vtos_i4p_i4i4},
    {"vtos_i4p_i4i4ooi4i4", w_vtos_i4p_i4i4ooi4i4},
    {"vtos_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_o", w_vtos_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_o},
    {"vtos_r4r4r4_", w_vtos_r4r4r4_},
    {"vtos_r4r4r4r4_", w_vtos_r4r4r4r4_},
    {"vtos_r4r4r4r4_b", w_vtos_r4r4r4r4_b},
    {"vtos_r4r4r4r4_bs_r4r4_s_r4r4_", w_vtos_r4r4r4r4_bs_r4r4_s_r4r4_},
    {"vtos_r4r4r4r4_r4s_r4r4r4r4_", w_vtos_r4r4r4r4_r4s_r4r4r4r4_},
    {"vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_o", w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_o},
    {"vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4", w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4},
    {"vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4", w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4},
    {"vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4", w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4},
    {"vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4", w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4},
    {"vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4o", w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4o},
    {"vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4o", w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4o},
    {"vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4", w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4},
    {"vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4o", w_vtos_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4o},
    {"vtosi4", w_vtosi4},
    {"vtosi4i4", w_vtosi4i4},
    {"vtoso", w_vtoso},
    {"vtosoi4i4", w_vtosoi4i4},
    {"vtosr4", w_vtosr4},
    {"vtoss", w_vtoss},
    {"vtoss_i4i4i4pi4i4i4_", w_vtoss_i4i4i4pi4i4i4_},
    {"vtoss_r4r4r4r4_", w_vtoss_r4r4r4r4_},
    {"vtoss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vtoss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vtosu4u4u4Do", w_vtosu4u4u4Do},
    {"vtou4", w_vtou4},
    {"vtou4obDbDbDu4DbDu4", w_vtou4obDbDbDu4DbDu4},
    {"vtou4os_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_bDbDbDu4DbDu4", w_vtou4os_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_bDbDbDu4DbDu4},
    {"vtp", w_vtp},
    {"vtpDb", w_vtpDb},
    {"vtpi4", w_vtpi4},
    {"vtpi4p", w_vtpi4p},
    {"vtpou4", w_vtpou4},
    {"vtpu4s_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_u4u4", w_vtpu4s_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_u4u4},
    {"vtr4", w_vtr4},
    {"vtr4b", w_vtr4b},
    {"vtr4i4", w_vtr4i4},
    {"vtr4i4o", w_vtr4i4o},
    {"vtr4i4oO", w_vtr4i4oO},
    {"vtr4o", w_vtr4o},
    {"vtr4r4", w_vtr4r4},
    {"vtr4r4b", w_vtr4r4b},
    {"vtr4r4i4s_r4r4r4r4_s_r4r4r4r4_", w_vtr4r4i4s_r4r4r4r4_s_r4r4r4r4_},
    {"vtr4r4os_r4r4r4r4_", w_vtr4r4os_r4r4r4r4_},
    {"vtr4r4os_r4r4r4r4_r4s_r4r4r4r4_", w_vtr4r4os_r4r4r4r4_r4s_r4r4r4r4_},
    {"vtr4r4r4", w_vtr4r4r4},
    {"vtr4r4r4Di4Di4", w_vtr4r4r4Di4Di4},
    {"vtr4r4r4i4", w_vtr4r4r4i4},
    {"vtr4r4r4o", w_vtr4r4r4o},
    {"vtr4r4r4r4", w_vtr4r4r4r4},
    {"vtr4r4r4r4b", w_vtr4r4r4r4b},
    {"vtr4r4r4r4r4", w_vtr4r4r4r4r4},
    {"vtr4r4r4r4r4r4", w_vtr4r4r4r4r4r4},
    {"vtr4r4s", w_vtr4r4s},
    {"vtr4r4s_r4r4r4r4_", w_vtr4r4s_r4r4r4r4_},
    {"vtr4r4s_r4r4r4r4_o", w_vtr4r4s_r4r4r4r4_o},
    {"vtr4s_r4r4r4r4_b", w_vtr4s_r4r4r4r4_b},
    {"vtr4s_r4r4r4r4_s_r4r4r4r4_", w_vtr4s_r4r4r4r4_s_r4r4r4r4_},
    {"vtr4s_r4r4r4r4_s_r4r4r4r4_r4r4r4r4", w_vtr4s_r4r4r4r4_s_r4r4r4r4_r4r4r4r4},
    {"vtr4s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4r4", w_vtr4s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_r4r4},
    {"vtr8", w_vtr8},
    {"vts", w_vts},
    {"vtsDi4Di4Di4", w_vtsDi4Di4Di4},
    {"vtsDoDoDsDsDs", w_vtsDoDoDsDsDs},
    {"vtsDr4Di4", w_vtsDr4Di4},
    {"vtsDsDs", w_vtsDsDs},
    {"vtsO", w_vtsO},
    {"vtsOi4", w_vtsOi4},
    {"vtsOo", w_vtsOo},
    {"vtsPs", w_vtsPs},
    {"vtsVO", w_vtsVO},
    {"vtsVi4", w_vtsVi4},
    {"vtsVo", w_vtsVo},
    {"vtsVr4", w_vtsVr4},
    {"vts_Pu1i4i4i4i4pi4i4_", w_vts_Pu1i4i4i4i4pi4i4_},
    {"vts_Pvi4i4i4pi4i4oi4_", w_vts_Pvi4i4i4pi4i4oi4_},
    {"vts_Pvi4i4i4pi4i4oi4_Db", w_vts_Pvi4i4i4pi4i4oi4_Db},
    {"vts_Pvi4i4i4pi4i4oi4_bb", w_vts_Pvi4i4i4pi4i4oi4_bb},
    {"vts_Pvi4i4i4pi4i4oi4_i4Db", w_vts_Pvi4i4i4pi4i4oi4_i4Db},
    {"vts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_", w_vts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_},
    {"vts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_Db", w_vts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_Db},
    {"vts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_bb", w_vts_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_bb},
    {"vts_br4r4r4r4_", w_vts_br4r4r4r4_},
    {"vts_i2i2_", w_vts_i2i2_},
    {"vts_i4_", w_vts_i4_},
    {"vts_i4_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_o", w_vts_i4_s_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_o},
    {"vts_i4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vts_i4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vts_i4i2i2u1u1u1u1u1u1u1u1_o", w_vts_i4i2i2u1u1u1u1u1u1u1u1_o},
    {"vts_i4i4_", w_vts_i4i4_},
    {"vts_i4i4_s_i4i4_", w_vts_i4i4_s_i4i4_},
    {"vts_i4i4i4_", w_vts_i4i4i4_},
    {"vts_i4i4i4_s_i4i4i4_", w_vts_i4i4i4_s_i4i4i4_},
    {"vts_i4i4i4i4_", w_vts_i4i4i4i4_},
    {"vts_i4i4i4i4b_", w_vts_i4i4i4i4b_},
    {"vts_i4i4i4i4i4i4_", w_vts_i4i4i4i4i4i4_},
    {"vts_i4i4i4i4i4i4i4i4i4i4i4i4i4_", w_vts_i4i4i4i4i4i4i4i4i4i4i4i4i4_},
    {"vts_i4i4i4pi4i4i4_", w_vts_i4i4i4pi4i4i4_},
    {"vts_i4i4i4pi4i4i4_b", w_vts_i4i4i4pi4i4i4_b},
    {"vts_i4i4i4pi4i4i4_bb", w_vts_i4i4i4pi4i4i4_bb},
    {"vts_i4i4i4pi4i4i4_i4", w_vts_i4i4i4pi4i4i4_i4},
    {"vts_i4i4i4pi4i4i4_i4Di4Di4", w_vts_i4i4i4pi4i4i4_i4Di4Di4},
    {"vts_i4i4i4pi4i4i4_i4i4", w_vts_i4i4i4pi4i4i4_i4i4},
    {"vts_i4i4i4pi4i4i4_i4i4i4", w_vts_i4i4i4pi4i4i4_i4i4i4},
    {"vts_i4i4i4pi4i4i4_i4i4i4i4", w_vts_i4i4i4pi4i4i4_i4i4i4i4},
    {"vts_i4i4i4pi4i4i4_i4i4i4i4i4i4s_i4i4i4pi4i4i4_i4i4i4i4", w_vts_i4i4i4pi4i4i4_i4i4i4i4i4i4s_i4i4i4pi4i4i4_i4i4i4i4},
    {"vts_i4i4i4pi4i4i4_i4i4s_i4i4i4pi4i4i4_i4i4", w_vts_i4i4i4pi4i4i4_i4i4s_i4i4i4pi4i4i4_i4i4},
    {"vts_i4i4i4pi4i4i4_i4r4b", w_vts_i4i4i4pi4i4i4_i4r4b},
    {"vts_i4i4i4pi4i4i4_i4s_i4i4i4pi4i4i4_i4", w_vts_i4i4i4pi4i4i4_i4s_i4i4i4pi4i4i4_i4},
    {"vts_i4i4i4pi4i4i4_pi4i4i4i4i4i4", w_vts_i4i4i4pi4i4i4_pi4i4i4i4i4i4},
    {"vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_", w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_},
    {"vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_i4", w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_i4},
    {"vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_i4i4", w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_i4i4},
    {"vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_i4i4i4", w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_i4i4i4},
    {"vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_o", w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_o},
    {"vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_oi4", w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_oi4},
    {"vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_oi4i4", w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_oi4i4},
    {"vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_s_r4r4_s_r4r4_", w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_s_r4r4_s_r4r4_},
    {"vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_s_r4r4_s_r4r4_i4i4", w_vts_i4i4i4pi4i4i4_s_i4i4i4pi4i4i4_s_r4r4_s_r4r4_i4i4},
    {"vts_i4i4r4u1u1u1u1_", w_vts_i4i4r4u1u1u1u1_},
    {"vts_i4p_Di4Di4Di4", w_vts_i4p_Di4Di4Di4},
    {"vts_i4p_s_i4p_", w_vts_i4p_s_i4p_},
    {"vts_i4p_s_i4p_i4", w_vts_i4p_s_i4p_i4},
    {"vts_i4p_s_i4p_i4i4", w_vts_i4p_s_i4p_i4i4},
    {"vts_i4p_s_i4p_i4i4i4", w_vts_i4p_s_i4p_i4i4i4},
    {"vts_i4r4r4r4r4r4i4_", w_vts_i4r4r4r4r4r4i4_},
    {"vts_i4u1r4r4r4r4r4r4_", w_vts_i4u1r4r4r4r4r4r4_},
    {"vts_i4u1u1u1u1_", w_vts_i4u1u1u1u1_},
    {"vts_i8_s_i8_s_i8_", w_vts_i8_s_i8_s_i8_},
    {"vts_i8_s_i8_s_i8_s_i8_", w_vts_i8_s_i8_s_i8_s_i8_},
    {"vts_i8i8i8_", w_vts_i8i8i8_},
    {"vts_i8i8i8_i4", w_vts_i8i8i8_i4},
    {"vts_i8i8i8i8_", w_vts_i8i8i8i8_},
    {"vts_oi4i4i4pi4i4i4ooi4i4i4_", w_vts_oi4i4i4pi4i4i4ooi4i4i4_},
    {"vts_oi4i4i4pi4i4i4ooi4i4i4_i4i4i4", w_vts_oi4i4i4pi4i4i4ooi4i4i4_i4i4i4},
    {"vts_oi4pi4i4i4ooi4i4_", w_vts_oi4pi4i4i4ooi4i4_},
    {"vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_", w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_},
    {"vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_Ps_i4i4i4u4i4i2i2_", w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_Ps_i4i4i4u4i4i2i2_},
    {"vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_Ps_i4i4i4u4i4i2i2_Ps_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_", w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_Ps_i4i4i4u4i4i2i2_Ps_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_},
    {"vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_Ps_i4i4i4u4i4i2i2_s_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_", w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_Ps_i4i4i4u4i4i2i2_s_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_},
    {"vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_Ps_i4i4i4u4i4i2i2_s_i4_bs_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_", w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4i4i4i4i4_Ps_i4i4i4u4i4i2i2_s_i4_bs_Pvi4i4i4pi4i4oi4_s_Pvi4i4i4pi4i4oi4_},
    {"vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_i4", w_vts_pPs_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4_Ps_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4i4i4_i4i4i4_pi4i4_i4},
    {"vts_pi4i4_", w_vts_pi4i4_},
    {"vts_pi4i4_i4", w_vts_pi4i4_i4},
    {"vts_pu4_", w_vts_pu4_},
    {"vts_pu4_s_u8r8r4r4r8r4r4i4pu4_", w_vts_pu4_s_u8r8r4r4r8r4r4i4pu4_},
    {"vts_pu4_s_u8r8r4r4r8r4r4i4pu4_O", w_vts_pu4_s_u8r8r4r4r8r4r4i4pu4_O},
    {"vts_pu4u4_", w_vts_pu4u4_},
    {"vts_r4r4_", w_vts_r4r4_},
    {"vts_r4r4_b", w_vts_r4r4_b},
    {"vts_r4r4_bb", w_vts_r4r4_bb},
    {"vts_r4r4_s_r4r4_", w_vts_r4r4_s_r4r4_},
    {"vts_r4r4i4i4i4_i4o", w_vts_r4r4i4i4i4_i4o},
    {"vts_r4r4i4i4i4_o", w_vts_r4r4i4i4i4_o},
    {"vts_r4r4r4_", w_vts_r4r4r4_},
    {"vts_r4r4r4_Db", w_vts_r4r4r4_Db},
    {"vts_r4r4r4_i4", w_vts_r4r4r4_i4},
    {"vts_r4r4r4_o", w_vts_r4r4r4_o},
    {"vts_r4r4r4_r4", w_vts_r4r4r4_r4},
    {"vts_r4r4r4_r4i4", w_vts_r4r4r4_r4i4},
    {"vts_r4r4r4_s_i4u1u1u1u1_", w_vts_r4r4r4_s_i4u1u1u1u1_},
    {"vts_r4r4r4_s_i4u1u1u1u1_s_r4r4_", w_vts_r4r4r4_s_i4u1u1u1u1_s_r4r4_},
    {"vts_r4r4r4_s_r4r4r4_", w_vts_r4r4r4_s_r4r4r4_},
    {"vts_r4r4r4_s_r4r4r4_r4", w_vts_r4r4r4_s_r4r4r4_r4},
    {"vts_r4r4r4_s_r4r4r4_s_r4r4r4_", w_vts_r4r4r4_s_r4r4r4_s_r4r4r4_},
    {"vts_r4r4r4_s_r4r4r4r4_", w_vts_r4r4r4_s_r4r4r4r4_},
    {"vts_r4r4r4_s_r4r4r4r4_r4", w_vts_r4r4r4_s_r4r4r4r4_r4},
    {"vts_r4r4r4_s_r4r4r4r4_s_r4r4r4_", w_vts_r4r4r4_s_r4r4r4r4_s_r4r4r4_},
    {"vts_r4r4r4r4_", w_vts_r4r4r4r4_},
    {"vts_r4r4r4r4_Dr4", w_vts_r4r4r4r4_Dr4},
    {"vts_r4r4r4r4_Dr4Du4", w_vts_r4r4r4r4_Dr4Du4},
    {"vts_r4r4r4r4_bb", w_vts_r4r4r4r4_bb},
    {"vts_r4r4r4r4_i4i4", w_vts_r4r4r4r4_i4i4},
    {"vts_r4r4r4r4_i4i4b", w_vts_r4r4r4r4_i4i4b},
    {"vts_r4r4r4r4_r4", w_vts_r4r4r4r4_r4},
    {"vts_r4r4r4r4_r4i4o", w_vts_r4r4r4r4_r4i4o},
    {"vts_r4r4r4r4_s_i4u1u1u1u1_", w_vts_r4r4r4r4_s_i4u1u1u1u1_},
    {"vts_r4r4r4r4_s_i4u1u1u1u1_s_r4r4r4r4_", w_vts_r4r4r4r4_s_i4u1u1u1u1_s_r4r4r4r4_},
    {"vts_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_", w_vts_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_s_r4r4r4r4_},
    {"vts_r4r4r4r4r4r4_", w_vts_r4r4r4r4r4r4_},
    {"vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_", w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_},
    {"vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_", w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_},
    {"vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_", w_vts_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_s_r4r4r4r4r4r4r4r4r4i4b_},
    {"vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4", w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4},
    {"vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4", w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4},
    {"vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4o", w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4i4i4o},
    {"vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4o", w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4o},
    {"vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4", w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4},
    {"vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4o", w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_oi4i4oi4o},
    {"vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_", w_vts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4u4u1u1r4r4r4r4r4i4i4u4i4u4i4i4_},
    {"vts_su4bbb_", w_vts_su4bbb_},
    {"vts_u1i1_", w_vts_u1i1_},
    {"vts_u1u1u1u1u1u1u1u1_", w_vts_u1u1u1u1u1u1u1u1_},
    {"vts_u1u1u1u1u1u1u1u1u1u1u1u1_", w_vts_u1u1u1u1u1u1u1u1u1u1u1u1_},
    {"vts_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_", w_vts_u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2_},
    {"vts_u8u8_", w_vts_u8u8_},
    {"vtsb", w_vtsb},
    {"vtsbbbbsi4b", w_vtsbbbbsi4b},
    {"vtsbi4", w_vtsbi4},
    {"vtsbsDi4", w_vtsbsDi4},
    {"vtsi4", w_vtsi4},
    {"vtsi4Vo", w_vtsi4Vo},
    {"vtsi4bbbbsi4", w_vtsi4bbbbsi4},
    {"vtsi4i4", w_vtsi4i4},
    {"vtsi4i4i4Do", w_vtsi4i4i4Do},
    {"vtsi4o", w_vtsi4o},
    {"vtsi4sVo", w_vtsi4sVo},
    {"vtsi8i8", w_vtsi8i8},
    {"vtso", w_vtso},
    {"vtsoDb", w_vtsoDb},
    {"vtsoDs", w_vtsoDs},
    {"vtsob", w_vtsob},
    {"vtsoi4", w_vtsoi4},
    {"vtsoi4i4", w_vtsoi4i4},
    {"vtsooDsDs", w_vtsooDsDs},
    {"vtsooi4", w_vtsooi4},
    {"vtsooo", w_vtsooo},
    {"vtsooooooi4o", w_vtsooooooi4o},
    {"vtsos_r4r4_", w_vtsos_r4r4_},
    {"vtsr4", w_vtsr4},
    {"vtsr4ooo", w_vtsr4ooo},
    {"vtsr4r4", w_vtsr4r4},
    {"vtss", w_vtss},
    {"vtss_i4i4i4pi4i4i4_", w_vtss_i4i4i4pi4i4i4_},
    {"vtss_i4i4i4pi4i4i4_i4", w_vtss_i4i4i4pi4i4i4_i4},
    {"vtss_r4r4_", w_vtss_r4r4_},
    {"vtss_r4r4r4r4_", w_vtss_r4r4r4r4_},
    {"vtss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", w_vtss_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"vtss_u8u8_", w_vtss_u8u8_},
    {"vtssi4", w_vtssi4},
    {"vtsss", w_vtsss},
    {"vtssss", w_vtssss},
    {"vtsu4i4i8bbi8b", w_vtsu4i4i8bbi8b},
    {"vtu1", w_vtu1},
    {"vtu1u1u1u1", w_vtu1u1u1u1},
    {"vtu2oDi4Di4", w_vtu2oDi4Di4},
    {"vtu2ob", w_vtu2ob},
    {"vtu4", w_vtu4},
    {"vtu4b", w_vtu4b},
    {"vtu4bbb", w_vtu4bbb},
    {"vtu4i4", w_vtu4i4},
    {"vtu4i4b", w_vtu4i4b},
    {"vtu4i4i4i4", w_vtu4i4i4i4},
    {"vtu4i4i8i8", w_vtu4i4i8i8},
    {"vtu4i4i8i8i4i8", w_vtu4i4i8i8i4i8},
    {"vtu4i4i8i8i8i8Di4", w_vtu4i4i8i8i8i8Di4},
    {"vtu4i8", w_vtu4i8},
    {"vtu4i8bb", w_vtu4i8bb},
    {"vtu4i8bbi8i4i8b", w_vtu4i8bbi8i4i8b},
    {"vtu4i8i8bbi8i4i8b", w_vtu4i8i8bbi8i4i8b},
    {"vtu4i8i8i8", w_vtu4i8i8i8},
    {"vtu4i8i8i8Db", w_vtu4i8i8i8Db},
    {"vtu4i8i8i8i8", w_vtu4i8i8i8i8},
    {"vtu4i8i8i8i8bb", w_vtu4i8i8i8i8bb},
    {"vtu4i8i8i8i8bi8i8", w_vtu4i8i8i8i8bi8i8},
    {"vtu4s_i8i8i8_", w_vtu4s_i8i8i8_},
    {"vtu4s_i8i8i8_bbi8i4i8b", w_vtu4s_i8i8i8_bbi8i4i8b},
    {"vtu4s_i8i8i8_i8i8", w_vtu4s_i8i8i8_i8i8},
    {"vtu4s_i8i8i8_s_i8i8i8_", w_vtu4s_i8i8i8_s_i8i8i8_},
    {"vtu4s_r4r4r4r4_s_br4r4r4r4_", w_vtu4s_r4r4r4r4_s_br4r4r4r4_},
    {"vtu4u4b", w_vtu4u4b},
    {"vtu4u4i4", w_vtu4u4i4},
    {"vtu4u4i8i8i4i4", w_vtu4u4i8i8i4i4},
    {"vtu4u4u4u4", w_vtu4u4u4u4},
    {"vtu8", w_vtu8},
    {"vtu8u8", w_vtu8u8},
    {"vu1u1", w_vu1u1},
    {"vu1u1s", w_vu1u1s},
    {"vu2u2", w_vu2u2},
    {"vu2u2s", w_vu2u2s},
    {"vu4", w_vu4},
    {"vu4u4", w_vu4u4},
    {"vu4u4s", w_vu4u4s},
    {"vu8", w_vu8},
    {"vu8u8", w_vu8u8},
    {"vu8u8s", w_vu8u8s},
    {nullptr, nullptr}
};


static void* b_O(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_O");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_OO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_OO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_OVO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_OVO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    auto arrayLength = GetArrayLength(p0);
    v8::Local<v8::Value> *Argv = (v8::Local<v8::Value> *)alloca(sizeof(v8::Local<v8::Value>) * (0 + arrayLength));
    memset(Argv, 0, sizeof(v8::Local<v8::Value>) * (0 + arrayLength));
    
    RestArguments<void*>::UnPackRefOrBoxedValueType(context, p0, arrayLength, TIp0, Argv + 0);
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1 + arrayLength - 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oi4popb(void* target, int32_t p0, void* p1, void* p2, void* p3, bool p4, void* method) {
    // PLog(LogLevel::Log, "Running b_Oi4popb");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate),
        converter::Converter<bool>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oo(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_Oo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Ooo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_Ooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oooo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_Oooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oppi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_Oppi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Os_oooObr4r4r4r4bb_(void* target, struct s_oooObr4r4r4r4bb_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_Os_oooObr4r4r4r4bb_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_Oso(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_Oso");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_OssoPi4(void* target, void* p0, void* p1, void* p2, int32_t* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_OssoPi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static bool b_b(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_b");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bO");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bOooi4(void* target, void* p0, void* p1, void* p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bOooi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bPs(void* target, void** p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bPs");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_(void* target, struct s_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bb(void* target, bool p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bb");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<bool>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bi4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bi4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bi4i4i4po(void* target, int32_t p0, int32_t p1, int32_t p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_bi4i4i4po");

    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bo(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bo");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_boO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boPi4(void* target, void* p0, int32_t* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_boPi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boPsPs(void* target, void* p0, void** p1, void** p2, void* method) {
    // PLog(LogLevel::Log, "Running b_boPsPs");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        v8::Undefined(isolate),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_boi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boi4O(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_boi4O");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_boo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_booi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_booi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boooi4(void* target, void* p0, void* p1, void* p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_boooi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_booso(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_booso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_boso(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_boso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bososo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_bososo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSAnyToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bosso(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bosso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bosss(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bosss");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2),
        CSAnyToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bossss(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_bossss");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2),
        CSAnyToJsValue(isolate, context, p3),
        CSAnyToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bp(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bp");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bs");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bsO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_bsO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_i4ss_(void* target, struct s_i4ss_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_i4ss_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_r4r4_Ps_r4r4r4_Ps_r4r4r4_(void* target, struct s_r4r4_ p0, struct s_r4r4r4_* p1, struct s_r4r4r4_* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_r4r4_Ps_r4r4r4_Ps_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        v8::Undefined(isolate),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_sOO_(void* target, struct s_sOO_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_sOO_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_u8_(void* target, struct s_u8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_u8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bs_u8u8u4u4u4u4i4oo_oo(void* target, struct s_u8u8u4u4u4u4i4oo_ p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_bs_u8u8u4u4u4u4i4oo_oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bsbi4s(void* target, void* p0, bool p1, int32_t p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bsbi4s");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2),
        CSAnyToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bso(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_bso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bsooi4(void* target, void* p0, void* p1, void* p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_bsooi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static bool b_bu1o(void* target, uint8_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_bu1o");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<uint8_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    bool ret = converter::Converter<bool>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static Il2CppChar b_csi4c(void* target, void* p0, int32_t p1, Il2CppChar p2, void* method) {
    // PLog(LogLevel::Log, "Running b_csi4c");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<Il2CppChar>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    Il2CppChar ret = converter::Converter<Il2CppChar>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int16_t b_i2os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i2os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int16_t ret = converter::Converter<int16_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4i4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_i4i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4i4i4ob(void* target, int32_t p0, int32_t p1, void* p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_i4i4i4ob");

    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4i4sb(void* target, int32_t p0, void* p1, bool p2, void* method) {
    // PLog(LogLevel::Log, "Running b_i4i4sb");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<bool>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_i4o");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4ob(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i4ob");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4oi4o(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_i4oi4o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4oo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i4oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4ooo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_i4ooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4oooo(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_i4oooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i4os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4os_r4r4r4_s_r4r4_ob(void* target, void* p0, struct s_r4r4r4_ p1, struct s_r4r4_ p2, void* p3, bool p4, void* method) {
    // PLog(LogLevel::Log, "Running b_i4os_r4r4r4_s_r4r4_ob");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        CSRefToJsValue(isolate, context, p3),
        converter::Converter<bool>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4s_oooObr4r4r4r4bboooObr4r4r4r4bbb_(void* target, struct s_oooObr4r4r4r4bboooObr4r4r4r4bbb_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_i4s_oooObr4r4r4r4bboooObr4r4r4r4bbb_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int32_t b_i4ss(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i4ss");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int32_t ret = converter::Converter<int32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int64_t b_i8o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_i8o");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int64_t ret = converter::Converter<int64_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static int64_t b_i8os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_i8os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    int64_t ret = converter::Converter<int64_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static void* b_o(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_o");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_oO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oOo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oOo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oOs(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oOs");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oOsooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_oOsooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_(void* target, struct s_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_oPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ob(void* target, bool p0, void* method) {
    // PLog(LogLevel::Log, "Running b_ob");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<bool>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_oi4");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi4oo(void* target, int32_t p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oi4oo");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi4popb(void* target, int32_t p0, void* p1, void* p2, void* p3, bool p4, void* method) {
    // PLog(LogLevel::Log, "Running b_oi4popb");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate),
        converter::Converter<bool>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi4s(void* target, int32_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oi4s");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oi8oo(void* target, int64_t p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oi8oo");

    auto TIret = GetReturnType(method);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<int64_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oo(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_oo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_ooO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_ooi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooi4i4(void* target, void* p0, int32_t p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_ooi4i4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooi4s_r4r4_ooPi4(void* target, void* p0, int32_t p1, struct s_r4r4_ p2, void* p3, void* p4, int32_t* p5, void* method) {
    // PLog(LogLevel::Log, "Running b_ooi4s_r4r4_ooPi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[6]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 6, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_ooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooO(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oooO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oooi4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooi8o(void* target, void* p0, void* p1, int64_t p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_oooi8o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int64_t>::toScript(context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooO(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSAnyToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooO(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSAnyToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[6]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 6, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[7]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 7, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[8]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 8, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[9]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 9, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[10]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 10, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[11]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 11, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[12]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 12, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[13]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 13, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[14]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 14, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* p14, void* method) {
    // PLog(LogLevel::Log, "Running b_oooooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);
    auto TIp14 = GetParameterType(method, 14);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[15]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13),
        CSRefToJsValue(isolate, context, p14)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 15, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* p14, void* p15, void* method) {
    // PLog(LogLevel::Log, "Running b_ooooooooooooooooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);
    auto TIp14 = GetParameterType(method, 14);
    auto TIp15 = GetParameterType(method, 15);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[16]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13),
        CSRefToJsValue(isolate, context, p14),
        CSRefToJsValue(isolate, context, p15)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 16, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooor4(void* target, void* p0, void* p1, float p2, void* method) {
    // PLog(LogLevel::Log, "Running b_ooor4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<float>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooos_r4r4_i4(void* target, void* p0, void* p1, struct s_r4r4_ p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_ooos_r4r4_i4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oos(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oos");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oos_r4r4_(void* target, void* p0, struct s_r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oos_r4r4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oosb(void* target, void* p0, void* p1, bool p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oosb");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<bool>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_ooso(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_ooso");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oosu8(void* target, void* p0, void* p1, uint64_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oosu8");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<uint64_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oou4u4(void* target, void* p0, uint32_t p1, uint32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_oou4u4");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<uint32_t>::toScript(context, p1),
        converter::Converter<uint32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_os(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_os");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_os_i4i4_(void* target, struct s_i4i4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_os_i4i4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_os_r4r4r4r4_o(void* target, struct s_r4r4r4r4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_os_r4r4r4r4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_osi4o(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_osi4o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_osooo(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_osooo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_oss(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_oss");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_osso(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_osso");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal o/O
    void* ret = JsValueToCSRef(context, MaybeRet.ToLocalChecked(), TIret);
    return ret;
        
}

static void* b_pp(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_pp");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    void* ret = DataTransfer::GetPointer<void>(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static void* b_pppi4i8(void* target, void* p0, void* p1, int32_t p2, int64_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_pppi4i8");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p2),
        converter::Converter<int64_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    void* ret = DataTransfer::GetPointer<void>(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_r4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4i4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r4i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r4o");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4oos_r4r4r4_(void* target, void* p0, void* p1, struct s_r4r4r4_ p2, void* method) {
    // PLog(LogLevel::Log, "Running b_r4oos_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_r4os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4r4(void* target, float p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r4r4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<float>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4r4Ps_r4r4r4r4_(void* target, float p0, struct s_r4r4r4r4_* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_r4r4Ps_r4r4r4r4_");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<float>::toScript(context, p0),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static float b_r4s_r4r4r4_(void* target, struct s_r4r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r4s_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    float ret = converter::Converter<float>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static double b_r8(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_r8");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    double ret = converter::Converter<double>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static double b_r8o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_r8o");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    double ret = converter::Converter<double>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static double b_r8os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_r8os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    double ret = converter::Converter<double>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static void* b_s(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_s");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_sO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_sO");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static struct s__ b_s__(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_s__");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s__* pret = DataTransfer::GetPointer<s__>(context, MaybeRet.ToLocalChecked());
    s__ ret = pret ? *pret : s__ {};
    return ret;
        
}

static struct s_bi4_ b_s_bi4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_bi4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_bi4_* pret = DataTransfer::GetPointer<s_bi4_>(context, MaybeRet.ToLocalChecked());
    s_bi4_ ret = pret ? *pret : s_bi4_ {};
    return ret;
        
}

static struct s_bi4i4i4i4u8_ b_s_bi4i4i4i4u8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_bi4i4i4i4u8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_bi4i4i4i4u8_* pret = DataTransfer::GetPointer<s_bi4i4i4i4u8_>(context, MaybeRet.ToLocalChecked());
    s_bi4i4i4i4u8_ ret = pret ? *pret : s_bi4i4i4i4u8_ {};
    return ret;
        
}

static struct s_bi8_ b_s_bi8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_bi8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_bi8_* pret = DataTransfer::GetPointer<s_bi8_>(context, MaybeRet.ToLocalChecked());
    s_bi8_ ret = pret ? *pret : s_bi8_ {};
    return ret;
        
}

static struct s_bo_ b_s_bo_s(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_bo_s");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_bo_* pret = DataTransfer::GetPointer<s_bo_>(context, MaybeRet.ToLocalChecked());
    s_bo_ ret = pret ? *pret : s_bo_ {};
    return ret;
        
}

static struct s_br4_ b_s_br4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_br4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_br4_* pret = DataTransfer::GetPointer<s_br4_>(context, MaybeRet.ToLocalChecked());
    s_br4_ ret = pret ? *pret : s_br4_ {};
    return ret;
        
}

static struct s_br8_ b_s_br8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_br8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_br8_* pret = DataTransfer::GetPointer<s_br8_>(context, MaybeRet.ToLocalChecked());
    s_br8_ ret = pret ? *pret : s_br8_ {};
    return ret;
        
}

static struct s_i4i4_ b_s_i4i4_s_i4i4_(void* target, struct s_i4i4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_i4i4_s_i4i4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_i4i4_* pret = DataTransfer::GetPointer<s_i4i4_>(context, MaybeRet.ToLocalChecked());
    s_i4i4_ ret = pret ? *pret : s_i4i4_ {};
    return ret;
        
}

static struct s_i4i4i4i4u8_ b_s_i4i4i4i4u8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_i4i4i4i4u8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_i4i4i4i4u8_* pret = DataTransfer::GetPointer<s_i4i4i4i4u8_>(context, MaybeRet.ToLocalChecked());
    s_i4i4i4i4u8_ ret = pret ? *pret : s_i4i4i4i4u8_ {};
    return ret;
        
}

static struct s_ooor4r4_ b_s_ooor4r4_s_ooor4r4_(void* target, struct s_ooor4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_ooor4r4_s_ooor4r4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_ooor4r4_* pret = DataTransfer::GetPointer<s_ooor4r4_>(context, MaybeRet.ToLocalChecked());
    s_ooor4r4_ ret = pret ? *pret : s_ooor4r4_ {};
    return ret;
        
}

static struct s_ossi4i4i4i4o_ b_s_ossi4i4i4i4o_s_ossi4i4i4i4o_(void* target, struct s_ossi4i4i4i4o_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_ossi4i4i4i4o_s_ossi4i4i4i4o_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_ossi4i4i4i4o_* pret = DataTransfer::GetPointer<s_ossi4i4i4i4o_>(context, MaybeRet.ToLocalChecked());
    s_ossi4i4i4i4o_ ret = pret ? *pret : s_ossi4i4i4i4o_ {};
    return ret;
        
}

static struct s_pi4_ b_s_pi4_os_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(void* target, void* p0, struct s_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_s_pi4_os_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_pi4_* pret = DataTransfer::GetPointer<s_pi4_>(context, MaybeRet.ToLocalChecked());
    s_pi4_ ret = pret ? *pret : s_pi4_ {};
    return ret;
        
}

static struct s_r4r4_ b_s_r4r4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4_* pret = DataTransfer::GetPointer<s_r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4_ ret = pret ? *pret : s_r4r4_ {};
    return ret;
        
}

static struct s_r4r4_ b_s_r4r4_s_r4r4_(void* target, struct s_r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4_s_r4r4_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4_* pret = DataTransfer::GetPointer<s_r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4_ ret = pret ? *pret : s_r4r4_ {};
    return ret;
        
}

static struct s_r4r4r4_ b_s_r4r4r4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4r4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4r4_* pret = DataTransfer::GetPointer<s_r4r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4r4_ ret = pret ? *pret : s_r4r4r4_ {};
    return ret;
        
}

static struct s_r4r4r4r4_ b_s_r4r4r4r4_(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4r4r4_");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pret = DataTransfer::GetPointer<s_r4r4r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4r4r4_ ret = pret ? *pret : s_r4r4r4r4_ {};
    return ret;
        
}

static struct s_r4r4r4r4_ b_s_r4r4r4r4_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4r4r4_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4_* pret = DataTransfer::GetPointer<s_r4r4r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4r4r4_ ret = pret ? *pret : s_r4r4r4r4_ {};
    return ret;
        
}

static struct s_r4r4r4r4r4r4_ b_s_r4r4r4r4r4r4_(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_s_r4r4r4r4r4r4_");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_r4r4r4r4r4r4_* pret = DataTransfer::GetPointer<s_r4r4r4r4r4r4_>(context, MaybeRet.ToLocalChecked());
    s_r4r4r4r4r4r4_ ret = pret ? *pret : s_r4r4r4r4r4r4_ {};
    return ret;
        
}

static struct s_u8_ b_s_u8_o(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_s_u8_o");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal struct
    s_u8_* pret = DataTransfer::GetPointer<s_u8_>(context, MaybeRet.ToLocalChecked());
    s_u8_ ret = pret ? *pret : s_u8_ {};
    return ret;
        
}

static void* b_si4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_si4");

    auto TIret = GetReturnType(method);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_so(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_so");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_sob(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_sob");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_soo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_soo");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_sos(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_sos");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_ss(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_ss");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_ss_oi4osi4u1u1u1u1_(void* target, struct s_oi4osi4u1u1u1u1_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_ss_oi4osi4u1u1u1u1_");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_ssbs(void* target, void* p0, bool p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_ssbs");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static void* b_sso(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_sso");

    auto TIret = GetReturnType(method);
    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal s
    v8::String::Utf8Value tret(isolate, MaybeRet.ToLocalChecked());
    void* ret = CStringToCSharpString(*tret);
    return ret;
        
}

static uint16_t b_u2os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_u2os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    uint16_t ret = converter::Converter<uint16_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static uint32_t b_u4os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_u4os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    uint32_t ret = converter::Converter<uint32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static uint32_t b_u4u4pu4(void* target, uint32_t p0, void* p1, uint32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_u4u4pu4");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<uint32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        converter::Converter<uint32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    uint32_t ret = converter::Converter<uint32_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static uint64_t b_u8os(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_u8os");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
        return {};
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
        return {};
    }
    if (MaybeRet.IsEmpty())
    {
        return {};
    }
    
    // JSValToCSVal P any
    uint64_t ret = converter::Converter<uint64_t>::toCpp(context, MaybeRet.ToLocalChecked());
    return ret;
        
}

static void b_v(void* target, void* method) {
    // PLog(LogLevel::Log, "Running b_v");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> *Argv = nullptr;
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 0, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vO(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vO");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vODo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vODo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vOO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOb(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vOb");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vOo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOoi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vOoi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOsO(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vOsO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOs_Oi4_(void* target, void* p0, struct s_Oi4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vOs_Oi4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vOs_Oi4_o(void* target, void* p0, struct s_Oi4_ p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vOs_Oi4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vPs_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_(void* target, struct s_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vPs_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vb(void* target, bool p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vb");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<bool>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vbbi4(void* target, bool p0, bool p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vbbi4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<bool>::toScript(context, p0),
        converter::Converter<bool>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vbs(void* target, bool p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vbs");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<bool>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vbso(void* target, bool p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vbso");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<bool>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4(void* target, int32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4O(void* target, int32_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4O");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4b(void* target, int32_t p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4b");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4i4(void* target, int32_t p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4i4i4p(void* target, int32_t p0, int32_t p1, int32_t p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4i4i4p");

    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4i8i8b(void* target, int32_t p0, int64_t p1, int64_t p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4i8i8b");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<int64_t>::toScript(context, p1),
        converter::Converter<int64_t>::toScript(context, p2),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4o(void* target, int32_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4o");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4oi4i4(void* target, int32_t p0, void* p1, int32_t p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4oi4i4");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4ooo(void* target, int32_t p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4ooo");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4popO(void* target, int32_t p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4popO");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate),
        CSAnyToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4popo(void* target, int32_t p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4popo");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p2),
        v8::Undefined(isolate),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4s(void* target, int32_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4s");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4s_r4r4r4_s_r4r4r4r4_r4i4(void* target, int32_t p0, struct s_r4r4r4_ p1, struct s_r4r4r4r4_ p2, float p3, int32_t p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4s_r4r4r4_s_r4r4r4r4_r4i4");

    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        converter::Converter<int32_t>::toScript(context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        converter::Converter<float>::toScript(context, p3),
        converter::Converter<int32_t>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4s_r4r4r4r4_(void* target, int32_t p0, struct s_r4r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4s_r4r4r4r4_");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int32_t>::toScript(context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi4u4u4(void* target, int32_t p0, uint32_t p1, uint32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vi4u4u4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<int32_t>::toScript(context, p0),
        converter::Converter<uint32_t>::toScript(context, p1),
        converter::Converter<uint32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi8(void* target, int64_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vi8");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<int64_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi8i4(void* target, int64_t p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi8i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int64_t>::toScript(context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi8i8(void* target, int64_t p0, int64_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi8i8");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int64_t>::toScript(context, p0),
        converter::Converter<int64_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vi8o(void* target, int64_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vi8o");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<int64_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vo(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vo");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSRefToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voO(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_voO");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vob(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vob");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4i4(void* target, void* p0, int32_t p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4o(void* target, void* p0, int32_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4oo(void* target, void* p0, int32_t p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi4s_r4r4_(void* target, void* p0, int32_t p1, struct s_r4r4_ p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voi4s_r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi8(void* target, void* p0, int64_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_voi8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int64_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voi8i8i8i8i8i8i8(void* target, void* p0, int64_t p1, int64_t p2, int64_t p3, int64_t p4, int64_t p5, int64_t p6, int64_t p7, void* method) {
    // PLog(LogLevel::Log, "Running b_voi8i8i8i8i8i8i8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[8]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<int64_t>::toScript(context, p1),
        converter::Converter<int64_t>::toScript(context, p2),
        converter::Converter<int64_t>::toScript(context, p3),
        converter::Converter<int64_t>::toScript(context, p4),
        converter::Converter<int64_t>::toScript(context, p5),
        converter::Converter<int64_t>::toScript(context, p6),
        converter::Converter<int64_t>::toScript(context, p7)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 8, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voo(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_voo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vooi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooi8(void* target, void* p0, void* p1, int64_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vooi8");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        converter::Converter<int64_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooo(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_voooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[6]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 6, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[7]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 7, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[8]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 8, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[9]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 9, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[10]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 10, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[11]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 11, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[12]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 12, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[13]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 13, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[14]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 14, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* p14, void* method) {
    // PLog(LogLevel::Log, "Running b_vooooooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);
    auto TIp14 = GetParameterType(method, 14);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[15]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13),
        CSRefToJsValue(isolate, context, p14)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 15, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voooooooooooooooo(void* target, void* p0, void* p1, void* p2, void* p3, void* p4, void* p5, void* p6, void* p7, void* p8, void* p9, void* p10, void* p11, void* p12, void* p13, void* p14, void* p15, void* method) {
    // PLog(LogLevel::Log, "Running b_voooooooooooooooo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp4 = GetParameterType(method, 4);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);
    auto TIp7 = GetParameterType(method, 7);
    auto TIp8 = GetParameterType(method, 8);
    auto TIp9 = GetParameterType(method, 9);
    auto TIp10 = GetParameterType(method, 10);
    auto TIp11 = GetParameterType(method, 11);
    auto TIp12 = GetParameterType(method, 12);
    auto TIp13 = GetParameterType(method, 13);
    auto TIp14 = GetParameterType(method, 14);
    auto TIp15 = GetParameterType(method, 15);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[16]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3),
        CSRefToJsValue(isolate, context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6),
        CSRefToJsValue(isolate, context, p7),
        CSRefToJsValue(isolate, context, p8),
        CSRefToJsValue(isolate, context, p9),
        CSRefToJsValue(isolate, context, p10),
        CSRefToJsValue(isolate, context, p11),
        CSRefToJsValue(isolate, context, p12),
        CSRefToJsValue(isolate, context, p13),
        CSRefToJsValue(isolate, context, p14),
        CSRefToJsValue(isolate, context, p15)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 16, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voos(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voos");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vor4(void* target, void* p0, float p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vor4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<float>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vor8(void* target, void* p0, double p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vor8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<double>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_Pvi4i4i4pi4i4oi4_(void* target, void* p0, struct s_Pvi4i4i4pi4i4oi4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_Pvi4i4i4pi4i4oi4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_i4_(void* target, void* p0, struct s_i4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_i4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_i4_ob(void* target, void* p0, struct s_i4_ p1, void* p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_i4_ob");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        CSRefToJsValue(isolate, context, p2),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_i4i4i4i4_b(void* target, void* p0, struct s_i4i4i4i4_ p1, bool p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_i4i4i4i4_b");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        converter::Converter<bool>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_oi4osi4u1u1u1u1_(void* target, void* p0, struct s_oi4osi4u1u1u1u1_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_oi4osi4u1u1u1u1_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_r4r4_(void* target, void* p0, struct s_r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_r4r4_r4(void* target, void* p0, struct s_r4r4_ p1, float p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_r4r4_r4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        converter::Converter<float>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_r4r4r4_(void* target, void* p0, struct s_r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_r4r4r4r4_(void* target, void* p0, struct s_r4r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_r4r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vos_sosi4i4i4i4i4_i4(void* target, void* p0, struct s_sosi4i4i4i4i4_ p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vos_sosi4i4i4i4i4_i4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1)),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vosb(void* target, void* p0, void* p1, bool p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vosb");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<bool>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vosbsr4oo(void* target, void* p0, void* p1, bool p2, void* p3, float p4, void* p5, void* p6, void* method) {
    // PLog(LogLevel::Log, "Running b_vosbsr4oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp3 = GetParameterType(method, 3);
    auto TIp5 = GetParameterType(method, 5);
    auto TIp6 = GetParameterType(method, 6);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[7]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<bool>::toScript(context, p2),
        CSAnyToJsValue(isolate, context, p3),
        converter::Converter<float>::toScript(context, p4),
        CSRefToJsValue(isolate, context, p5),
        CSRefToJsValue(isolate, context, p6)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 7, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voso(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_voso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_voss_i4i4i4i4_b(void* target, void* p0, void* p1, struct s_i4i4i4i4_ p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_voss_i4i4i4i4_b");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSRefToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2)),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vou1s(void* target, void* p0, uint8_t p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vou1s");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<uint8_t>::toScript(context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vou4(void* target, void* p0, uint32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vou4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSRefToJsValue(isolate, context, p0),
        converter::Converter<uint32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vp(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vp");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vpi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpi4ppi8(void* target, void* p0, int32_t p1, void* p2, void* p3, int64_t p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vpi4ppi8");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p1),
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int64_t>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpi4u4u4(void* target, void* p0, int32_t p1, uint32_t p2, uint32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vpi4u4u4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<uint32_t>::toScript(context, p2),
        converter::Converter<uint32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpi8(void* target, void* p0, int64_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vpi8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        v8::Undefined(isolate),
        converter::Converter<int64_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpppi4(void* target, void* p0, void* p1, void* p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vpppi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpppi4i8(void* target, void* p0, void* p1, void* p2, int32_t p3, int64_t p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vpppi4i8");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        converter::Converter<int32_t>::toScript(context, p3),
        converter::Converter<int64_t>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpr4r4r4r4r4r4(void* target, void* p0, float p1, float p2, float p3, float p4, float p5, float p6, void* method) {
    // PLog(LogLevel::Log, "Running b_vpr4r4r4r4r4r4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[7]{
        v8::Undefined(isolate),
        converter::Converter<float>::toScript(context, p1),
        converter::Converter<float>::toScript(context, p2),
        converter::Converter<float>::toScript(context, p3),
        converter::Converter<float>::toScript(context, p4),
        converter::Converter<float>::toScript(context, p5),
        converter::Converter<float>::toScript(context, p6)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 7, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpu2i4p(void* target, void* p0, uint16_t p1, int32_t p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vpu2i4p");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        v8::Undefined(isolate),
        converter::Converter<uint16_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpu4(void* target, void* p0, uint32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vpu4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        v8::Undefined(isolate),
        converter::Converter<uint32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpu4u4(void* target, void* p0, uint32_t p1, uint32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vpu4u4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        v8::Undefined(isolate),
        converter::Converter<uint32_t>::toScript(context, p1),
        converter::Converter<uint32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vpu4u4u4i4(void* target, void* p0, uint32_t p1, uint32_t p2, uint32_t p3, int32_t p4, void* method) {
    // PLog(LogLevel::Log, "Running b_vpu4u4u4i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[5]{
        v8::Undefined(isolate),
        converter::Converter<uint32_t>::toScript(context, p1),
        converter::Converter<uint32_t>::toScript(context, p2),
        converter::Converter<uint32_t>::toScript(context, p3),
        converter::Converter<int32_t>::toScript(context, p4)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 5, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vr4(void* target, float p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vr4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<float>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vr4Ps_r4r4r4r4_Pr4Pr4(void* target, float p0, struct s_r4r4r4r4_* p1, float* p2, float* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vr4Ps_r4r4r4r4_Pr4Pr4");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<float>::toScript(context, p0),
        v8::Undefined(isolate),
        v8::Undefined(isolate),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vr4b(void* target, float p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vr4b");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<float>::toScript(context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs(void* target, void* p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CSAnyToJsValue(isolate, context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_Oi4_(void* target, struct s_Oi4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_Oi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs__(void* target, struct s__ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs__");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_(void* target, struct s_i4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_b(void* target, struct s_i4_ p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_b");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_i4(void* target, struct s_i4_ p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_i4i4(void* target, struct s_i4_ p0, int32_t p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_i4i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_s(void* target, struct s_i4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_s");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_s_Pvi4i4i4pi4i4oi4_(void* target, struct s_i4_ p0, struct s_Pvi4i4i4pi4i4oi4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_s_Pvi4i4i4pi4i4oi4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4_s_i4_(void* target, struct s_i4_ p0, struct s_i4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4_s_i4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i4_(void* target, struct s_i4i4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i4i4pi4i4i4_o(void* target, struct s_i4i4i4pi4i4i4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i4i4pi4i4i4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_(void* target, struct s_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i8_(void* target, struct s_i4i8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4i8_o(void* target, struct s_i4i8_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4i8_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4o_(void* target, struct s_i4o_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4o_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4oooo_(void* target, struct s_i4oooo_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4oooo_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4osu8i8_(void* target, struct s_i4osu8i8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4osu8i8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4r4r4i4_(void* target, struct s_i4r4r4i4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4r4r4i4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4ss_(void* target, struct s_i4ss_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4ss_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i4u1u1_(void* target, struct s_i4u1u1_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i4u1u1_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_i8i8_(void* target, struct s_i8i8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_i8i8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_oo_(void* target, struct s_oo_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_oo_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_oob_(void* target, struct s_oob_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_oob_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_oooObr4r4r4r4bb_(void* target, struct s_oooObr4r4r4r4bb_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_oooObr4r4r4r4bb_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_ossi4i4i4i4o_(void* target, struct s_ossi4i4i4i4o_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_ossi4i4i4i4o_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_pi4_(void* target, struct s_pi4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_pi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_pi4_o(void* target, struct s_pi4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_pi4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_ppi4i4_o(void* target, struct s_ppi4i4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_ppi4i4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_pu4_(void* target, struct s_pu4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_pu4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4_(void* target, struct s_r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4oi4_(void* target, struct s_r4r4oi4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4oi4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4_(void* target, struct s_r4r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_(void* target, struct s_r4r4r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_i4(void* target, struct s_r4r4r4r4_ p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_i4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_i4bb(void* target, struct s_r4r4r4r4_ p0, int32_t p1, bool p2, bool p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_i4bb");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        converter::Converter<int32_t>::toScript(context, p1),
        converter::Converter<bool>::toScript(context, p2),
        converter::Converter<bool>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_o(void* target, struct s_r4r4r4r4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_r4r4r4r4_oo(void* target, struct s_r4r4r4r4_ p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_r4r4r4r4_oo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_so_(void* target, struct s_so_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_so_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_soo_(void* target, struct s_soo_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_soo_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_ss_(void* target, struct s_ss_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_ss_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_u4u4u4u4_o(void* target, struct s_u4u4u4u4_ p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_u4u4u4u4_o");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0)),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_u8_(void* target, struct s_u8_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_u8_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_u8b_(void* target, struct s_u8b_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_u8b_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vs_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_(void* target, struct s_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_ p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vs_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        CopyValueType(isolate, context, TIp0, &p0, sizeof(p0))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsb(void* target, void* p0, bool p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vsb");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsbs(void* target, void* p0, bool p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsbs");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1),
        CSAnyToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsbs_Pvi4i4i4pi4i4oi4i4i4i4_(void* target, void* p0, bool p1, struct s_Pvi4i4i4pi4i4oi4i4i4i4_ p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsbs_Pvi4i4i4pi4i4oi4i4i4i4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<bool>::toScript(context, p1),
        CopyValueType(isolate, context, TIp2, &p2, sizeof(p2))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsi4(void* target, void* p0, int32_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vsi4");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<int32_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsi8(void* target, void* p0, int64_t p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vsi8");

    auto TIp0 = GetParameterType(method, 0);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        converter::Converter<int64_t>::toScript(context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vso(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsoo(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsoo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSRefToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vss(void* target, void* p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vss");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vss_r4r4r4r4_(void* target, void* p0, struct s_r4r4r4r4_ p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vss_r4r4r4r4_");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        CSAnyToJsValue(isolate, context, p0),
        CopyValueType(isolate, context, TIp1, &p1, sizeof(p1))
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vssi4(void* target, void* p0, void* p1, int32_t p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vssi4");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        converter::Converter<int32_t>::toScript(context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vsso(void* target, void* p0, void* p1, void* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vsso");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vssoo(void* target, void* p0, void* p1, void* p2, void* p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vssoo");

    auto TIp0 = GetParameterType(method, 0);
    auto TIp1 = GetParameterType(method, 1);
    auto TIp2 = GetParameterType(method, 2);
    auto TIp3 = GetParameterType(method, 3);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        CSAnyToJsValue(isolate, context, p0),
        CSAnyToJsValue(isolate, context, p1),
        CSRefToJsValue(isolate, context, p2),
        CSRefToJsValue(isolate, context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vu1(void* target, uint8_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vu1");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<uint8_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vu4(void* target, uint32_t p0, void* method) {
    // PLog(LogLevel::Log, "Running b_vu4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[1]{
        converter::Converter<uint32_t>::toScript(context, p0)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 1, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vu4u4Ps_ppi4i4p_(void* target, uint32_t p0, uint32_t p1, struct s_ppi4i4p_* p2, void* method) {
    // PLog(LogLevel::Log, "Running b_vu4u4Ps_ppi4i4p_");

    auto TIp2 = GetParameterType(method, 2);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[3]{
        converter::Converter<uint32_t>::toScript(context, p0),
        converter::Converter<uint32_t>::toScript(context, p1),
        v8::Undefined(isolate)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 3, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vu4u4u4i4(void* target, uint32_t p0, uint32_t p1, uint32_t p2, int32_t p3, void* method) {
    // PLog(LogLevel::Log, "Running b_vu4u4u4i4");


    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[4]{
        converter::Converter<uint32_t>::toScript(context, p0),
        converter::Converter<uint32_t>::toScript(context, p1),
        converter::Converter<uint32_t>::toScript(context, p2),
        converter::Converter<int32_t>::toScript(context, p3)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 4, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static void b_vu8o(void* target, uint64_t p0, void* p1, void* method) {
    // PLog(LogLevel::Log, "Running b_vu8o");

    auto TIp1 = GetParameterType(method, 1);

    PersistentObjectInfo* delegateInfo = GetObjectData(target, PersistentObjectInfo);
    if (delegateInfo->JsEnvLifeCycleTracker.expired())
    {
        ThrowInvalidOperationException("JsEnv had been destroy");
    }
    v8::Isolate* isolate = delegateInfo->EnvInfo->Isolate;
    v8::Isolate::Scope isolateScope(isolate);
    v8::HandleScope HandleScope(isolate);
    auto context = delegateInfo->EnvInfo->Context.Get(isolate);
    v8::Context::Scope ContextScope(context);

    v8::TryCatch TryCatch(isolate);
    auto Function = delegateInfo->JsObject.Get(isolate).As<v8::Function>();
    v8::Local<v8::Value> Argv[2]{
        converter::Converter<uint64_t>::toScript(context, p0),
        CSRefToJsValue(isolate, context, p1)
    };
    auto MaybeRet = Function->Call(context, v8::Undefined(isolate), 2, Argv);
    
    if (TryCatch.HasCaught())
    {
        auto msg = DataTransfer::ExceptionToString(isolate, TryCatch.Exception());
        ThrowInvalidOperationException(msg.c_str());
    }
}

static BridgeFuncInfo g_bridgeFuncInfos[] = {
    
    {"O", (MethodPointer)b_O},
    {"OO", (MethodPointer)b_OO},
    {"OVO", (MethodPointer)b_OVO},
    {"Oi4popb", (MethodPointer)b_Oi4popb},
    {"Oo", (MethodPointer)b_Oo},
    {"Ooo", (MethodPointer)b_Ooo},
    {"Oooo", (MethodPointer)b_Oooo},
    {"Oppi4", (MethodPointer)b_Oppi4},
    {"Os_oooObr4r4r4r4bb_", (MethodPointer)b_Os_oooObr4r4r4r4bb_},
    {"Oso", (MethodPointer)b_Oso},
    {"OssoPi4", (MethodPointer)b_OssoPi4},
    {"b", (MethodPointer)b_b},
    {"bO", (MethodPointer)b_bO},
    {"bOooi4", (MethodPointer)b_bOooi4},
    {"bPs", (MethodPointer)b_bPs},
    {"bPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_", (MethodPointer)b_bPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_},
    {"bb", (MethodPointer)b_bb},
    {"bi4", (MethodPointer)b_bi4},
    {"bi4i4i4po", (MethodPointer)b_bi4i4i4po},
    {"bo", (MethodPointer)b_bo},
    {"boO", (MethodPointer)b_boO},
    {"boPi4", (MethodPointer)b_boPi4},
    {"boPsPs", (MethodPointer)b_boPsPs},
    {"boi4", (MethodPointer)b_boi4},
    {"boi4O", (MethodPointer)b_boi4O},
    {"boo", (MethodPointer)b_boo},
    {"booi4", (MethodPointer)b_booi4},
    {"boooi4", (MethodPointer)b_boooi4},
    {"booso", (MethodPointer)b_booso},
    {"boso", (MethodPointer)b_boso},
    {"bososo", (MethodPointer)b_bososo},
    {"bosso", (MethodPointer)b_bosso},
    {"bosss", (MethodPointer)b_bosss},
    {"bossss", (MethodPointer)b_bossss},
    {"bp", (MethodPointer)b_bp},
    {"bs", (MethodPointer)b_bs},
    {"bsO", (MethodPointer)b_bsO},
    {"bs_i4ss_", (MethodPointer)b_bs_i4ss_},
    {"bs_r4r4_Ps_r4r4r4_Ps_r4r4r4_", (MethodPointer)b_bs_r4r4_Ps_r4r4r4_Ps_r4r4r4_},
    {"bs_sOO_", (MethodPointer)b_bs_sOO_},
    {"bs_u8_", (MethodPointer)b_bs_u8_},
    {"bs_u8u8u4u4u4u4i4oo_oo", (MethodPointer)b_bs_u8u8u4u4u4u4i4oo_oo},
    {"bsbi4s", (MethodPointer)b_bsbi4s},
    {"bso", (MethodPointer)b_bso},
    {"bsooi4", (MethodPointer)b_bsooi4},
    {"bu1o", (MethodPointer)b_bu1o},
    {"csi4c", (MethodPointer)b_csi4c},
    {"i2os", (MethodPointer)b_i2os},
    {"i4", (MethodPointer)b_i4},
    {"i4i4", (MethodPointer)b_i4i4},
    {"i4i4i4ob", (MethodPointer)b_i4i4i4ob},
    {"i4i4sb", (MethodPointer)b_i4i4sb},
    {"i4o", (MethodPointer)b_i4o},
    {"i4ob", (MethodPointer)b_i4ob},
    {"i4oi4o", (MethodPointer)b_i4oi4o},
    {"i4oo", (MethodPointer)b_i4oo},
    {"i4ooo", (MethodPointer)b_i4ooo},
    {"i4oooo", (MethodPointer)b_i4oooo},
    {"i4os", (MethodPointer)b_i4os},
    {"i4os_r4r4r4_s_r4r4_ob", (MethodPointer)b_i4os_r4r4r4_s_r4r4_ob},
    {"i4s_oooObr4r4r4r4bboooObr4r4r4r4bbb_", (MethodPointer)b_i4s_oooObr4r4r4r4bboooObr4r4r4r4bbb_},
    {"i4ss", (MethodPointer)b_i4ss},
    {"i8o", (MethodPointer)b_i8o},
    {"i8os", (MethodPointer)b_i8os},
    {"o", (MethodPointer)b_o},
    {"oO", (MethodPointer)b_oO},
    {"oOo", (MethodPointer)b_oOo},
    {"oOs", (MethodPointer)b_oOs},
    {"oOsooo", (MethodPointer)b_oOsooo},
    {"oPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_", (MethodPointer)b_oPs_Ps_u4u4i8i8i8i8i8i8i4u4u4c_pi4pi4pi4_},
    {"ob", (MethodPointer)b_ob},
    {"oi4", (MethodPointer)b_oi4},
    {"oi4oo", (MethodPointer)b_oi4oo},
    {"oi4popb", (MethodPointer)b_oi4popb},
    {"oi4s", (MethodPointer)b_oi4s},
    {"oi8oo", (MethodPointer)b_oi8oo},
    {"oo", (MethodPointer)b_oo},
    {"ooO", (MethodPointer)b_ooO},
    {"ooi4", (MethodPointer)b_ooi4},
    {"ooi4i4", (MethodPointer)b_ooi4i4},
    {"ooi4s_r4r4_ooPi4", (MethodPointer)b_ooi4s_r4r4_ooPi4},
    {"ooo", (MethodPointer)b_ooo},
    {"oooO", (MethodPointer)b_oooO},
    {"oooi4", (MethodPointer)b_oooi4},
    {"oooi8o", (MethodPointer)b_oooi8o},
    {"oooo", (MethodPointer)b_oooo},
    {"ooooO", (MethodPointer)b_ooooO},
    {"ooooo", (MethodPointer)b_ooooo},
    {"oooooO", (MethodPointer)b_oooooO},
    {"oooooo", (MethodPointer)b_oooooo},
    {"ooooooo", (MethodPointer)b_ooooooo},
    {"oooooooo", (MethodPointer)b_oooooooo},
    {"ooooooooo", (MethodPointer)b_ooooooooo},
    {"oooooooooo", (MethodPointer)b_oooooooooo},
    {"ooooooooooo", (MethodPointer)b_ooooooooooo},
    {"oooooooooooo", (MethodPointer)b_oooooooooooo},
    {"ooooooooooooo", (MethodPointer)b_ooooooooooooo},
    {"oooooooooooooo", (MethodPointer)b_oooooooooooooo},
    {"ooooooooooooooo", (MethodPointer)b_ooooooooooooooo},
    {"oooooooooooooooo", (MethodPointer)b_oooooooooooooooo},
    {"ooooooooooooooooo", (MethodPointer)b_ooooooooooooooooo},
    {"ooor4", (MethodPointer)b_ooor4},
    {"ooos_r4r4_i4", (MethodPointer)b_ooos_r4r4_i4},
    {"oos", (MethodPointer)b_oos},
    {"oos_r4r4_", (MethodPointer)b_oos_r4r4_},
    {"oosb", (MethodPointer)b_oosb},
    {"ooso", (MethodPointer)b_ooso},
    {"oosu8", (MethodPointer)b_oosu8},
    {"oou4u4", (MethodPointer)b_oou4u4},
    {"os", (MethodPointer)b_os},
    {"os_i4i4_", (MethodPointer)b_os_i4i4_},
    {"os_r4r4r4r4_o", (MethodPointer)b_os_r4r4r4r4_o},
    {"osi4o", (MethodPointer)b_osi4o},
    {"osooo", (MethodPointer)b_osooo},
    {"oss", (MethodPointer)b_oss},
    {"osso", (MethodPointer)b_osso},
    {"pp", (MethodPointer)b_pp},
    {"pppi4i8", (MethodPointer)b_pppi4i8},
    {"r4", (MethodPointer)b_r4},
    {"r4i4", (MethodPointer)b_r4i4},
    {"r4o", (MethodPointer)b_r4o},
    {"r4oos_r4r4r4_", (MethodPointer)b_r4oos_r4r4r4_},
    {"r4os", (MethodPointer)b_r4os},
    {"r4r4", (MethodPointer)b_r4r4},
    {"r4r4Ps_r4r4r4r4_", (MethodPointer)b_r4r4Ps_r4r4r4r4_},
    {"r4s_r4r4r4_", (MethodPointer)b_r4s_r4r4r4_},
    {"r8", (MethodPointer)b_r8},
    {"r8o", (MethodPointer)b_r8o},
    {"r8os", (MethodPointer)b_r8os},
    {"s", (MethodPointer)b_s},
    {"sO", (MethodPointer)b_sO},
    {"s__", (MethodPointer)b_s__},
    {"s_bi4_o", (MethodPointer)b_s_bi4_o},
    {"s_bi4i4i4i4u8_o", (MethodPointer)b_s_bi4i4i4i4u8_o},
    {"s_bi8_o", (MethodPointer)b_s_bi8_o},
    {"s_bo_s", (MethodPointer)b_s_bo_s},
    {"s_br4_o", (MethodPointer)b_s_br4_o},
    {"s_br8_o", (MethodPointer)b_s_br8_o},
    {"s_i4i4_s_i4i4_", (MethodPointer)b_s_i4i4_s_i4i4_},
    {"s_i4i4i4i4u8_o", (MethodPointer)b_s_i4i4i4i4u8_o},
    {"s_ooor4r4_s_ooor4r4_", (MethodPointer)b_s_ooor4r4_s_ooor4r4_},
    {"s_ossi4i4i4i4o_s_ossi4i4i4i4o_", (MethodPointer)b_s_ossi4i4i4i4o_s_ossi4i4i4i4o_},
    {"s_pi4_os_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", (MethodPointer)b_s_pi4_os_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4i4r4r4r4r4r4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"s_r4r4_o", (MethodPointer)b_s_r4r4_o},
    {"s_r4r4_s_r4r4_", (MethodPointer)b_s_r4r4_s_r4r4_},
    {"s_r4r4r4_o", (MethodPointer)b_s_r4r4r4_o},
    {"s_r4r4r4r4_", (MethodPointer)b_s_r4r4r4r4_},
    {"s_r4r4r4r4_o", (MethodPointer)b_s_r4r4r4r4_o},
    {"s_r4r4r4r4r4r4_", (MethodPointer)b_s_r4r4r4r4r4r4_},
    {"s_u8_o", (MethodPointer)b_s_u8_o},
    {"si4", (MethodPointer)b_si4},
    {"so", (MethodPointer)b_so},
    {"sob", (MethodPointer)b_sob},
    {"soo", (MethodPointer)b_soo},
    {"sos", (MethodPointer)b_sos},
    {"ss", (MethodPointer)b_ss},
    {"ss_oi4osi4u1u1u1u1_", (MethodPointer)b_ss_oi4osi4u1u1u1u1_},
    {"ssbs", (MethodPointer)b_ssbs},
    {"sso", (MethodPointer)b_sso},
    {"u2os", (MethodPointer)b_u2os},
    {"u4os", (MethodPointer)b_u4os},
    {"u4u4pu4", (MethodPointer)b_u4u4pu4},
    {"u8os", (MethodPointer)b_u8os},
    {"v", (MethodPointer)b_v},
    {"vO", (MethodPointer)b_vO},
    {"vODo", (MethodPointer)b_vODo},
    {"vOO", (MethodPointer)b_vOO},
    {"vOb", (MethodPointer)b_vOb},
    {"vOo", (MethodPointer)b_vOo},
    {"vOoi4", (MethodPointer)b_vOoi4},
    {"vOsO", (MethodPointer)b_vOsO},
    {"vOs_Oi4_", (MethodPointer)b_vOs_Oi4_},
    {"vOs_Oi4_o", (MethodPointer)b_vOs_Oi4_o},
    {"vPs_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_", (MethodPointer)b_vPs_Pvi4i4i4pi4i4oi4Pvi4i4i4pi4i4oi4_},
    {"vb", (MethodPointer)b_vb},
    {"vbbi4", (MethodPointer)b_vbbi4},
    {"vbs", (MethodPointer)b_vbs},
    {"vbso", (MethodPointer)b_vbso},
    {"vi4", (MethodPointer)b_vi4},
    {"vi4O", (MethodPointer)b_vi4O},
    {"vi4b", (MethodPointer)b_vi4b},
    {"vi4i4", (MethodPointer)b_vi4i4},
    {"vi4i4i4p", (MethodPointer)b_vi4i4i4p},
    {"vi4i8i8b", (MethodPointer)b_vi4i8i8b},
    {"vi4o", (MethodPointer)b_vi4o},
    {"vi4oi4i4", (MethodPointer)b_vi4oi4i4},
    {"vi4ooo", (MethodPointer)b_vi4ooo},
    {"vi4popO", (MethodPointer)b_vi4popO},
    {"vi4popo", (MethodPointer)b_vi4popo},
    {"vi4s", (MethodPointer)b_vi4s},
    {"vi4s_r4r4r4_s_r4r4r4r4_r4i4", (MethodPointer)b_vi4s_r4r4r4_s_r4r4r4r4_r4i4},
    {"vi4s_r4r4r4r4_", (MethodPointer)b_vi4s_r4r4r4r4_},
    {"vi4u4u4", (MethodPointer)b_vi4u4u4},
    {"vi8", (MethodPointer)b_vi8},
    {"vi8i4", (MethodPointer)b_vi8i4},
    {"vi8i8", (MethodPointer)b_vi8i8},
    {"vi8o", (MethodPointer)b_vi8o},
    {"vo", (MethodPointer)b_vo},
    {"voO", (MethodPointer)b_voO},
    {"vob", (MethodPointer)b_vob},
    {"voi4", (MethodPointer)b_voi4},
    {"voi4i4", (MethodPointer)b_voi4i4},
    {"voi4o", (MethodPointer)b_voi4o},
    {"voi4oo", (MethodPointer)b_voi4oo},
    {"voi4s_r4r4_", (MethodPointer)b_voi4s_r4r4_},
    {"voi8", (MethodPointer)b_voi8},
    {"voi8i8i8i8i8i8i8", (MethodPointer)b_voi8i8i8i8i8i8i8},
    {"voo", (MethodPointer)b_voo},
    {"vooi4", (MethodPointer)b_vooi4},
    {"vooi8", (MethodPointer)b_vooi8},
    {"vooo", (MethodPointer)b_vooo},
    {"voooo", (MethodPointer)b_voooo},
    {"vooooo", (MethodPointer)b_vooooo},
    {"voooooo", (MethodPointer)b_voooooo},
    {"vooooooo", (MethodPointer)b_vooooooo},
    {"voooooooo", (MethodPointer)b_voooooooo},
    {"vooooooooo", (MethodPointer)b_vooooooooo},
    {"voooooooooo", (MethodPointer)b_voooooooooo},
    {"vooooooooooo", (MethodPointer)b_vooooooooooo},
    {"voooooooooooo", (MethodPointer)b_voooooooooooo},
    {"vooooooooooooo", (MethodPointer)b_vooooooooooooo},
    {"voooooooooooooo", (MethodPointer)b_voooooooooooooo},
    {"vooooooooooooooo", (MethodPointer)b_vooooooooooooooo},
    {"voooooooooooooooo", (MethodPointer)b_voooooooooooooooo},
    {"voos", (MethodPointer)b_voos},
    {"vor4", (MethodPointer)b_vor4},
    {"vor8", (MethodPointer)b_vor8},
    {"vos", (MethodPointer)b_vos},
    {"vos_Pvi4i4i4pi4i4oi4_", (MethodPointer)b_vos_Pvi4i4i4pi4i4oi4_},
    {"vos_i4_", (MethodPointer)b_vos_i4_},
    {"vos_i4_ob", (MethodPointer)b_vos_i4_ob},
    {"vos_i4i4i4i4_b", (MethodPointer)b_vos_i4i4i4i4_b},
    {"vos_oi4osi4u1u1u1u1_", (MethodPointer)b_vos_oi4osi4u1u1u1u1_},
    {"vos_r4r4_", (MethodPointer)b_vos_r4r4_},
    {"vos_r4r4_r4", (MethodPointer)b_vos_r4r4_r4},
    {"vos_r4r4r4_", (MethodPointer)b_vos_r4r4r4_},
    {"vos_r4r4r4r4_", (MethodPointer)b_vos_r4r4r4r4_},
    {"vos_sosi4i4i4i4i4_i4", (MethodPointer)b_vos_sosi4i4i4i4i4_i4},
    {"vosb", (MethodPointer)b_vosb},
    {"vosbsr4oo", (MethodPointer)b_vosbsr4oo},
    {"voso", (MethodPointer)b_voso},
    {"voss_i4i4i4i4_b", (MethodPointer)b_voss_i4i4i4i4_b},
    {"vou1s", (MethodPointer)b_vou1s},
    {"vou4", (MethodPointer)b_vou4},
    {"vp", (MethodPointer)b_vp},
    {"vpi4", (MethodPointer)b_vpi4},
    {"vpi4ppi8", (MethodPointer)b_vpi4ppi8},
    {"vpi4u4u4", (MethodPointer)b_vpi4u4u4},
    {"vpi8", (MethodPointer)b_vpi8},
    {"vpppi4", (MethodPointer)b_vpppi4},
    {"vpppi4i8", (MethodPointer)b_vpppi4i8},
    {"vpr4r4r4r4r4r4", (MethodPointer)b_vpr4r4r4r4r4r4},
    {"vpu2i4p", (MethodPointer)b_vpu2i4p},
    {"vpu4", (MethodPointer)b_vpu4},
    {"vpu4u4", (MethodPointer)b_vpu4u4},
    {"vpu4u4u4i4", (MethodPointer)b_vpu4u4u4i4},
    {"vr4", (MethodPointer)b_vr4},
    {"vr4Ps_r4r4r4r4_Pr4Pr4", (MethodPointer)b_vr4Ps_r4r4r4r4_Pr4Pr4},
    {"vr4b", (MethodPointer)b_vr4b},
    {"vs", (MethodPointer)b_vs},
    {"vs_Oi4_", (MethodPointer)b_vs_Oi4_},
    {"vs__", (MethodPointer)b_vs__},
    {"vs_i4_", (MethodPointer)b_vs_i4_},
    {"vs_i4_b", (MethodPointer)b_vs_i4_b},
    {"vs_i4_i4", (MethodPointer)b_vs_i4_i4},
    {"vs_i4_i4i4", (MethodPointer)b_vs_i4_i4i4},
    {"vs_i4_s", (MethodPointer)b_vs_i4_s},
    {"vs_i4_s_Pvi4i4i4pi4i4oi4_", (MethodPointer)b_vs_i4_s_Pvi4i4i4pi4i4oi4_},
    {"vs_i4_s_i4_", (MethodPointer)b_vs_i4_s_i4_},
    {"vs_i4i4_", (MethodPointer)b_vs_i4i4_},
    {"vs_i4i4i4pi4i4i4_o", (MethodPointer)b_vs_i4i4i4pi4i4i4_o},
    {"vs_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_", (MethodPointer)b_vs_i4i4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4i4u8_},
    {"vs_i4i8_", (MethodPointer)b_vs_i4i8_},
    {"vs_i4i8_o", (MethodPointer)b_vs_i4i8_o},
    {"vs_i4o_", (MethodPointer)b_vs_i4o_},
    {"vs_i4oooo_", (MethodPointer)b_vs_i4oooo_},
    {"vs_i4osu8i8_", (MethodPointer)b_vs_i4osu8i8_},
    {"vs_i4r4r4i4_", (MethodPointer)b_vs_i4r4r4i4_},
    {"vs_i4ss_", (MethodPointer)b_vs_i4ss_},
    {"vs_i4u1u1_", (MethodPointer)b_vs_i4u1u1_},
    {"vs_i8i8_", (MethodPointer)b_vs_i8i8_},
    {"vs_oo_", (MethodPointer)b_vs_oo_},
    {"vs_oob_", (MethodPointer)b_vs_oob_},
    {"vs_oooObr4r4r4r4bb_", (MethodPointer)b_vs_oooObr4r4r4r4bb_},
    {"vs_ossi4i4i4i4o_", (MethodPointer)b_vs_ossi4i4i4i4o_},
    {"vs_pi4_", (MethodPointer)b_vs_pi4_},
    {"vs_pi4_o", (MethodPointer)b_vs_pi4_o},
    {"vs_ppi4i4_o", (MethodPointer)b_vs_ppi4i4_o},
    {"vs_pu4_", (MethodPointer)b_vs_pu4_},
    {"vs_r4r4_", (MethodPointer)b_vs_r4r4_},
    {"vs_r4r4oi4_", (MethodPointer)b_vs_r4r4oi4_},
    {"vs_r4r4r4_", (MethodPointer)b_vs_r4r4r4_},
    {"vs_r4r4r4r4_", (MethodPointer)b_vs_r4r4r4r4_},
    {"vs_r4r4r4r4_i4", (MethodPointer)b_vs_r4r4r4r4_i4},
    {"vs_r4r4r4r4_i4bb", (MethodPointer)b_vs_r4r4r4r4_i4bb},
    {"vs_r4r4r4r4_o", (MethodPointer)b_vs_r4r4r4r4_o},
    {"vs_r4r4r4r4_oo", (MethodPointer)b_vs_r4r4r4r4_oo},
    {"vs_so_", (MethodPointer)b_vs_so_},
    {"vs_soo_", (MethodPointer)b_vs_soo_},
    {"vs_ss_", (MethodPointer)b_vs_ss_},
    {"vs_u4u4u4u4_o", (MethodPointer)b_vs_u4u4u4u4_o},
    {"vs_u8_", (MethodPointer)b_vs_u8_},
    {"vs_u8b_", (MethodPointer)b_vs_u8b_},
    {"vs_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_", (MethodPointer)b_vs_u8u8ooi4i4u8r4r4r4r4r4r4r4r4r4r4_},
    {"vsb", (MethodPointer)b_vsb},
    {"vsbs", (MethodPointer)b_vsbs},
    {"vsbs_Pvi4i4i4pi4i4oi4i4i4i4_", (MethodPointer)b_vsbs_Pvi4i4i4pi4i4oi4i4i4i4_},
    {"vsi4", (MethodPointer)b_vsi4},
    {"vsi8", (MethodPointer)b_vsi8},
    {"vso", (MethodPointer)b_vso},
    {"vsoo", (MethodPointer)b_vsoo},
    {"vss", (MethodPointer)b_vss},
    {"vss_r4r4r4r4_", (MethodPointer)b_vss_r4r4r4r4_},
    {"vssi4", (MethodPointer)b_vssi4},
    {"vsso", (MethodPointer)b_vsso},
    {"vssoo", (MethodPointer)b_vssoo},
    {"vu1", (MethodPointer)b_vu1},
    {"vu4", (MethodPointer)b_vu4},
    {"vu4u4Ps_ppi4i4p_", (MethodPointer)b_vu4u4Ps_ppi4i4p_},
    {"vu4u4u4i4", (MethodPointer)b_vu4u4u4i4},
    {"vu8o", (MethodPointer)b_vu8o},
    {nullptr, nullptr}
};


static void ifg_b(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_b");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    bool ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_b(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_b");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal P any
    bool p = converter::Converter<bool>::toCpp(context, info[0]);
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_i4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_i4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    int32_t ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_i4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_i4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal P any
    int32_t p = converter::Converter<int32_t>::toCpp(context, info[0]);
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_i8(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_i8");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    int64_t ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
}

static void ifs_i8(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_i8");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal P any
    int64_t p = converter::Converter<int64_t>::toCpp(context, info[0]);
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_o(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_o");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    void* ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
}

static void ifs_o(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_o");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal o/O
    void* p = JsValueToCSRef(context, info[0], TIp);
    FieldSet(nullptr, fieldInfo, offset, p);
}

static void ifg_r4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_r4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    float ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_r4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_r4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal P any
    float p = converter::Converter<float>::toCpp(context, info[0]);
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_r8(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_r8");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    double ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_r8(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_r8");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal P any
    double p = converter::Converter<double>::toCpp(context, info[0]);
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_s(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_s");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    void* ret;

    FieldGet(nullptr, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
}

static void ifs_s(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_s");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal s
    v8::String::Utf8Value tp(isolate, info[0]);
    void* p = CStringToCSharpString(*tp);
    FieldSet(nullptr, fieldInfo, offset, p);
}

static void ifg_s_i4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_s_i4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    auto ret = GetValueTypeFieldPtr(nullptr, fieldInfo, offset);
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_s_i4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_s_i4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal struct
    s_i4_* pp = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p = pp ? *pp : s_i4_ {};
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_s_i4i4r4u1u1u1u1_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_s_i4i4r4u1u1u1u1_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    auto ret = GetValueTypeFieldPtr(nullptr, fieldInfo, offset);
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_s_i4i4r4u1u1u1u1_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_s_i4i4r4u1u1u1u1_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal struct
    s_i4i4r4u1u1u1u1_* pp = DataTransfer::GetPointer<s_i4i4r4u1u1u1u1_>(context, info[0]);
    s_i4i4r4u1u1u1u1_ p = pp ? *pp : s_i4i4r4u1u1u1u1_ {};
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_s_i8i8i8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_s_i8i8i8_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    auto ret = GetValueTypeFieldPtr(nullptr, fieldInfo, offset);
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_s_i8i8i8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_s_i8i8i8_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal struct
    s_i8i8i8_* pp = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p = pp ? *pp : s_i8i8i8_ {};
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_s_i8i8i8i8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_s_i8i8i8i8_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    auto ret = GetValueTypeFieldPtr(nullptr, fieldInfo, offset);
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_s_i8i8i8i8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_s_i8i8i8i8_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal struct
    s_i8i8i8i8_* pp = DataTransfer::GetPointer<s_i8i8i8i8_>(context, info[0]);
    s_i8i8i8i8_ p = pp ? *pp : s_i8i8i8i8_ {};
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_s_pu4u4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_s_pu4u4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    auto ret = GetValueTypeFieldPtr(nullptr, fieldInfo, offset);
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_s_pu4u4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_s_pu4u4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal struct
    s_pu4u4_* pp = DataTransfer::GetPointer<s_pu4u4_>(context, info[0]);
    s_pu4u4_ p = pp ? *pp : s_pu4u4_ {};
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_s_r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_s_r4r4r4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    auto ret = GetValueTypeFieldPtr(nullptr, fieldInfo, offset);
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_s_r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_s_r4r4r4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal struct
    s_r4r4r4_* pp = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p = pp ? *pp : s_r4r4r4_ {};
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_s_r4r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_s_r4r4r4r4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
    auto ret = GetValueTypeFieldPtr(nullptr, fieldInfo, offset);
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_s_r4r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_s_r4r4r4r4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();
        // JSValToCSVal struct
    s_r4r4r4r4_* pp = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p = pp ? *pp : s_r4r4r4r4_ {};
    FieldSet(nullptr, fieldInfo, offset, &p);
}

static void ifg_tO(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_tO");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    void* ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
}

static void ifs_tO(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_tO");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal o/O
    void* p = JsValueToCSRef(context, info[0], TIp);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_tb(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_tb");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    bool ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_tb(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_tb");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    bool p = converter::Converter<bool>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ti2(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ti2");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    int16_t ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_ti2(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ti2");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    int16_t p = converter::Converter<int16_t>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ti4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ti4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    int32_t ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_ti4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ti4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    int32_t p = converter::Converter<int32_t>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ti8(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ti8");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    int64_t ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(v8::BigInt::New(isolate, ret));
}

static void ifs_ti8(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ti8");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    int64_t p = converter::Converter<int64_t>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_to(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_to");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    void* ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(CSRefToJsValue(isolate, context, ret));
}

static void ifs_to(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_to");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal o/O
    void* p = JsValueToCSRef(context, info[0], TIp);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_tp(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_tp");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    void* ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(v8::ArrayBuffer::New(isolate, v8::ArrayBuffer::NewBackingStore(ret, 0, &v8::BackingStore::EmptyDeleter, nullptr)));
}

static void ifs_tp(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_tp");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    void* p = DataTransfer::GetPointer<void>(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_tr4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_tr4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    float ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_tr4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_tr4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    float p = converter::Converter<float>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_tr8(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_tr8");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    double ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_tr8(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_tr8");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    double p = converter::Converter<double>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    void* ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(CSAnyToJsValue(isolate, context, ret));
}

static void ifs_ts(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal s
    v8::String::Utf8Value tp(isolate, info[0]);
    void* p = CStringToCSharpString(*tp);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_Pvi4i4i4pi4i4oi4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_Pvi4i4i4pi4i4oi4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_Pvi4i4i4pi4i4oi4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_Pvi4i4i4pi4i4oi4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_Pvi4i4i4pi4i4oi4_* pp = DataTransfer::GetPointer<s_Pvi4i4i4pi4i4oi4_>(context, info[0]);
    s_Pvi4i4i4pi4i4oi4_ p = pp ? *pp : s_Pvi4i4i4pi4i4oi4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_bi4u1u1u1u1_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_bi4u1u1u1u1_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_bi4u1u1u1u1_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_bi4u1u1u1u1_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_bi4u1u1u1u1_* pp = DataTransfer::GetPointer<s_bi4u1u1u1u1_>(context, info[0]);
    s_bi4u1u1u1u1_ p = pp ? *pp : s_bi4u1u1u1u1_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_br4r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_br4r4r4r4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_br4r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_br4r4r4r4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_br4r4r4r4_* pp = DataTransfer::GetPointer<s_br4r4r4r4_>(context, info[0]);
    s_br4r4r4r4_ p = pp ? *pp : s_br4r4r4r4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_* pp = DataTransfer::GetPointer<s_bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_>(context, info[0]);
    s_bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_ p = pp ? *pp : s_bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_i4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_i4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_i4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_i4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_i4_* pp = DataTransfer::GetPointer<s_i4_>(context, info[0]);
    s_i4_ p = pp ? *pp : s_i4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_i4i4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_i4i4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_i4i4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_i4i4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_i4i4_* pp = DataTransfer::GetPointer<s_i4i4_>(context, info[0]);
    s_i4i4_ p = pp ? *pp : s_i4i4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_i4i4i4i4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_i4i4i4i4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_i4i4i4i4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_i4i4i4i4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_i4i4i4i4_* pp = DataTransfer::GetPointer<s_i4i4i4i4_>(context, info[0]);
    s_i4i4i4i4_ p = pp ? *pp : s_i4i4i4i4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_i4p_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_i4p_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_i4p_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_i4p_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_i4p_* pp = DataTransfer::GetPointer<s_i4p_>(context, info[0]);
    s_i4p_ p = pp ? *pp : s_i4p_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_i4r4r4r4r4r4i4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_i4r4r4r4r4r4i4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_i4r4r4r4r4r4i4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_i4r4r4r4r4r4i4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_i4r4r4r4r4r4i4_* pp = DataTransfer::GetPointer<s_i4r4r4r4r4r4i4_>(context, info[0]);
    s_i4r4r4r4r4r4i4_ p = pp ? *pp : s_i4r4r4r4r4r4i4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_i4u1u1u1u1_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_i4u1u1u1u1_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_i4u1u1u1u1_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_i4u1u1u1u1_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_i4u1u1u1u1_* pp = DataTransfer::GetPointer<s_i4u1u1u1u1_>(context, info[0]);
    s_i4u1u1u1u1_ p = pp ? *pp : s_i4u1u1u1u1_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_i8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_i8_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_i8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_i8_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_i8_* pp = DataTransfer::GetPointer<s_i8_>(context, info[0]);
    s_i8_ p = pp ? *pp : s_i8_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_i8i8i8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_i8i8i8_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_i8i8i8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_i8i8i8_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_i8i8i8_* pp = DataTransfer::GetPointer<s_i8i8i8_>(context, info[0]);
    s_i8i8i8_ p = pp ? *pp : s_i8i8i8_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_r4r4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_r4r4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_r4r4_* pp = DataTransfer::GetPointer<s_r4r4_>(context, info[0]);
    s_r4r4_ p = pp ? *pp : s_r4r4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_r4r4r4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_r4r4r4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_r4r4r4_* pp = DataTransfer::GetPointer<s_r4r4r4_>(context, info[0]);
    s_r4r4r4_ p = pp ? *pp : s_r4r4r4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_r4r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_r4r4r4r4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_r4r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_r4r4r4r4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_r4r4r4r4_* pp = DataTransfer::GetPointer<s_r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4_ p = pp ? *pp : s_r4r4r4r4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_* pp = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_ p = pp ? *pp : s_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_* pp = DataTransfer::GetPointer<s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_>(context, info[0]);
    s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ p = pp ? *pp : s_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_u4u4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_u4u4_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_u4u4_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_u4u4_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_u4u4_* pp = DataTransfer::GetPointer<s_u4u4_>(context, info[0]);
    s_u4u4_ p = pp ? *pp : s_u4u4_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_ts_u8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_ts_u8_");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    auto ret = (char*)self + offset;
    
    info.GetReturnValue().Set(DataTransfer::FindOrAddCData(isolate, context, TIret, ret, true));
}

static void ifs_ts_u8_(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_ts_u8_");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal struct
    s_u8_* pp = DataTransfer::GetPointer<s_u8_>(context, info[0]);
    s_u8_ p = pp ? *pp : s_u8_ {};
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_tu1(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_tu1");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    uint8_t ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_tu1(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_tu1");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    uint8_t p = converter::Converter<uint8_t>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_tu4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_tu4");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    uint32_t ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(ret);
}

static void ifs_tu4(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_tu4");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    uint32_t p = converter::Converter<uint32_t>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static void ifg_tu8(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIret) {
    // PLog(LogLevel::Log, "Running ifg_tu8");

    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

    uint64_t ret;

    FieldGet(self, fieldInfo, offset, &ret);
    
    info.GetReturnValue().Set(v8::BigInt::NewFromUnsigned(isolate, ret));
}

static void ifs_tu8(const v8::FunctionCallbackInfo<v8::Value>& info, void* fieldInfo, size_t offset, void* TIp) {
    // PLog(LogLevel::Log, "Running ifs_tu8");
    
    v8::Isolate* isolate = info.GetIsolate();
    v8::Local<v8::Context> context = isolate->GetCurrentContext();

    auto self = puerts::DataTransfer::GetPointerFast<void>(info.Holder());

        // JSValToCSVal P any
    uint64_t p = converter::Converter<uint64_t>::toCpp(context, info[0]);
    FieldSet(self, fieldInfo, offset, &p);
}

static FieldWrapFuncInfo g_fieldWrapFuncInfos[] = {
    
    {"b", ifg_b, ifs_b},
    {"i4", ifg_i4, ifs_i4},
    {"i8", ifg_i8, ifs_i8},
    {"o", ifg_o, ifs_o},
    {"r4", ifg_r4, ifs_r4},
    {"r8", ifg_r8, ifs_r8},
    {"s", ifg_s, ifs_s},
    {"s_i4_", ifg_s_i4_, ifs_s_i4_},
    {"s_i4i4r4u1u1u1u1_", ifg_s_i4i4r4u1u1u1u1_, ifs_s_i4i4r4u1u1u1u1_},
    {"s_i8i8i8_", ifg_s_i8i8i8_, ifs_s_i8i8i8_},
    {"s_i8i8i8i8_", ifg_s_i8i8i8i8_, ifs_s_i8i8i8i8_},
    {"s_pu4u4_", ifg_s_pu4u4_, ifs_s_pu4u4_},
    {"s_r4r4r4_", ifg_s_r4r4r4_, ifs_s_r4r4r4_},
    {"s_r4r4r4r4_", ifg_s_r4r4r4r4_, ifs_s_r4r4r4r4_},
    {"tO", ifg_tO, ifs_tO},
    {"tb", ifg_tb, ifs_tb},
    {"ti2", ifg_ti2, ifs_ti2},
    {"ti4", ifg_ti4, ifs_ti4},
    {"ti8", ifg_ti8, ifs_ti8},
    {"to", ifg_to, ifs_to},
    {"tp", ifg_tp, ifs_tp},
    {"tr4", ifg_tr4, ifs_tr4},
    {"tr8", ifg_tr8, ifs_tr8},
    {"ts", ifg_ts, ifs_ts},
    {"ts_Pvi4i4i4pi4i4oi4_", ifg_ts_Pvi4i4i4pi4i4oi4_, ifs_ts_Pvi4i4i4pi4i4oi4_},
    {"ts_bi4u1u1u1u1_", ifg_ts_bi4u1u1u1u1_, ifs_ts_bi4u1u1u1u1_},
    {"ts_br4r4r4r4_", ifg_ts_br4r4r4r4_, ifs_ts_br4r4r4r4_},
    {"ts_bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_", ifg_ts_bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_, ifs_ts_bu1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1u1i2i4i4r4u1u1u1u1u1i1u1u1u1u1u1u1u1u1u1u1u1u1i4i4_},
    {"ts_i4_", ifg_ts_i4_, ifs_ts_i4_},
    {"ts_i4i4_", ifg_ts_i4i4_, ifs_ts_i4i4_},
    {"ts_i4i4i4i4_", ifg_ts_i4i4i4i4_, ifs_ts_i4i4i4i4_},
    {"ts_i4p_", ifg_ts_i4p_, ifs_ts_i4p_},
    {"ts_i4r4r4r4r4r4i4_", ifg_ts_i4r4r4r4r4r4i4_, ifs_ts_i4r4r4r4r4r4i4_},
    {"ts_i4u1u1u1u1_", ifg_ts_i4u1u1u1u1_, ifs_ts_i4u1u1u1u1_},
    {"ts_i8_", ifg_ts_i8_, ifs_ts_i8_},
    {"ts_i8i8i8_", ifg_ts_i8i8i8_, ifs_ts_i8i8i8_},
    {"ts_r4r4_", ifg_ts_r4r4_, ifs_ts_r4r4_},
    {"ts_r4r4r4_", ifg_ts_r4r4r4_, ifs_ts_r4r4r4_},
    {"ts_r4r4r4r4_", ifg_ts_r4r4r4r4_, ifs_ts_r4r4r4r4_},
    {"ts_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_", ifg_ts_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_, ifs_ts_r4r4r4r4r4r4r4r4br4r4r4r4u4i4i4b_},
    {"ts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_", ifg_ts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_, ifs_ts_r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4r4_},
    {"ts_u4u4_", ifg_ts_u4u4_, ifs_ts_u4u4_},
    {"ts_u8_", ifg_ts_u8_, ifs_ts_u8_},
    {"tu1", ifg_tu1, ifs_tu1},
    {"tu4", ifg_tu4, ifs_tu4},
    {"tu8", ifg_tu8, ifs_tu8},
    {nullptr, nullptr, nullptr}    
};

